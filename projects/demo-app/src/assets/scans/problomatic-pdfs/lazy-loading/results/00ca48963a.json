{"statistics":{"identical":0,"minorChanges":49,"relatedMeaning":27},"text":{"comparison":{"identical":{"source":{"chars":{"starts":[],"lengths":[]},"words":{"starts":[],"lengths":[]}},"suspected":{"chars":{"starts":[],"lengths":[]},"words":{"starts":[],"lengths":[]}}},"minorChanges":{"source":{"chars":{"starts":[669367,669995],"lengths":[122,179]},"words":{"starts":[101552,101650],"lengths":[22,25]}},"suspected":{"chars":{"starts":[53613,54674],"lengths":[119,144]},"words":{"starts":[8227,8384],"lengths":[21,19]}}},"relatedMeaning":{"source":{"chars":{"starts":[669170],"lengths":[196]},"words":{"starts":[101525],"lengths":[26]}},"suspected":{"chars":{"starts":[53363],"lengths":[166]},"words":{"starts":[8190],"lengths":[23]}}}},"value":"Voxel-based Solid Models:\nRepresentation, Display and Geometric\nAnalysis\nM. Tech Dissertation\nSubmitted in partial fulfillment of the requirements for the award of the degree of\n\nMaster of Technology\n(Manufacturing Engineering)\n\nby\n\nSandeep Sudhir Patil\n(Roll No. 03310002)\nunder the guidance of\n\nProf. B. Ravi\n\nDepartment of Mechanical Engineering\nIndian Institute of Technology, Bombay\nMumbai – 400076\nJune 2005\n\nAbstract\n\n‘Voxel’ stands for ‘volumetric element’ or ‘volumetric pixel’ and is a three-dimensional\nelement analogous to what pixels are in two-dimensions. ‘Volumetric modeling’ in the\nform of exhaustive enumeration of voxels is becoming popular in CAD/CAM/CAE\nworld, owing to its superiority over traditional solid models especially for free form\nmodeling (volumetric modeling, display and analysis).\nIn this work, a new generic voxel based volumetric modeling and visualization system\nhas been developed. The binary voxel model is stored as a stack of voxel layers\nrepresented as ‘bit-arrays’. The process of ‘voxelization’ converts polygonal solid model\nto the voxel format. The voxelization gives satisfactory results in terms of memory\nconsumption and processing time for voxel resolutions up to 1000 – overall volume of 1\nbillion voxels. Voxel resolution can be set as per application requirement. A new\nalgorithm has been developed for visualization of the voxel model using direct point\nbased rendering. This uses look-up table to generate realistic rendering. The images\ngenerated are better than simple cube face display which gives blocky appearance. Low\nlevel functions that operate on the voxel data are written to perform geometric\ncomputation and reasoning. With this, functions to perform sectional-display, X-ray scan\nand skin-removal simulation have been developed. The algorithms have been tested for\ncomplex free-form models like a ‘Ganehsa’ and a Pelvic bone model along with other\nengineering models. The outcome is a new basic voxel based modeling framework which\ncan be extended and coupled to standard solid modeling systems as a supplement\nproviding additional capabilities to traditional surface based systems.\nKeywords- Voxel, Solid modeling, Volume modeling, Free-form, Geometric reasoning.\n\ni\n\nContents\nChapter No.\n\nTitle\n\nPage No.\n\nAbstract\n\ni\n\nList of tables\n\nv\n\nList of figures\n\nvii\n\n1 Introduction\n\n1-5\n\n1.1 Solid modeling\n1.2 Voxel based modeling\n1.3 Report organization\n\n2\n3\n5\n\n2 Literature review\n\n6-31\n\n2.1 Volume representation methods\n2.2 Volume graphics\n2.3 Voxel model representations\n2.3.1 Discrete Cell Enumeration\n2.3.2 Octree representation\n2.3.3 Array representation\n2.4 Voxelization\n2.4.1 Essential characteristics of Voxelization\nalgorithm\n2.4.2 Scan conversion algorithm\n2.4.3 Implicit functions\n2.4.4 Distance shells and fields\n2.4.5 Parity count method\n2.4.6 Ray stabbing\n2.5 Volumetric display (rendering)\n2.5.1 Classifying volume rendering methods\n2.5.2 Indirect methods\n2.5.3 Direct methods for the display of surfaces in binary data\n2.5.4 Display algorithms for grey-scale data\n2.5.5 Radiosity\n2.6 Applications of Voxel (Volume) based modeling\n2.6.1 Scientific data set visualization\n2.6.2 Amorphous entity visualization\n2.6.3 Representing solid interiors\n2.6.4 Visualizing volume data\n\nii\n\n6\n8\n9\n9\n10\n11\n12\n13\n13\n14\n14\n15\n15\n16\n16\n17\n19\n22\n23\n24\n24\n26\n26\n27\n\n2.6.5 Haptic modeling and rendering\n2.7 Summery of Literature survey\n3 Problem definition\n\n29\n29\n32-38\n\n3.1 Motivation\n3.2 Study of present voxel based modeling systems\n3.2.1 FreeForm Modeling Plus\n3.2.2 3D Doctor\n3.2.3 MIMICS\n3.3 Objective and scope\n3.4 Approach\n4 Voxel data structure and voxelization\n4.1 Voxel data set\n4.2 Voxel data structure\n4.2.1 Bit array\n4.2.2 Voxel data on disc\n4.3 Voxelization\n4.3.1 Voxelization algorithm\n4.3.2 Modified Voxelization algorithm\n4.3.3 Errors in voxelization\n5 Voxel display and analysis\n\n32\n33\n33\n34\n35\n37\n37\n39-48\n39\n40\n41\n43\n43\n43\n46\n46\n49-56\n\n5.1 Intensity look-up table\n5.2 Geometric analysis of voxel model\n5.2.1 Progressive sectional display\n5.2.2 Skin removal simulation\n5.2.3 X-ray scan\n\n49\n54\n55\n55\n56\n\n6 Implementation and results\n\n57-73\n\n6.1 Voxelization\n6.2 Voxel display\n6.3 Voxel section display\n6.4 Skin removal\n6.5 X-ray scan display\n\n57\n63\n69\n70\n71\n\n7 Conclusions\n\n74-75\n\n7.1 Summary of work done\n7.2 Future scope\n\n74\n75\n\niii\n\nAppendix\n\n76-78\n\nA. ‘STL’ file format\nB. 3D discrete topology\n\n76\n77\n\nReferences\n\n79-80\n\nAcknowledgement\n\n81\n\niv\n\nList of figures\nFig. No.\n\nFigure title\n\nPage No.\n\n2.1\n\nVolume representation methods\n\n7\n\n2.3.2\n\nQuadtree and Octree architecture\n\n11\n\n2.5.1\n\nClassification of volume rendering methods\n\n17\n\n2.5.3\n\nDirect volumetric rendering\n\n22\n\n2.6.1\n\nVolumetric analysis and visualization\n\n24\n\n2.6.2\n\nAmorphous entity visualization\n\n26\n\n2.6.3\n\nMapping human body anatomy\n\n26\n\n2.6.4\n\nSolid model from CT scan data slices\n\n27\n\n2.6.5\n\nHaptic modeling and rendering\n\n29\n\n3.2.1\n\nModeling in FreeForm modeling Plus 7.1\n\n33\n\n3.2.2\n\nVolume Rendering in 3D Doctor\n\n35\n\n3.2.3\n\nMIMICS software interface\n\n36\n\n4.2.1\n\nStack of ‘planes’ holding bit-array\n\n41\n\n4.3.1\n\nSteps to initialize voxelization\n\n44\n\n4.3.2\n\nVoxelization algorithm\n\n45\n\n4.3.3\n\nErrors in voxelization caused by thin sections\n\n47\n\n4.3.4\n\nImage showing errors in voxelization\n\n48\n\n5.1\n\nFace connected neighbouring voxels\n\n50\n\n5.2\n\nVoxel intensities for a sphere\n\n52\n\n5.2.1\n\nProgressive sectional display\n\n55\n\n5.2.2\n\nSuccessive skin removal simulation\n\n56\n\n5.2.3\n\nX-ray scan: Intensity variations proportional to thickness\n\n56\n\n6.1.1\n\nTime for Voxelization of standard shapes\nwith different resolution\n\n6.1.2\n\n59\n\nTime for Voxelization of various solid models\nwith different resolution\n\n6.1.3\n\n61\n\nMemory required for Voxelization of standard shapes and\nvarious solid models with different resolution respectively\n\nv\n\n62\n\nList of figures (Cont.)\nFig. No.\n\nFigure title\n\nPage No.\n\n6.2.1\n\nVoxel images with point-smooth Off and On (R=20)\n\n6.2.2\n\nVoxel images with Zoom and corresponding change of\n\n63\n\npoint size(S) (Resolution=200)\n\n63\n\n6.2.3\n\nVoxel images with different resolutions (R)\n\n64\n\n6.2.4\n\nVoxel images with different angles of rotation\nabout Y-axis (Resolution= 200)\n\n6.2.5\n\nVoxel model from the project and from FreeForm\n(Resolution= 200)\n\n6.2.6\n\n65\n\nVoxel display images of various solid models with\nresolution of 400\n\n6.2.7\n\n64\n\n66\n\nDisplay Images fro Ganesha model with different\nresolutions (R)\n\n67\n\n6.2.8\n\nDisplay Images of pelvis model with different resolutions(R)\n\n67\n\n6.2.9\n\nDisplay Images of cylinder block with different resolutions(R)\n\n68\n\n6.3\n\nSectional Display Images of cylinder block and\nGanesha model with different resolutions(R)\n\n6.4\n\nSuccessive Skin removal Images of cylinder block\nwith resolution 200\n\n6.5.1\n\n70\n\nX-ray scan images of Ganesha model with minimum,\nmaximum and total thickness options respectively (R=200)\n\n6.5.2\n\n69\n\n72\n\nX-ray scan images of Cylinder block model along two\ndirections and with different thickness options (R=200)\n\nvi\n\n73\n\nList of tables\nTable No. Table title\n\nPage No.\n\n1.1\n\nComparison of exact and approximate 3D model representations\n\n3\n\n4.2.1\n\nVoxel indices in bit-array for one Z-plane with resolution 100\n\n42\n\n5.1\n\nSample bit strings from neighbouring voxel configuration\n\n51\n\n5.2\n\nIntensity look-up table\n\n53\n\n6.1.1\n\nVoxelization results for standard shapes\n\n58\n\n6.1.2\n\nVoxelization results for various solid models\n\n60\n\nvii\n\nChapter 1\n\nIntroduction\n\nToday, the use of computers in various fields has gone well beyond mere data storage.\nEspecially in engineering, computers are extensively used for virtual product modeling,\nsimulations, manufacturing planning and control, knowledge management, automation\nand other allied business processes. The practices like CAD, CAM, CAE have developed\nenormously over last couple of decades, not only in terms of penetration into industry but\nthe underlying technologies as well. Similar trends of increasing computer applications\nare seen in other areas as well, like medical modeling and simulations, geological\nmodeling, environmental modeling and simulations. On the other side, non-engineering\nfields like animation and computer gaming, virtual reality, art, fashion and archeological\nmodeling are also using computers for making new generation designs. The drivers for\nthis growth of computer applications are innovations in the basic computer technology\nand hardware, and also the ever expanding business scope and complexities. The latest\npractices like collaborative engineering, product life cycle management and teleoperations demand more advances in the computer technology to enable faster and\nefficient communication across distances.\nIn engineering applications, a virtual model of product and assemblies is a must for all\nother computer integrated processes. Solid modeling is extensively used in engineering as\nwell as non-engineering areas such as medical modeling. The components and assemblies\ninvolved are getting more complex day by day. Hence, an efficient solid modeling\ntechnology is very fundamental for successful implementation of upstream applications.\nTraditionally surface representations were used for solid modeling as they are very\ncompact and just sufficient for many applications. But surface models lack volumetric\ninformation and do not cater easily for volumetric analysis and display. The need for\nvolumetric modeling and display was first recognized when medical scanning\ntechnologies like CT and MRI became popular. Other areas where volume modeling is\nused are scientific analysis of volumetric phenomenon like environmental and geological\nresearch.\n\n1\n\n1.1 Solid modeling\nSolid models come under the realm of 3D modeling. 3D modeling is a computerized\nrepresentation of physical objects in some suitable mathematic or abstract from. The 3D\nmodels from the basis for all CAE and CAM operations.\nThe 3D model world constitutes two fundamental aspects: Modeling and Representation.\nModeling is how the actual computer model is generated using some modeling software\npackage (For instance Pro-E, CATIA) or in a raw form by some 3D scanning (CAT, MRI,\nConfocal Microscopy, Radar imaging). Various methods used in 3D modeling include\n\n\nCSG (Constructive Solid Geometry)\n\n\nBreps (Boundary representation) and\n\n\nFeature based modeling\n\nRepresentation is the form of representation of the 3D model and way in which it is\nstored in the computer memory. Different schemes in practice for representing 3D models\nare\n\n\nSurface models\n\n\nWireframe models- Meshes and polygon (faceted models)\n\n\nDecomposition based (Octrees, BSP)\n\n\nVoxel based: ―Voxel‖ stands for ―volume element‖ or ―volume pixel‖. Voxel\nbased models represent solids as a three dimensional arrangement of discrete\nvolume elements.\n\nThe 3D representation schemes for sold models can be broadly classified as: Exact and\nApproximate representations.\nExact representation is precise model of object topology and mathematically represents\nall geometry. These include Wireframe, Parametric surfaces, and Solid models\nrepresented by CSG, BRep and implicit solid models. Here the object features are\nrepresented exclusively.\nApproximate representation involves discretization of the 3D objects and use of simple\nprimitives to model topology and geometry. These include Facet/ Mesh representing just\nsurfaces, Voxel models representing volumes.\n\n2\n\nThe comparative positives and negatives of exact and approximate representations are\ngiven in the following table 1.1.\nTable 1.1 Comparison of exact and approximate 3D model representations\nExact representation\n\nApproximate representation\nAdvantages\n\n\nPrecision: good for simulation, modeling\n\n\nEasy to implement\n\n\nLots of modeling environments\n\n\nEasy to acquire (3D scanner, CT)\n\n\nCompact\n\n\nEasy to render\n\n\nMany applications\n\n\nMany algorithms possible\n\nLimitations\n\n\nComplex data structures\n\n\nLoss of details\n\n\nExpensive algorithms\n\n\nData structure sizes can get huge, for\n\n\nWide variety of formats\n\n\nHard to acquire data\n\n\nEasy to break, cracks can appear\n\n\nTranslation required for rendering\n\n\nNot suitable for certain applications\n\ngood fidelity\n\n1.2 Voxel based modeling\n―Voxel‖ is a 3-dimensional element analogous to ―pixel‖ in 2D. In volumetric modeling\nan object is represented as a collection of voxels in 3D arrangement which may be regular\nor irregular. Cubic voxels in uniform grid aligned with the coordinate axes is the simplest\nand commonly used representation. The same is used in this project.\n―Volume visualization‖ is a very fast growing field in computer graphics driven by need\nfor analysing large volumetric data sets generated in scientific and medical projects.\nVolume visualization systems are used to create high-quality displays from scalar and\nvector datasets defined on multidimensional grids, usually for the purpose of gaining\ninsight into a scientific problem. Volume visualization also uses concept of voxels. But\nvoxels used in CAD application are little different in the sense that generally they are\nbinary models where voxel only represent status of object occupancy in the given volume.\n\n3\n\nVoxel based modeling is not new but it was not used to extent because of huge memory\nand processing capability required by computers to handle voxel models of sufficient\nresolution. But now with advances in computer hardware and architectures, we have\nsufficiently higher processing speed and cheaper memory that voxel models can be\nimplemented on desktop systems as well. It is expected that voxel based modeling will be\nused extensively in future in areas like CAD/CAM/CAE, medical imaging, scientific\nsimulations and visualizations, animations and non-engineering modeling, virtual reality\nsystems and tele-operations and controls etc. Some manufacturing related problems can\nbe better analysed using voxel based modeling [Lu, 1996] than conventional surface\nbased systems.\nThe focus of this work is on use of  ̳volumetric modeling‘ in CAD/CAE application for\nengineering/non-engineering components. A  ̳voxel‘ based model representation scheme\nhas been developed. The main goal of the project was to develop a voxel representation\nscheme efficient in terms of memory and processing and which serves voxel resolution up\nto 1000. That is an overall volume of 1 billion voxels. Though, in general, voxel models\nof resolution up to 400 are commonly used. A new visualization algorithm using point\nbased direct rendering is developed for displaying voxel model. The work is different\nfrom conventional  ̳Volume visualization‘ basically in terms of type of volume data\ninvolved and the purpose of visualization.\nA CAD model is usually defined in B-Rep format which is essentially a surface\nrepresentation. Such model is first converted into a  ̳volumetric model‘ representation by\nprocess of ―Voxelization‖. The voxel data generated is basically binary data in uniform\nCartesian grid. As this is a simple and low level representation of only geometry of\nobject, there are no data values (either scalar or vector) in volumetric form. Hence the\ndisplay algorithm sought was to just suffice efficient visualization of object geometry\nwith sufficient accuracy and realism. The availability of volumetric representation and\nvisualization in a CAD/CAE system allows great many possibilities in geometrical\nprocessing and analysis which are not easy to implement if not impossible, with\nconventional surface representations. Along with basic display functions, few low level\ngeometric reasoning functions are also written to operate on voxel model. Using such\nfunctions, section display, X-ray scan and skin-removal simulation module is also\ndeveloped.\n4\n\n1.3 Report organization\nThe detailed literature review regarding volumetric modeling and volume graphics is\npresented in chapter two. The chapter begins with fundamentals of volumetric modeling\nand its advantages and limitations. Various algorithms and methods proposed and\ndeveloped by researchers for voxel model representation and display are described.\nDescription of various voxelization algorithms is also included. The chapter ends with\napplications of voxel based modeling and summary of literature review.\nChapter three includes the problem definition, objectives and scope of the work. A short\ndescription of study of few existing voxel based modeling systems is included. The\nchapter ends with the description of approach followed in the work.\nChapters four and five include detailed description of the major work done in the project.\nThe new voxel model representation scheme and voxelization algorithm are explained in\nchapter four. While, chapter five describes the new voxel display algorithm developed.\nThe geometric reasoning and analysis functions implemented are included in chapter five.\nDetail results regarding time and memory required for voxelization are presented in\nchapter six. The results include testing on various engineering and non-engineering\nmodels. The chapter also includes numerous images of display of various voxel models\nusing the developed visualization algorithm with different settings. The outcome of the\ngeometric analysis functions is presented at the end of the chapter.\nConclusion and scope for future work is presented at end of the report.\n\n5\n\nChapter 2\n\nLiterature review\n\nVolume graphics and volumetric modeling are separate streams of research, but have\nconsiderable interlink. Over the last couple of decades, these fields have evolved\nenormously in terms of variety of technologies and depth as well. The chapter begins with\nevaluation of volumetric modeling and voxel based methods. This is followed by various\nvoxel based model representation techniques presently used. Then a detailed review of\nvarious voxelization and volumetric display algorithms is presented.\n\n2.1 Volume representation methods\nVolume representation for engineering models is essentially space occupancy information\nfor a given object. The information is  ̳Binary‘. It means that the space is either occupied\nby the object or is void. Following are the various methods used for volume\nrepresentation which are described in Figure 2.1.\n(a) Sweep volume\nSweeping a 2D area along a trajectory creates a new 3D object. The sweep may be\nTranslational, Tapered, Rotational or General 3D curve. Thus each volumetric segment is\ndefined by one  ̳section curve‘ which is a closed planar curve swept along  ̳sweep curve‘.\n(b) Binary Space Partitions (BSP)\nBSP involves partitioning 3D space by a sequence of planes successively dividing the\nspace into two halves each time. The tree representation of BSP is a binary tree with two\nchild nodes added as leaf nodes. A leaf node represents a homogeneous portion of spaceeither ―in‖ or ―out‖. Regions decrease in size along any tree path. It is easy to determine if\na point lies inside our outside the region by traversing the BSP tree.\n\n6\n\n(c) Constructive Solid Geometry (CSG)\nCombines simple primitives using Boolean operations and represents as a binary tree. The\nBoolean operations include Union, Intersection and Difference. To generate the object the\ntree is processed in a depth-first pass. The CSG representation may not be unique.\n(d) Boundary Representation (B-Rep)\nA closed 2D surface defines a 3D object. At ach point on the boundary there is an ―in‖\nand ―out‖ side. Boundary representations can be defined in two ways,  ̳Primitive based': a\ncollection of primitives forming the boundary (polygons, for example) and  ̳Freeform\nbased‘ (splines, parametric surfaces, implicit forms).\n(e) Spatial Occupancy Enumeration\nThis is a voxel based method. It is an extension of the concept of pixels into 3D. Space is\nconsidered as a regular array of cells (usually cubes). Each cell is called ―voxel‖. A 3D\nobject is represented as a list of object filled Voxels\n\nTranslational\nTapered\nSlanted\nRotational\nSolids by Sweep\n\nCSG\n\nVoxel enumeration\n\nBSP\n\nFig. 2.1 Volume representation methods\n7\n\n2.2 Volume graphics\nVolume graphics is an emerging subfield of computer graphics. It is concerned with the\nsynthesis, modeling, manipulation, and rendering of volumetric geometric objects, stored\nin a volume buffer of voxels. A volume representation that has general applicability is the\nexhaustive enumeration of the occupancy of elementary cells (voxels) that lie on a\nuniform 3D grid. For each cell, either a binary value indicating whether that cell is inside\nor outside the object (binary voxel model) or a numerical value representing some\nphysical quantity such as density (gray-value voxel model) is maintained. Usually a\nspatial ordering is imposed on the occupancy values by storing them in a 3D array. A 3D\narray (called also volume buffer, cubic frame buffer, 3D raster) is typically used to store\nthese values [Kaufman, 1993].\nDesired features of a modeling system\nSelection of a representation scheme for solid models for any application involves\nevaluating the following things [Jense, 1989]\n\n\nStorage cost\n\n\nDisplay complexities\n\n\nDesired manipulations\n\n\nData availability\n\n\nRepresentation conversions\n\nTypical manipulations that may be performed on geometric data are\nGeometric transformations (translation, rotation and scaling)\nModeling operations (Boolean set operations, re-slicing, spatial editing)\nNumerical analysis (extraction and quantification of parameters such as surface\narea, volume)\nFrom the above listed parameters, requirements of a good solid model representation\ncould be identified as\nAccurate\n\nEfficient Boolean operations\n\nConcise\n\nEfficient display\n\nAffine invariant\n\nIncorporate volume information\n\nEasy acquisition\n\nEasy to implement algorithms\n\nGuaranteed validity\n\nGood resolution variability\n8\n\nVoxel based modeling\nUsing voxel based methods for solid model representation provides following advantages\nand limitations. [Kaufman, 1993]\nAdvantages\nSimple, intuitive, unambiguous and unique representation\nSame complexity for all objects\nNatural acquisition for some applications (CT, MRI)\nTrivial Boolean operations (CSG)\nHeterogeneity and anisotropy of models can be easily incorporated into analysis\n(which may be the case in objects made by powder metallurgy of recently by\nNanotechnology)\nDisplay is viewpoint independent, insensitive to scene and object complexity\nLimitations\nApproximate representation: inherent to discretization\nLarge memory requirements\nLarger processing times (compared to surface models in terms of display)\nAliasing\nLack of geometric representation\n\n2.3 Voxel model representations\nThere are many methods proposed for voxelization of polygon models [Nooruddin, 2003;\nFang, 2000] and CSG models [Fang, 2000]. As there are many method of voxelization, so\nthere are many representation schemes for voxel models. Mostly the voxel file formats\nare application specific. Few voxel model representations in use are as follows.\n2.3.1 Discrete Cell Enumeration\nThere are many formats used by commercial software developers which have a specific\ndata field format specified for every voxel and the file essentially is enumeration of these\nvalues in some sequence of voxels. For instance the following voxel representation\nformats.\n\n9\n\n(a) Vox1999a file format\nThe proposed voxel file format consists of three logical sections. The file begins with a\nfile header that contains descriptions and copyright notices pertaining to the data in the\nfile. The header is followed by a volume description section that describes the first\nvolume and the voxel data in it. The volume data section follows immediately after the\nend of the description section. Each datum in the data section represents a voxel\ncontaining one or more fields (for example, an RGBA voxel). The volume description\nand volume data sections may repeat to provide for multiple volumes in one file\n[TeraRecon Inc., 2002].\n(b) Gaussian Cube File format\nThe cube file describes volumetric data as well as atom positions. The file consists of a\nheader which includes the atom information and the size as well as orientation of the\nvolumetric data. This is followed by the volumetric data, one scalar per voxel element.\nAll aspects of the file are in text format.\nHeader- The header has the number of atoms included in the file followed by the position\nof the origin of the volumetric data. Then it includes the number of voxels along each axis\n(x, y, z) followed by the axis vector. This means the volume need not be aligned with the\ncoordinate axis, also means it may be sheared. The last section in the header is one line\nfor each atom consisting of 5 numbers, the first is the atom number, the last three are the\nx, y, z coordinates of the atom center.\nVolumetric data- The volumetric data is straightforward, one floating point number for\neach volumetric element.\n2.3.2 Octree representation\nOctree is a data structure enabling efficient storage of 3D data. Octree is a 3D\ngeneralization of a Quadtree (for 2D). Each node in an Octree has eight children. Octree\ndescribes a recursive partitioning of a volume into cells that are completely full or empty\n[Prakash, 1990]. Octree methods achieve data compression by storing voxel information\nin a hierarchical tree structure, which is built in a top-down fashion by recursively\nsubdividing inhomogeneous regions of the volume into eight sub-regions until each\nterminal node of the tree corresponds to a region of the volume in which all voxels share\nthe same value.\n\n10\n\nActual implementation of octree uses pointers for representing connections between\nparent and sibling nodes at every stage of partitioning (Fig. 2.3.2).\n\nOctree\n\nFig. 2.3.2 Quadtree and Octree architecture\n\n2.3.3 Array representation\nIn spite of the many advantages associated with an octree representation of solids, the\nmain disadvantage would be that of storage. This is because for every node in the octree,\nwe must store pointers to its parent and eight siblings. Instead, if the octree was\nimplemented as an array, we would have to allocate space for a full tree amounting to\n[(8n+1 - 1) / 7] nodes, for a tree of depth n. However, we would not need to store pointers\nto siblings and parent since their location is implicit in the array index of any given node.\nFurther, for a realistic reproduction of irregular solids, it is presumable that the octree\nwould grow close to its full size. Consequently, we find no storage efficiency in storing\nthe tree in a pointer based structure as opposed to an array based structure. In fact we\nwould find that in realistic modeling of sculptured surfaces and solids, a pointer based\nstructure would actually consume more memory space due to the pointer storage\noverhead corresponding to each of the eight sons and parent.\nThus it can be seen that as the object shape becomes more complex, the depth of octree\nincreases and it becomes more inefficient in terms of memory. Instead a simple\nexhaustive enumeration format of voxel data implemented as array will have size\nindependent of object shape complexity. Also it will avoid the overhead of storing\npointers. Also, the advantage can be taken of the regularity in the arrangement of voxels\nin the given volume to enforce correspondence between the actual voxel in space and its\n\n11\n\nindex in the array. There are many possible variations in array representation of voxel\nmodels. Many commercial software packages have their own custom formats. The\nsimplest array implementation would be for a binary voxel model wherein a single bit can\nbe used to represent state of each voxel. For grayscale voxel model, depending upon the\nrange of variable at each voxel, an array of appropriate data type can be used.\nHere is one such model employing arrays to store voxel information. A node in the voxel\nmodel is a number called V-value as shown below.\nV-value = vn vn-1..... v1 where 0 ≤ vi ≤ 8.\nEach digit vi denotes the path to be taken at level i, (0=terminal, 1,2,3,4,5,6,7,8 are the\ndirections of the sibling nodes along the eight octants) to reach the node from root which\nis assigned a level 0. The root carries a V-value 00...0. V-value gives the unique path\nfrom root to any node in the tree and can also be obtained for a given path. Each element\nof this array contains 2 bits (call Co, Cl) of information. These represent the color-type of\nthe node as follows.\ntype color-type = (white, gray, not-used, black);\nC0\n0\n0\n1\n1\n\nCl\n0\nI\n0\n1\n\nColor\nWhite\nGray\nNot-used\nBlack\n\nA white or black node is a terminal node and has no children. However, with regard to the\narray representation of voxel tree, the nodes allocated for their children are labeled notused. A gray node is a non-terminal node and has children which are black, white or gray.\n\n2.4 Voxelization\n̳Voxelization‘ is the process of converting geometric objects from their continuous\ngeometric representation into a set of voxels that ―best‖ approximates the continuous\nobject [Kaufman, 1993]. As this process mimics the scan conversion process that\npixelizes (rasterizes) 2D geometric objects, it is also referred to as  ̳3D scan –conversion‘.\nHowever, the voxelization process does not render the voxels but merely generates a\ndatabase of the discrete digitization of the continuous object.\n12\n\n2.4.1 Essential characteristics of Voxelization algorithm\nA 3D scan-converter is required to obey some fidelity, connectivity, and efficiency\nrequirements [Kaufman, 1987]. The requirements assume viewing from a major axis, and\nwould have to be changed slightly for omni directional viewing.\n(a) Fidelity\n\n\nThe discrete points, for which the region contained by them is entirely inside the\ncontinuous object, are in the converted discrete object.\n\n\nThe discrete points, for which the region contained by them is entirely outside the\ncontinuous object, are not in the converted discrete object.\n\n\nObviously, some discrete points will not belong to either of the above cases, and more\nguidelines are necessary.\n\n\nIf the object is 3D (volume), its ―inside‖ will be converted according to requirements\n1 and 2. Other points will be treated by majority decision - the discrete point is in the\nobject if more than half its region is in the continuous object.\n\n(b) Connectivity\n\n\nFor a 1D object, 6-connectivity or 26-connectivity is required, depending on\nimplementation needs.\n\n\nFor a 2D object ―lack of tunnels‖ of certain connectivity is required. Again, 6connected or 26-connected tunnels can be disallowed depending on implementation\nrequirements.\n\n(c) Efficiency\n\n\nUse integer or fixed point arithmetic whenever possible, and floating point only when\nimpossible otherwise.\n\n\nUse simple operations (addition) rather than complex ones (multiplication), and avoid\naltogether more complex operations (square root) within inner algorithm loops.\n\n\nOperate in parallel so that the temporal complexity is less than the computational\ncomplexity, without too much hardware complexity.\n\nVarious methods used for voxelization are as follows.\n2.4.2 Scan conversion algorithm\nThis is also called as ―volume sampling‖. The basic method for converting objects is\nspatial occupancy. A regular grid of voxels is placed over the domain of the source\nobject, and for each voxel a binary decision is made as to whether each voxel is inside or\n\n13\n\non, or outside the object [Kaufman, 1987; Huang, 1998]. The recognized problem with\nthis method is that the representation produces a discrete surface which is recognizably\nblocky. Simple solutions have been to increase the resolution of the data set, but this in\nturn increases the memory requirements and rendering times [Jones, 2001]. These\nalgorithms do scan-conversion with computational complexity which is linear in the\nnumber of voxels written to the CFB (Cubic Frame Buffer) [Kaufman, 1987]. All\nalgorithms are incremental and use only additions, subtractions, tests and simpler\noperations inside the inner algorithm loops. Since the algorithms are basically sequential,\nthe temporal complexity is also linear. There are algorithms proposed for voxelizing lines\nand polygons [Wang, 1993].\n2.4.3 Implicit functions\nSampling is a valid method for producing voxelised objects, but it suffers from resolution\nproblems (blocky images), and restricted orientation of normals. One type of object for\nwhich this volume sampling is not a problem is that of implicit functions [Jones, 2001].\nHere the voxel grid is calculated by evaluating the function of the implicit surface – for\nexample, for a sphere of radius r, f (x, y, z) = x2 +y2 +z2 - r2.\nNormals from such data produce naturally shaded objects. The implicit functions encoded\nas above can be considered as  ̳space filled‘ voxelization – there is a value at every point\nin the domain of the object. The sampled voxelizations only produce values in the vicinity\nof the object and can be considered to be  ̳shell‘ voxelizations.\n2.4.4 Distance shells and fields\nIf the interest is just in encoding the surface and do not need a space filled distance field,\nwe can voxelize the object just in the vicinity of the surface. Such a voxelization is called\n̳a distance shell‘. Here the computational expense is significantly less, and the surface\nrepresentation is far superior when compared to the over sampling method which takes an\nequivalent time. The distance shell adequately represents the object, and is a valid method\nfor voxelizing objects where only the surface needs to be encoded. As a shell voxelization\nit benefits from the advantage of requiring less memory to store. Space filled distance\nfields [Jones, 2001] can be calculated from distance shells and gives more realistic\nmodeling with many application areas.\n\n14\n\n2.4.5 Parity count method\nFor polygon mesh models, classify a voxel V by counting the number of times that a ray\nwith its origin at the center of V intersects polygons of the model [Nooruddin, 2003]. An\nodd number of intersections mean that V is interior to the model and an even number\nmeans it is outside. This is simply the 3D extension to the parity count method of\ndetermining whether a point is interior to a polygon in 2D. For manifold models, the\ndirection of the ray is unimportant and advantage can be taken of this to speed up the\nvoxel classification. Many parallel rays can be cast through the polygonal model and each\none of these rays classifies all of the voxels along the ray. For an N x N x N volume, we\nneed to cast only N x N rays, with each ray passing through N voxel centers. Although\nthe parity count method works well for manifold models, many polygonal models have\nvarious degeneracies that require modifying the voxelization process. One common\nproblem is for a model to have small cracks or holes in the surface. To voxelize such\nmodels, the parity count method is extended by using k different directions of\northographic projection and by scan-converting the model once for each direction. Each\nof the k projections gives the classification of a voxel (interior or exterior), and the\nmajority vote is the voxel‘s final classification. For watertight models, all of the votes will\nagree.\n2.4.6 Ray stabbing\nThe ray-stabbing method also makes use of orthographic projections of a polygonal\nmodel. It differs from the parity count method, however, in the way it interprets the depth\nsamples of a ray. The ray stabbing method only retains the first and last depth sample\nalong each ray [Nooruddin, 2003]. In effect, each ray only keeps those points of\nintersection where the ray first stabs the surface of the model. Keeping both the first and\nlast depth samples is equivalent to stabbing the surface from two directions at once, at no\nextra cost. A voxel is classified by a ray to be interior if the voxel lies between these two\nextreme depth samples; otherwise, it is classified as an exterior voxel. For a single\ndirection of projection, this can cause some voxels to be misclassified as being interior to\nthe surface. To avoid this, several projections in different directions are taken. If any of\nthe projections classify a voxel as exterior, it is given an exterior classification. Only\nthose voxels that are classified as interior for all projections are given the final\nclassification of interior.\n\n15\n\n2.5 Volumetric display (rendering)\nTraditional surface graphics is not ideal for rendering volumetric objects which have\nvolume data associated; for example sampled data sets from CT, MRI and amorphous\ndata like gases, fire smoke, cloud. Also, when operations such as peeling, cutting,\nsculpting are to be performed on solid models which expose the interiors of object,\nsurface graphics finds difficulty [Acker, 1993].\nAdvantages of Volume graphics\n\n\nSuitable for sampled data and amorphous phenomena\n\n\nInsensitive to scene complexity\n\n\nInsensitive to surface type\n\n\nAllows block (volumetric) operations\n\n\nHierarchical representation\n\nLimitations of Volume graphics\n\n\nLarge memory and processing power required\n\n\nObject-space aliasing\n\n\nDiscrete transformations\n\n\nLack of geometric representation\n\n2.5.1 Classifying Volume rendering methods\nSeveral methods exist for the rendering of volumes. One class of these methods converts\nthe voxel representation into surface and line primitives [Elvins, 1992]. However,\nmethods of this class suffer from various disadvantages that mainly arise from the\nambiguity of determining the exact position of the surface. As an alternative, direct\nmethods have been developed to render volumes. These methods can be classified as\nobject order or image order as shown in figure 2.5.1. Object-order methods require the\nenumeration of all voxels of a volume and the determination of the affected pixels on a\nscreen. Image order techniques, on the other hand, determine all the voxels of a volume\nwhich affect a given pixel on the screen. Hybrid methods exist in which the volume is\ntraversed in both object and image order.\n\n16\n\nVarious rendering methods can be differentiated using the following three characteristics,\n(1) whether the explicit creation of an intermediate surface representation is required (if\nso, then refer to the method as \"indirect\")\n(2) whether the method is designed to operate on binary or on grey-scale data, and\n(3) for methods that operate on grey-scale data, whether a binary decision must be made\nabout the existence of a surface at any given location in the volume.\nVoxel data\n\nBinary\n\nGrey-scale\n\nDirect rendering\n\nObject order\n\nIndirect rendering\n\nImage order\n\nFig. 2.5.1 Classification of volume rendering methods\nThe following sections contain short description of various direct and indirect rendering\nmethods for binary voxel data as per the classification described above.\n2.5.2 Indirect methods\n(a) Tiling method\nThis one of the earliest approaches used to create images from volume data sets involved\nthe construction of three-dimensional polygonally-tiled surfaces from planar contour\ncurves defined on successive two-dimensional slices through a volume. In the simplest\ncases, a single closed contour (either hand-drawn or computed using an automatic\nboundary-detection algorithm) is used to outline the object of interest separately on each\nslice and contour points from adjacent slices are then joined to form triangular tiles.\n(b) Indirect, voxel-based methods\nIn addition to the tiling methods, a number of voxel-based methods have been introduced\nwhich compute and display surfaces from volume data. Most of these methods assume,\n17\n\nfor algorithmic simplicity, that all data points in the volume are equidistant. If the data\nhas been sampled at unequal rates in the different dimensions (for example, if the distance\nbetween data points within a slice is less than the distance between data points in adjacent\nslices), then some kind of interpolation is generally used to obtain the necessary\nintermediate values. In most grey-scale data sets, the value at a voxel represents a point\nsample of a continuous three-dimensional distribution, which is referred to as \"intensity\".\nIn the cuberille method, the volume occupied by each voxel is modelled as a cube of\nconstant intensity consisting of six polygonal faces, and object surfaces are constructed\nfrom appropriately selected connected subsets of these cube faces. Despite the large\nnumber of primitives, images can be displayed fairly quickly once the set of cube faces\ncomprising the surface has been found because the shading and hidden surface\ncomputations can be optimized to take advantage of the regularity of the polygonal\nrepresentation. The quality of an image produced by this method will be highly dependent\non the accuracy of both the surface localization and the estimation of surface normals.\nBecause the cuberille method relies on an intermediate representation in which polygons\nmay only appear in one of three possible orientations, the images produced by this\nmethod will exhibit sharp discontinuities in surface brightness if shading is based solely\non the polygonal approximation. Attempts to mitigate the effects of these blocky artifacts\nby low-pass filtering the final image, antialiasing using sub-pixel sampling, or averaging\nsurface normals from adjacent polygons have met with little success.\n(c) Indirect, sub-voxel based methods\nOne of the most popular voxel-based methods is the \"marching cubes\" algorithm\n[Lorensen, 1987] which uses subvoxel-sized triangular elements to represent isovalue\nsurfaces in a volume. Unlike other methods, in which each data point, or voxel, is\nrepresented as a small cube, the basic unit of operation in this algorithm is the cubic\nvolume defined between eight neighboring data samples. Each such cube in the data set is\nexamined and if the desired isovalue surface is found to be contained within that volume,\na trianglular tesselation of the enclosed portion of the surface is derived. As a first step,\nthe voxel intensity (or some precomputed object inclusion likelihood value) at each of the\neight cube vertices is compared with a threshold value to determine whether that voxel\nlies inside or outside of the desired surface. The cube is then assigned one of 256 possible\n\n18\n\nindex values based on the configuration of its vertices. These 256 cube configurations can\nbe mapped by rotation into 15 topologically distinct arrangements, and a triangular\ntesselation is defined for each of these canonical cases. Vertex coordinates are computed\nfor each triangle in the tesselation by linearly interpolating between the endpoints of the\nenclosing cube edge, according to the difference between the threshold value and the\nvalues at each of the endpoints. To achieve the best possible results in shading, normals at\nthe triangle vertices are computed not from the surface's polygonal approximation but\nrather from the intensity gradients of the underlying voxel data; gradient values found at\neach of the eight cube vertices, using central differences, are linearly interpolated along\ncube edges to the triangle vertex locations.\nThe marching cubes algorithm has a number of features that recommend it. Because\nsubvoxel elements of arbitrary orientation are used in the polygonal representation,\nsurfaces produced by this method generally fit the underlying data more closely than\nsurfaces obtained through either a cuberille or tiling approach, and virtual memory\nrequirements are kept to a minimum since the algorithm operates on only two slices of\ndata at a time. A marching-cubes surface will usually take longer to render than a\ncuberille or tiled surface, however, due to the larger number of polygons and also to the\nloss of the regularity in polygonal orientation that allowed simplified shading and hidden\nsurface computations to be used in the rendering of cuberille data.\n2.5.3 Direct methods for the display of surfaces in binary data\nIn the mid-1980's a number of new methods for visualizing volume data sets were\nproposed, which did not require the extraction of surfaces as a first step.\n(a) Octree methods\nOne of the earliest direct methods uses octree encoding to model objects defined by a\nbinary-valued volume obtained from the grey-scale data through thresholding or some\nother segmentation procedure. Images can be generated from an octree data set by\nestablishing a correspondence between pixels in the image and face-connected strings of\nvoxels in the volume, then recursively traversing the octree in a back-to-front order and\nwhenever a non-empty voxel is encountered overwriting the corresponding pixel value\nwith the color of the current voxel. Pseudo-shading can be implemented by defining top,\nbottom, left and right illumination factors which are added to a voxel's color when its\n19\n\nneighbor in the corresponding direction is empty. Front-to-back octree display algorithms\nhave also been developed for octree data sets.\nThe primary disadvantages of octree encoding binary data are the time it takes to build\nthe tree and the complexity of the tree-traversal operations. In addition, the octree\nrepresentation of a data set is highly dependent on the initial position and orientation of\nthe data; two data sets that differ only by a small translation or rotation may have\nsubstantially different octree representations.\n(b) Object-space methods for the display of surfaces in binary data\nAlgorithms which create images by projecting volume information onto the image plane\nare commonly referred to as \"object-space\" methods. An important feature of these\nalgorithms is that they do not require that the complete data set be resident in memory at\nall times. One of the earliest object space approaches renders images from binary-valued\nvoxel data sets by traversing slices of the arbitrarily-oriented volume from back to front,\nbeginning within each slice at the most distant corner and progressing along either rows\nor columns, projecting a value derived from the depth of each voxel perpendicularly onto\nan individual pixel of the final image.\n̳Splatting‘ also referred as ―forward projection‖ is an object-order approach. Only\nexisting objects in the volume are processed, which makes this approach time-efficient.\nThis method, although straightforward, is not optimal for a variety of reasons. The\nresulting images also suffer from the same shading problems that were encountered in the\ncuberille approach, and because a given pixel may be colored and re-colored many times\nbefore a final value is assigned, efficiency is sacrificed. In addition, this method is limited\nto performing parallel planar projections; a perspective view can be achieved only by prewarping the volume data before rendering is begun. Moreover, due to the poor quality of\nthe reconstruction algorithm, small hole artifacts can appear in the rendered image when\nthe volume is viewed at certain angles or magnifications. If voxel data is projected onto\nthe image plane in order of increasing distance from the viewer, only the first value\nreceived by each pixel needs to be retained and all subsequent attempts to write to the\nsame pixel must be disallowed. A front-to-back version of the above method which\nproduces equivalent images in less time avoids pixel re-writes through the use of a\ndynamic data structure that keeps track of unwritten scan-line segments. The algorithm\n20\n\nfirst ensures that face connected voxels in a single row of the volume will project onto\nadjacent pixels in a single scan-line of the two-dimensional image by requiring that all\nrotations be done in a specific sequence. As each row of voxels is projected onto the\nimage plane, the endpoints of the newly generated spans can then be compared with the\nendpoints of the unwritten portions of the scan-line, which eliminates the need to test for\noverwrites at each individual pixel.\n(c) Image-space methods for the display of surfaces in binary data\nIn addition to the object-space methods described above, image-space methods - which\nrender the data on a pixel-by-pixel basis - have also been developed to display solid\nobjects defined by binary-valued voxel data sets. The simplest of these methods steps\nthrough the volume along rays cast perpendicularly from the center of each pixel until the\nfirst non-empty voxel is encountered, shading pixels of the final image with a value based\nprimarily on their distance from this surface voxel. Ray casting method is sometimes\nreferred as ―backward projection‖ or ―resampling‖. It integrates the intensity along a ray\nthrough the voxels (Fig. 2.5.3) [Acker, 1993]. It is an image-order approach. A ray is shot\nthrough the volume for every pixel in the resulting image. The volume itself is processed\nobject oriented, where a transfer function defines the edges of an object in the volume.\nThe intersection point of a ray - perpendicular to the viewing plane - with an object\nborder is rendered by a shading function which represents lighting effects like shades and\nhighlights. Shading improves volume perception.\nOne advantage of the  ̳ray-casting‘ approach is that it does not require a complete\ntraversal of the volume; processing can be stopped as soon as a surface voxel is\nencountered along the ray from each pixel. A disadvantage of this approach is that in\norder to generate images at arbitrary orientations the entire data set must generally be\naccessible in memory at all times. Techniques have been developed which reduce the\ntime required to render a series of images by exploiting the coherence between\nconsecutive frames of a rotation sequence.\n\n21\n\nRay tracing\n\nSlicing\n\nIsosurface rendering\n\nFig. 2.5.3 Direct volumetric rendering\n2.5.4 Display algorithms for grey-scale data\nThis section describes few of the visualization algorithms developed for rendering greyscale voxel data.\n(a) Direct, binary methods for the display of surfaces in grey-scale data\nWhile early methods were designed to operate on binary-valued voxel data sets, in which\nsurfaces have been pre-defined using some type of segmentation procedure, more recent\nmethods have moved towards integrating segmentation into the rendering process. This\ngives twofold. First of all, retaining the grey-scale information at each voxel allows the\nuse of shading models which more accurately reflect the orientation of underlying object\nsurfaces. Because the values found at each voxel typically represent point samples of a\nsmoothly-varying function in three dimensions, shading methods that base their estimate\nof surface orientation on a 0th-order reconstruction in which the volume is represented by\na set of cubes of uniform intensity are clearly not optimal. A much better approximation\nto the surface orientation at a boundary voxel is given by the gradient of grey-scale values\nacross the voxels in a 3x3 neighborhood. In addition, surface position can be estimated\n22\n\nwith greater precision when the possibilities are not limited to specific locations on a\nregular grid.\n(b) Direct, binary methods for the display of intensity distributions in grey-scale\ndata\nA direct binary method has been developed which uses color to represent different\nintensity ranges within a volume. Before three-dimensional surface or volume rendering\nmethods came into widespread use, volume data was typically viewed on a slice-by-slice\nbasis. A display method that builds upon this slice-based approach forms images using\nstacks of two-dimensional slices. Data is extracted from the volume along a user-defined\naxis to produce the set of slices, and on each slice data points are assigned one of several\npossible colors based on the density range into which they fall. The slices are then\nprojected onto the screen, one at a time from back to front, with each slice slightly offset\nfrom its predecessor to produce an oblique view. Only those points falling within the\ndesired density ranges are displayed on each slice, to prevent the unwanted obscuration of\ndata from preceding slices.\n(c) Direct, non-binary methods for the display of grey-scale data\nThere exist a large number of other non-binary methods to display grey-scale volume data\nsuch as Multi-planar reconstruction. But, as the volume model considered in the project is\nbinary, such methods are not directly relevant and hence are not discussed here.\n\n2.5.5 Radiosity\nIn the radiosity approach, instead of modeling light as particles bouncing around in a\nscene (as is done in ray tracing), light is modeled as energy whose distribution tends\ntoward a stable equilibrium. The amount of radiation leaving a body is called the radiosity\n[Cohen, 1985]. It is the sum of the incident radiation which is reflected and that which is\nemitted by the body.\n\n23\n\n2.6 Applications of Voxel (Volume) based modeling\nThis section discusses various applications of voxel based modeling and volume graphics.\n2.6.1 Scientific data set visualization\nBecause of inherent discrete nature of voxel models, they lend themselves for easy\nscientific analysis and visualization involving volumes. As the voxel sizes become\nsmaller and smaller, made possible by larger and cheaper memory, the accuracy of\nanalysis continuously improves. More importantly, voxel models can very effectively\nincorporate the non-homogeneity of solids into analysis, as the local property variations\ncan be associated with voxel models (Fig. 2.6.1).\n\nFig. 2.6.1 Volumetric analysis and visualization\nIn CAD/CAM/CAE applications like for volumetric (mass) property evaluation,\ninterference, collision detection (tool path planning), simulations, manufacturability\nanalysis [Yagel, 1995; Chandru, 1995] voxel models are more easy (though not precise)\nto use. Voxel models can give real life rendering involving reflection, refraction and\ndiffractions in volumes.\n\n24\n\nIn view of CAD/CAE applications, aspects of geometric modeling that can benefit from\nadopting Voxel based approach are [Chandru, 1995]:\n(a) Estimating mass properties\nThe voxel model lets designers evaluate the mass properties of the modeled object.\nFor instance, the total material volume can be obtained as a simple sum of all the\nnonzero voxels of the volume buffer.\n(b) Interference detection\nDetecting interference among the components of an assembly is a major problem in\ncomputer-aided design of mechanical parts. Analytical methods for computing such\ninterference have been proposed but they are complicated and do not easily generalize\nto arbitrary geometries. This measure can be applied irrespective of the assembly‘s\ncomplexity and is another advantage of a voxel model.\n(c) Tolerancing\nTolerancing is an important aspect of mechanical. In a voxel-based modeler, the\nintersection of two objects due to variations in tolerance can be visualized as a 3D\ninterference volume itself.\n(d) CSG modeling\nComputation of the Boolean operations reduces to voxel-by-voxel logical operations.\n(e) Voxel-level analysis\nThe powerful aspect of voxel-based modeling is that the designer can selectively\nmodify individual voxels so that the resulting object meets the design specifications.\n(f) Designing composites\nA voxel-based modeler can ultimately provide the capability to design a composite\nobject with materials selectively placed at individual voxels.\n(g) Reverse engineering\nThe combination of Layered Manufacturing (LM) technologies and volume scanning\ndevices (like CT and MRI) is a powerful reverse-engineering platform. A voxel-based\nmodeling package can import the scanned volume data, perform voxel-level\nmodifications, and then directly fabricate the object, or its tooling, using LM\nequipment. Custom prostheses, replicas of archaeological artifacts, and retooling for\ncomponents where a sample is available but the design information is lost are some\nareas that greatly benefit from this combination.\n\n25\n\n2.6.2 Amorphous entity visualization\nThe entities like smoke, clouds, steam, fire, etc., which are amorphous (discrete, random\nvolumes) in nature, involved in simulations or artistic models, computer games etc. are\nimpossible to represent using surface models. Voxel based models perfectly fit in for their\nrepresentation and visualization (Fig. 2.6.2).\n\nFig-2.6.2 Amorphous entity visualization\n2.6.3 Representing solid interiors\nVoxel models are very effective in representing interior details of solid models. It is\ndifficult to model as well as represent solid free from objects like Human body and\ninternal organs, free-form solid artwork like jewelry, artifacts in traditional modeling\nschemes like CSG or B-rep. Voxel models prove to be best suited for such applications as\nthey provide means for\n\n\nSlicing: display the volume data mapped to colours, along a slice plane\n\n\nIso-surfacing: generate opaque and semi-opaque surfaces\n\n\nTransparency effects: volume material governs reflected and emitted light\nSlice\n\nSemi-transparent\nmaterial\nFig. 2.6.3 Mapping human body anatomy\n\n26\n\nIso-surface\n\nThese advantages of voxel models are effectively used in applications like\n\n\nSurgery simulation and planning\n\nAn interactive surgical planning system allows a surgeon to simulate manipulations of\norgans prior to an actual operation. Using patient data, acquired by means of CT scanning\nfor example, and an interactive 3D display system, multiple operating strategies can be\ntried out in advance. Possible difficulties thus may be anticipated, while by recording the\nsequence of actions taken during the simulation, an operation protocol can be produced.\n\n\nProsthetic design\n\nVoxel models can be used to combine and manipulate both physical data (CT scan) and\nartificially created objects (CAD models). The easy way in which spatial selection can be\nmade in a voxel model is used for the removal of parts of organs. The Boolean set\noperations union and difference allow the combination of reconstructed organs with usercreated secondary objects, such as prosthetics.\n2.6.4 Visualizing volume data\nSome geometric data acquisition techniques like CT (Computed Tomography), MRI\n(Magnetic Resonance Imaging) and PET (Positron Emission Tomography) generate\nvolume information. This lends the voxel based models as the most suitable visualization\ntool for such data (Fig. 2.6.4).\n\nFig. 2.6.4 Solid model from CT scan data slices\nThis proves very much useful in medical applications like for modeling prosthesis or\nimplants. The following section briefly describes aspects of medical modeling.\n\n27\n\nMedical modeling\nSome acquisition methods like CT scan, MRI, 3D-scan generate solids. There are few\nunique aspects of 3D medical imaging that distinguish it from other graphics processing\napplications. [Stytz, 1991]\nTwo well-known, closely related factors are data volume and computational cost. The\ntypical medical image contains a large amount of data. As an average CT procedure\ngenerates more than 2 million voxels per patient examination. MRI, PET, and ultrasound\nprocedures produce similar amounts of data. The second factor is that the algorithms used\nfor 3D medical imaging have great computational cost even at moderate 3D resolution.\nAdditional factors, first, there are no underlying mathematical models that can be applied\nto medical image data to simplify it. Second, the display is not static. Typically,\nphysicians, technicians, and other users want to interact with the display to perform\ndigital dissection and slicing. Third, for a 3D representation to provide an increase in\nclinical usefulness over a 2D representation it must be capable of portraying the scene\nfrom all points of view.\nThe importance of the voxel model comes from its use in the CT, MRI, SPECT, and PET\nmedical imaging modalities as well as for 3D medical image rendering. The voxel model\nis the assumed input data format for the three major approaches to medical image object\nspace modeling described in this section: the contour approach, the surface approach, and\nthe volume approach. These three object space modeling techniques provide the input\ndata to the two major classes of 3D medical image rendering techniques—surface and\nvolume rendering. Three major approaches to portraying an object in a 3D medical image\nvolume have been developed as the contour, surface, and volume object space depiction\nmethods. The contour, lD-primitive, approach uses sets of lD contours to form a\ndescription of the boundary of an object of interest within the individual slices that form a\n3D volume. The boundary is represented in each slice as a sequence of points connected\nby directed line segments. Before forming the boundary representation, the desired object\ncontour must be isolated using a segmentation operator. Thresholding can be used if the\nboundary occurs between high contrast materials. Otherwise, boundary detection using\nautomatic or manual tracking is used for segmentation.\n\n28\n\n2.6.5 Haptic modeling and rendering\nHaptic devices are now commercially available which give real time force feed-back.\nThese devices are very effectively combined with voxel modeling for\n\n\nInteractive\n\nsurgical\n\nsimulation\n\nand\n\nplanning\n\n\nFree-form modeling: virtual clay sculpting\n\n(Fig.2.6.5)\n\n\nHaptic based product design\n\n\nFig. 2.6.5 Haptic modeling and rendering\n\n2.7 Summery of Literature survey\nThe important concepts and methods of voxel based modeling (volume graphics) have\nbeen presented. Although volumetric representations and visualization techniques seem\nmore natural for sampled or computed data sets, they are very advantageous in traditional\ngeometric-based applications as well. This trend implies an expanding role for volume\nvisualization, and it has thus the potential to revolutionize the field of computer graphics,\nby providing an alternative to surface graphics, called ―volume graphics‖. Volume\ngraphics has advantages over surface graphics by being viewpoint independent,\ninsensitive to scene and object complexity, and lending itself to the realization of block\noperations, CSG modeling, and hierarchical representation. It is suitable for the\n\n29\n\nrepresentation of sampled or simulated datasets and their intermixing with geometric\nobjects, and it supports the visualization of internal structures. The problems associated\nwith the volume data representation are, large memory requirement, larger processing\ntime, aliasing, and lack of geometric representation.\nThese computational and some algorithmic bottlenecks need to be overcome to realize the\npotential offered by voxel based design. The possible areas for research aimed at\neliminating these bottlenecks are as follows.\n(A) Memory\nThe memory requirements of voxel models are enormous. For storing a reasonable\nresolution voxel model say 400x400x400 in raw form , (i.e. just as a 3D array of voxels)\nrequires 64 M bytes of space [Chandru, 1995]. One can trade-off computation time for\nstorage space by one of the following means.\n\n\nStore the voxel array in compressed form and use algorithms that will operate directly\non the compressed data.\n\n\nConvert the voxel array into some other more compact representation and reconvert\ninto voxels when required.\n\n\nRetain the original geometric representation and use voxelization algorithms when\nnecessary. This is especially valuable since in engineering design there is a large\nlibrary of components that can be imported into the voxel based modeler.\n\n(B) Rendering complexity\nIn order to be an effective design tool, a voxel based system should be able to update the\ndisplay at interactive rates. Current graphics rendering systems cannot provide a level of\nrendering performance on voxel models that is comparable to their polygon rendering\nperformance. However this situation is likely to change in the near future since parallel\nalgorithms and hardware support for volume rendering are the focus of several current\nresearch efforts.\n(C) Interactive volume sculpting\nOne of the premises on which a voxel based modeling and design system is based is the\navailability of a powerful interaction paradigm that provides the designer with the\n\n30\n\nfreedom to realize arbitrary shapes. Without this capability called ―interactive sculpting‖\nmost of the advantages of a voxel based design for rapid prototyping will be nullified.\nInteractive sculpting is currently a highly active research area.\nEfficient algorithms for computational analysis of voxel based models and virtual reality\ninterfaces for sculpting are some of the other challenging research problems.\nThe simplicity of designing analysis algorithms based on mass properties in voxel based\nmodels can be used for developing many manufacturing simulations and design solutions.\nFor example, metal flow simulation in casting, casting solidification analysis, prediction\nof defects and alike.\nThe progress so far in volume graphics, in computer hardware, and memory architectures,\ncoupled with the desire to reveal the inner structures of volumetric objects, suggests that\nvolume visualization and volume graphics using voxel based technologies may develop\ninto major trends in computer graphics and CAD/CAM.\n\n31\n\nChapter 3\n\nProblem definition\n\nThis chapter gives the basic outline of the project in terms of motivation for selecting the\nproblem and the scope of the work done. Also, this includes the review of few voxel\nbased system available commercially.\n\n3.1 Motivation\nThe literature survey clearly brings out the impact of Voxel modeling on a wide range of\napplications, ranging from CAD/CAM/CAE to medical field like prosthesis design,\nsurgery simulations and planning. Especially for the design of complex free-form shaped\nobjects, voxel based methods prove very effective.\nAs concluded from the literature survey, there is scope for working on developing\ncompact, application specific voxel model representations and visualization algorithms.\nEven with existing voxel based methodologies available, a large world of applications\nremains unexplored, specifically in manufacturing field.\nWith the advantages associated with voxel (volume) modeling and the developments in\ncomputing hardware, it is predicted that the fundamental problems like memory\nlimitation, resolution (accuracy with voxel size) and computation times, will be soon\nresolved.\nThus, it is expected that with the need for volumetric analysis increasing with very\ncomplex\n\nand\n\nheterogeneous\n\nsystems\n\ndeveloped\n\nby\n\nlatest\n\ntechnologies\n\nlike\n\nNanotechnology, advanced computer graphics in Virtual Reality (VR) simulations, will\nbring more and more focus on Voxel based modeling and Volume graphics.\n\n32\n\n3.2 Study of present voxel based modeling systems\nThe following software packages are installed at Prof. B. Ravi‘s lab in Mechanical\nEngineering department at IIT Bombay. We have complete license for FreeForm while\neducational trial licenses for MIMICS and 3D Doctor. The installations were followed by\ndemonstration and training sessions by the experts from respective companies.\n\n3.2.1 FreeForm Modeling Plus\nThis software is developed by SensAble Technologies Inc., USA (www.sensable.com). It\ncomes with a haptic interface called ―Phantom‖. The FreeForm Modeling Plus system is\nthe ideal tool for the design of complex, free-form shapes and delivers manufacturable\nmodels, files for rapid prototyping, and photo-realistic renderings.\n\nFig. 3.2.1 Modeling in FreeForm modeling Plus 7.1\nThis is a free-form interactive modeling technique based on the metaphor of sculpting and\npainting a voxel based solid material, such as a block of clay or wax. There are two\nmotivations for this approach. First, modeling topologically complex and highly-detailed\n\n33\n\nobjects are still difficult in most CAD systems. Second, sculpting has shown to be useful\nin volumetric applications. Real-time human interaction is achieved in this approach,\nsince the actions of sculpting (as carving, sawing) and painting are localized in the\nvolume buffer, a localized rendering can be employed to re-project only those pixels that\nare affected. Carving is the process of taking a pre-existing volume sampled tool to chip\nor chisel the object bit by bit. Since both the object and tool are represented as\nindependent volume buffers, the process of sculpting involves positioning the tool with\nrespect to the object and performing a Boolean subtraction between the two volumes.\nSawing is the process of removing a whole chunk of material at once, much like a\ncarpenter sawing off a portion of a wood piece. We have modeled few complex nonengineering objects like the Ganesha and some jewelry items using this system.\nThe main features of the system are\nInteractive sculpting of digital clay with haptic feed back\nOperations like adding clay, sculpt, smudge, pull, cut, combine, remove, etc along\nwith standard CAD operations like extrude, cut, revolve, mirror, sweep, etc\nSelective clay hardness\nVoxel size- Resolution adjustment (Scaling)\nFile format conversions with selective accuracy\n3.2.2 3D Doctor\nThis is a volumetric visualization and modeling package developed by Able Software\nCorporation (www.ablesw.com). 3D-DOCTOR creates 3D displays from CT/MRI\nimages. 3D-DOCTOR's vector-based editing tools allow easy image data handling,\nvolume measurement, and quantitative analysis. From extracted boundary data, 3D\nsurface models are created using the Surface Rendering command. Multiple objects can\nbe easily combined to create sophisticated 3D views of complex structures for\napplications such as surgical planning and diagnostic imaging. Parameters such as\nmaterial properties, colors, viewing angle, and display settings, can be adjusted\ninteractively.\n\nVolume\n\nrendering\n\nsupports\n\nseveral\n\nrendering\n\nmodes,\n\nincluding\n\nTransparency, where voxels are treated as transparent, Direct, where only surface voxels\nare displayed, and Maximum Density, where only the brightest voxel is displayed along\neach ray.\n\n34\n\nImage thresholding\n\nSurface rendering\n\nDirect volume rendering\n\nTransparent volume rendering\n\nFig. 3.2.2 Volume Rendering in 3D Doctor\n3.2.3 MIMICS\nMaterialise's Interactive Medical Image Control System (MIMICS) is an interactive tool\nfor the visualization and segmentation of CT images as well as MRI images and 3D\nrendering of objects. In the medical field MIMICS can be used for diagnostic, operation\nplanning or rehearsal purposes. A very flexible interface to rapid prototyping systems is\nincluded for building distinctive segmentation objects.\nThe software enables the surgeon or the radiologist to control and correct the\nsegmentation of CT-scans and MRI-scans. MIMICS is a general purpose segmentation\nprogram for gray value images. It can process any number of 2D image slices\n(rectangular images are allowed). The only restriction is the physical memory of\ncomputer.\n\n35\n\nFig. 3.2.3 MIMICS software interface\nMIMICS and 3D Doctor are very much similar in the sense that both take CT, MRI slice\ndata as input in form of Di-com images or BMP images with additional data. Then the\nimages are spatially referenced with each other and ―thresholding‖ is done. Thresholding\nis essentially a process of selecting a set of pixels with gray values within specified limits.\nThen the voxelization is as if adding thickness to the plane slices. The pixels selected are\nconverted to voxels by adding thickness and are grouped together to form the solid. The\ndistance between the slices determines the voxel thickness whereas the voxel height and\nthe width can be appropriately set. The model can be visualized using surface or volume\nrendering with required accuracy. Some standard file conversions through import/export\nare available.\nGoing through all these software packages, following remarks can be made.\nFreeForm provides for the virtual sculpting of digital clay using Boolean operations\non voxel model representation. The model display is continuously updated surface\nrepresentation.\nMIMICS and 3D Doctor use voxel model as modeling base for inherent volume\ndata obtaind through 3D scans like CT or MRI.\n\n36\n\nVoxel models are very appropriate for volumetric Boolean operations and free form\nshape models like human body anatomy models.\n\n3.3 Objective and scope\nThe overall objective of the project was to develop an efficient voxel based modeling and\nvisualization system which can be easily adopted for applications like manufacturability\nanalysis. The idea has been to take advantage of volumetric nature of voxel models which\nmake them ideal for problems involving volumes like solid models in CAD/CAM/CAE.\nThe focus of the work is been on binary voxel models which have only space occupancy\ninformation. Also, cubic voxels with regular arrangement aligned with the coordinate\naxes are considered. The major work involved devising fast and efficient voxelization\nalgorithm which can convert existing solid model in faceted format into the custom\ndeveloped voxel form. Solid model in form of ASCII STL file is taken as input into the\nsystem. The voxel model representation scheme involves model storage in memory as\nwell as in hard drive in file format. Minimum memory required and faster processing\nwere the main goals. To serve for general application requirements, the system was to be\nmade capable of handling 1 billion voxel models. This gives resolution of 1000 voxels\nalong each coordinate axes. Still provision was sought for selectively setting the voxel\nresolution as per the application requirement. A fast and effective visualization algorithm\nwould display the voxel model. The voxel model format would enable standard Boolean\noperations and also geometric reasoning to be performed on the voxelized solid.\n\n3.4 Approach\nThe work is split into modules which are implemented one by one as follows.\n(a) First a voxel model representation scheme was developed which would need\nminimum memory and at the same time allow faster access to individual voxel. The main\nfeatures sought in such a scheme were dynamic memory allocation, provision for\nselective resolution, speed of access and ease of implementation. Various alternatives\nwere evaluated to select the most efficient one. Having selected the voxel model\n\n37\n\nrepresentation format, a file format was determined to store the voxel model on hard drive\nin as compact form as possible.\n(b) After finalizing the voxel representation scheme, a voxelization algorithm was\ndeveloped to convert a solid model in STL format into the voxel format. A class base to\nimplement the selected representation scheme for voxel into C++ environment was\ndeveloped. The algorithm and the storage format were implemented using VC++ and\nvalidated using various solid models. The algorithm for voxelization was optimized for\nquicker voxelization and tested for few complex free-form models with various\ncomplexities and triangle counts.\n(c) After considering various methods available for voxel display, a new algorithm was\ndeveloped and implemented to render voxel models. OpenGL is used as graphics\nenvironment. The algorithm was tested for various complex models and the system was\nmodified for an errors found and for better performance.\n(d) Then over the developed voxel model base, many low level functions were written.\nThese functions include functions to access and modify individual voxels, handle voxel\nbodies, voxel display functions and few geometric reasoning functions.\n(e) Using the developed framework of voxel based modeling, functions were written for\nsectional display, X-ray scan and skin-removal simulation. The functions were tested for\nvarious models and the results were compiled.\n\n38\n\nChapter 4\n\nVoxel data structure and voxelization\n\nThis chapter contains the in depth description of the basic work done in the project to\ncome up with new voxel model representation scheme. Details of the considerations made\nfor designing the voxel model representation scheme along with the comparative\nevaluation of different options is presented. The chapter also includes the voxelization\nalgorithm and the modifications made to optimize it. Discussion is presented on the errors\nin the voxel model, the causes and measures to reduce the errors.\n\n4.1 Voxel data set\nAs voxel model is exhaustive enumeration of volume data, usually the amount of data is\nvery large as compared to parametric representation of solids. The size of data depends\nupon the number of voxels and also the amount of information to be stored per voxel. The\nnumber of voxels depends upon the grid used for discretization of solids. There has to be\na trade-off between the voxel resolution and the size of data. As the size of voxels\nreduces, the accuracy of representation improves and we get higher resolution in analysis.\nBut this will correspondingly increase the number of voxels to be stored for given solid\nmodel which may be difficult to handle in terms of available computer memory and\ncomputational load.\nSometimes the resolution required may be dictated by the application requirement. The\nactual physical size of the object also determines the number of voxels required for\nexpected resolution. For example, consider a cylinder block model of an automobile with\nmaximum dimension of around 500 mm. Then a grid of 1billion voxels (1000 x 1000 x\n1000) will give voxel dimension of 0.5 mm, which may be just sufficient for application\nlike casting solidification simulation. The same model with a grid of 500 x 500 x 500 will\ngive resolution of 1 mm which may be sufficient for approximate weight calculation or\ndetermination of C.G. Thus, it would be very useful if a voxel model representation and\nstorage scheme is flexible enough so that it can be easily configured for required\n39\n\nresolution depending upon particular application. So, we have incorporated such\nflexibility in the design of voxel file format and representation. But, still we will limit the\nmaximum grid to 1000 x 1000 x 1000 (1 billion voxels) as per the current computer\nmemory limitations.\nThe information to be stored for every voxel also depends upon the application\nrequirements. For a simple object, it may be sufficient to store only occupancy data,\nmeaning only whether a voxel is an object voxel or not. Such voxel models are called\n―binary voxel models‖, as they store only one binary variable per voxel. The project\ncurrently uses only binary voxel models. But many times, some property which varies\nspatially within the region of interest (object) need to be stored for corresponding voxels.\nThen we have to store a variable (discrete or continuous) with every voxel as for example\nlocal density value, intensity, type of voxel, etc. Sometimes, there might be requirement\nof storing more than one property value with every voxel, for example local velocity\nvector, temperature, etc. The voxel model needs to be flexible in this aspect as well to be\nable to be adopted for changing requirements.\nFor the voxel model to be developed, Cartesian coordinate system is chosen. Presently,\nvoxels are assumed to be cubic, meaning the scaling factor along all three axes is the\nsame. The voxels are assumed to be aligned with the coordinate axes.\n\n4.2 Voxel data structure\nThe voxel data needs to be stored efficiently in memory so as to allow very quick access\nto any voxel information and also be very compact as voxel data volume could be very\nlarge. As the voxel data size depends on the resolution set, the data size is variable. For a\ncubic voxel volume of resolution 1000, the maximum number of voxels may go up to\n1x109. But at the same time, for any further manipulation of voxel data for geometric\nreasoning or analysis, each voxel needs to be easy to access and modify. Taking this into\nconsideration, the voxel data is stored in memory as a ―Bit-array‖ while the file on the\ndisc can be made compact by writing in form of run-lengths.\n\n40\n\n4.2.1 Bit array\nA new bit array class is defined. Functions are written to set, reset, access and edit the\nvoxel information in the bit array. Every voxel is represented by single bit. So, it is a\nbinary structure, classifying voxels as either filled by the object or empty. The bit array is\ncreated one layer at a time. So, to start with, pointers to  ̳plane‘ structure are declared.\n̳Plane‘ is a structure which holds a bit array to store (resolution+2)2 voxels. Assuming\nmaximum possible resolution of 1000, an array of pointers to structure  ̳plane‘ is created\nat the beginning. Then depending upon the requirement as per the object shape, new plane\nis created for every Z increment and then the voxels in that plane are stored. All bits are\ninitially set to  ̳0‘. Then as per the voxelization algorithm, the filled voxels are set to  ̳1‘.\nThe actual index of the voxel to be accessed from the array is calculated properly from its\nX, Y and Z coordinate values. Chapter 3 includes the results of memory required for\nstoring voxel models of various objects with different resolution.\nThe actual bit array is one bit extra on all sides. This is to enable a simple filtering\nalgorithm for finding neighbour configuration to be applied to all voxels, including ones\nat the bounding box extremes. One layer of voxel is added on all sides of minimum\nvoxel-box required for a model as shown in the figure 4.2.1.\n\nPlane (Z+1)\nPlane (Z)\nOne layer of voxels added\non all sides\nPlane (Z-1)\nFig.4.2.1 Stack of ‘planes’ holding bit-array\nTo start with, one  ̳plane‘ is created to represent Z=0 layer. This bit array is set to  ̳0‘\nallover as it is the lowermost layer just outside the voxel box. Then, as the voxelization\nstarts, for every increment of Z, a new  ̳plane‘ is created which can hold the required bits.\n\n41\n\nAfter the voxelization is over with Z reaching maximum of object, one more extra  ̳plane‘\nis added on top, which again is set to  ̳0‘ allover.\nWhenever a new  ̳plane‘, that is a new bit-array is created, it is set to  ̳0‘ allover, and\nwhenever a filled voxel is found, the corresponding bit is set to  ̳1‘.Then the voxel index\nin the bit array is properly determined for voxel writing as well as while finding\nneighbour configuration. For example, for a resolution of 100, every  ̳plane‘ created will\nbe an array of (100 + 2)2 = (102)2 = 10404 bits. The array in memory would look like\n0\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n... ... ... ... ... ... 10401 10402 10403\n\nBut when considered voxels on a Z-layer, actual voxel indices would be as shown in table\n4.2.1.\nTable 4.2.1 Voxel indices in bit-array for one Z-plane with resolution 100\nx\n\nx\n\nx\n\nx\n\nx\n\nX\n\nx\n\nx\n\nx\n\n10402\n\n10403\n\n510\n\n511\n\nX+102\n\n408\n\n409\n\nX\n\n508\n\n509\n\n306\n\n307\n\nX-102\n\n406\n\n407\n\n204\n\n205\n\n304\n\n305\n\n102\n\n103\n\n104\n\n104\n\n106\n\nx\n\nX\n\nx\n\nx\n\n201\n\n202\n\n203\n\n0\n\n1\n\n2\n\n3\n\n4\n\nx\n\nX\n\nx\n\nx\n\n99\n\n100\n\n101\n\nThus the total memory required (MTOTAL) for a voxel cube of resolution  ̳R‘ is equal to\nMTOTAL = (MPOINTER + MPLANE ARRAY) x Total no. of planes\n= (4 bytes + [(R+2)2/8] bytes) x (R+2)\nThe goal of using minimum memory for voxel storage is achieved by two approaches.\nOne is the use of smallest memory unit for representing single voxel. As in the project, a\n̳bit‘ is used to represent voxel in the binary voxel model. The other approach is to use as\nminimum of such units as just required for the given object. This requires dynamic\nmemory allocation and which in turn needs a balance between pointer overhead and\nmemory saving.\n\n42\n\n4.2.2 Voxel data on disc\nAs voxel data is stored as bit-array in memory for quick, direct access, in contrast, voxel\ndata is stored on disc as a set of run-lengths to make it compact. The file is simply a\nsequence of voxel type and corresponding run-length. So,  ̳0‘ indicates empty voxel.\nSimilarly, different types of voxels can be identified by different characters or numbers. If\nthe voxel model is binary, containing voxels of only one type, then, file can be further\ncompacted by storing only run-lengths. Then, the starting run-length is always interpreted\nas of empty voxels, which could be  ̳0‘ also, and then follows the run-lengths for filled\nand empty voxels alternately.\n\n4.3 Voxelization\nThe solid model imported is in STL ASCII format. STL stands for  ̳Stereolithography\nTessellated Language‘. STL format is a kind of boundary representation scheme in which\nthe surface of solid is represented by triangles or  ̳facets‘. The file includes the listing of\nfacets in random order. For every facet, three coordinate values of three vertices and an\noutward normal vector is stored.\n4.3.1 Voxelization algorithm\nAfter importing STL, a structure to represent the model is created which stores the\nvertices, edges, facets and connectivity between them. Also, the bounding box of the\nmodel is determined. The voxel size is determined by dividing the maximum dimension\nof this bounding box by the resolution defined. The coefficients of line and plane\nequation of edges and facet are also determined.\nTo start with, the STL model is placed in the positive octant as shown in figure 4.3.1.\nThis is achieved not by actually translating the solid model but taking proper Y and Z\nvalues for the rays passed through. Then, the first ray passed is with Y=Ystart and\nZ=Zstart. After finding intersections for this ray and writing the voxel configuration, the\nY value is incremented by cell size. Thus effectively the next ray is shifted along positive\nY axis. After sufficient number of shifts along Y-axis, when the Y-span of object is\ncovered, Z-value is incremented by cell size. This process is repeated till Z value covers\nmaximum Z-coordinate of the model.\n\n43\n\nThe voxelization process essentially passes rays along X-axis in preset order and finds it‘s\nintersections with the facets. The number of intersections for any ray would always be\neven provided, the STL file is free of errors and the rays completely extend beyond the\nmodel on both sides. Then, it is just finding the voxels lying between an odd and the next\neven intersection, which are occupied by the solid model body. The algorithm is shown in\nfigure 4.3.2.\nZ\n\nVoxel size\n\nZ range\n\nZ\n\nY range\nY\n\nX\n\nY\n\nX\n\nZ\n\nY start\n\nZ\n\nFilled voxels\nY\n\nZ start\nX\n\nY\n\nFig.4.3.1 Steps to initialize voxelization\n\n44\n\nX\n\nSTL Ascii file\n\nCreate structure of faces, edges\nand vertices. Also, generates\nplane equations for facets.\n\nImport STL\n\nReset Y or Z values to go to next ray or plane respectively\n\nExtract faces which intersect X-axis\n\nRemove faces with\ncoefficients as  ̳0, y, z‘\n\nnormal\n\nCreate a ray parallel to X-axis\n\nEssentially, find the Y and Z\ncoordinates for the ray\n\nFind the intersections of this ray\nwith all the facets extracted\n\nSubstitute, Y and Z values for\nthe ray in the plane equation of\na facet and find X coordinate of\nthe intersection.\n\nCheck for inclusion of the\nintersection point within the facet.\nIf yes, carry the point forward.\n\nFind areas of triangles made by\nintersection point with all\nvertices. Check for difference in\nareas of parent facet and sum of\nthree triangles made.\n\nSort the intersections in ascending\norder\n\nAs, Y and Z for a given ray\nremain constant, only Xcoordinate values are required.\n\nTraverse the intersection\nsequence, find the run-lengths\nand populate the voxel bit-array\n\nEnsure even number of\nintersections. Voxels between\nan odd and the next even\nintersection are marked filled.\n\nVoxel bit array\nFig.4.3.2 Voxelization algorithm\n\n45\n\n4.3.2 Modified Voxelization algorithm\nTo reduce the time required for voxelization, the voxelization algorithm shown in figure\n4.3.2 is modified further. The redundancies removed from the algorithm include\nfollowing.\n(1) There may be many faces which intersect X-axis but the actual facet lies completely\noutside the current ray. These are the facets whose all vertices have Y or Z or both\ncoordinates greater or smaller than the corresponding values for the current ray.\nIntersections with such facets need not be calculated.\n(2) Shift the model close to origin such that its minimum X, Y, Z coordinate values\ncoincide with the origin. Then, the rays can be passed only up to maximum limits of the\nbounding box of the model, which are the maximum values of the X, Y, Z coordinates.\nThus, for every layer, Y coordinates of rays start from minimum Y and go up to\nmaximum Y for the bounding box. Thus, whenever, maximum Y is reached, Z-is\nincremented and voxelization continues for next layer. When maximum Z is reached,\nvoxelization is complete.\nWhen the STL is imported at first, the bounding box of the model is determined. This can\nbe used to reduce the voxelization time further. As the voxelization is layer by layer, with\nmemory space created for every new layer to be added, the memory as well as time\nrequired for voxelization will be still lesser when minimum layers are generated. Thus,\nthe ideal order of range for given set up would be as X-range > Y-range > Z-range. In\nother way, for any ratio of ranges, one can select the direction of rays and layers so that\nthe above order is achieved, which will take minimum time and memory for voxelization\nwith current scheme.\n\n4.3.3 Errors in voxelization\nPossible errors in the voxelization are as follows.\n(1) Missing thin sections.\n(2) Odd number of intersection caused by errors in STL of section thinner than voxel.\n(3) Approximation of shape, which is inherent to voxel models. This can be improved by\nhaving voxel models of higher resolution.\n\n46\n\nThe errors in voxelization are made visible in voxel model display or also in section\ndisplay and X-ray scan display. This can be identified as stray voxel lines or planes,\nmissing voxels and similar inconsistencies.\nThe maximum error possible is half the voxel size.\nAs shown in the figure 2.1, the first ray originates from\nY start = Yminimum of the model + (Voxel size / 2)\nZ start = Zminimum of the model + (Voxel size / 2)\nThen, the rays are passed with shift of voxel size along Y and/ or Z axes for further\niterations. For determining voxel along the ray, the intersections are sorted in ascending\norder. Then finding the run-lengths as\nRun-length = (Intersection i – Intersection (i-1)) / Voxel size\nThen the run-lengths are used to write the bit array for that plane as filled or empty voxels\nas the case may be.\nFor correction along X axis, after populating integer number of voxels between two\nintersections along a ray, the remainder can be analyzed for setting the partially occupied\nlast voxel as filled or empty. The other possible error is when voxel size is larger than the\nthinnest section in the model. Here also, by comparing the distance between the\nintersection with the voxel size, error ca be minimized. When such a section lies exactly\nbetween two rays without having any intersection as shown in the figure 4.4 below, it\nmay be completely missed.\nZ\n\nZ\n\nY\n\nX\n\nFig. 4.3.3 Errors in voxelization caused by thin sections\nWhen the Y or Z maximum value for the model lies between two adjacent rays, the first\nray will give valid intersections, but the next will not intersect inside the facets. As shown\nin the figure 4.4, the maximum error would be of half the voxel size. To include one more\nray will not give extra intersection as the intersection point will fail the facet inclusion\n47\n\ntest. If tolerance is provided on facet inclusion test, then we may get extra intersections\nwith adjacent triangles also. This may lead to wrong interpretation of geometry.\nFollowing figure 4.3.4 shows the errors in voxelization as voxels in thick black colour.\nThe figure on the right hand side shows the corrected voxel model. The erroneous voxel\nin form of one dimensional voxel structures such as a single isolated voxel, a voxel line or\na plane can be identified. These are the voxels which have specific surface connectivity\nconfiguration like only opposite faces connected, or opposite faces free and similar. If the\nvoxel model is scanned for such voxels, those can be reset and this will eliminate possible\nerroneous voxels to some extent. This is applicable when it is assured that the smallest\nfeature of the original model is bigger than two voxel dimensions. Otherwise this process\nmay remove some of feature details.\n\nFig.4.3.4 Image showing errors in voxelization\n\n48\n\nChapter 5\n\nVoxel display and analysis\n\nThere are many techniques for voxel display such as depth sorting or ray tracing, direct\nrendering,  ̳marching cube‘ and slicing. Many methods try to generate approximate\nsurfaces from the voxel data and render those surfaces with appropriate normals. These\ntechniques are useful for small volume data and when there is no surface information\navailable previously, like from medical scans with resolution of 2563.\nIn this project, as voxel model is generated from a STL file, which is the surface\ndefinition of object, again trying to extract surfaces from voxel data is unnecessary. Also,\nas the target resolution is of (1000)3 voxels, extracting surfaces from such huge voxel data\nwould be a very tedious task. Therefore a novel but direct method of displaying voxels as\npoints is implemented.\nWhen number of voxels is sufficiently large, displaying them as points will create a\ncontiguous surface like display. The problem is, points do not have normals and shadows\nlike 3D objects. Therefore for a point based display, variation in intensity can not be\nautomatically computed using standard graphics utilities. So, voxels at various locations\nover the model need to be given proper intensity values individually to create realistic\ndisplay. This is achieved using a predefined lookup table of intensity values\ncorresponding to neighbour configuration of every voxels.\n\n5.1 Intensity look-up table\nAs the voxels are assumed to be cubic in shape, every voxel will have maximum of 26\nneighbours as, voxels connected by face = 6, voxels connected by edge = 12, voxels\nconnected by vertex = 8. As for sufficiently higher resolution and normal solids without\nvery thin sections, most voxels are face connected. Also, while displaying voxel faces,\nonly face connectivity will determine the visibility of a particular voxel and not the edge\nor vertex connectivity. Therefore, for determining display intensity of voxels, only face\n\n49\n\nconnected neighbours are considered. Figure 5.1 shows the 6 face connected\nneighbouring voxels. The voxels numbers represent the order in which corresponding bits\nare read from the array and added to form an integer representing the neighbouring\nconfiguration as a whole.\nOnce the voxel data is obtained in form of bit array, the configuration of neighbouring\nvoxels can be obtained. This is done only for filled voxels.\n\n6\n\nZ\n\n4\n\nY\n2\n\nX\n\nX\n\n3\n\n1\n5\n\nFig.5.1 Face connected neighbouring voxels\nIf the current voxel has index  ̳X‘ in the bit array of plane Z, then its neighbours have\nindices as follows.\nIndex of  ̳1‘ = X – (resolution + 2)\nIndex of  ̳2‘ = X – 1\nIndex of  ̳3‘ = X + 1\nIndex of  ̳4‘ = X + (resolution + 2)\nIndex of  ̳5‘ = X (in the plane Z-1)\nIndex of  ̳6‘ = X (in the plane Z+1)\nThe status of these neighbour voxels is represented by either  ̳1‘ or  ̳0‘ in the array as\nwhen one is occupied or empty respectively. These neighbours are returned in the same\nsequence as 1-2-3-4-5-6. Each time the returned bit is added and then the bit string is\nshifted to left, except for the last bit. Thus the final bit string looks like 1-2-3-4-5-6.\nWhen this bit string is interpreted as integer, it gives a unique number for a particular\nneighbouring configuration. As there are total 26 = 64 combinations possible, the result\ncan be stored in a variable of type  ̳char‘. Now every voxel can be identified as surface or\ninterior. Also, amongst the surface voxels, a voxel can be categorized based on the\n\n50\n\nnumber of free faces where neighboring voxel is absent. This is shown in the following\ntable 5.1.\nTable 5.1 Sample bit strings from neighbouring voxel configuration\nNumber\nof free\n\nBit string\nSample configuration\n\nfaces\n\n4\n\n1\n\n2\n\n3\n\nX\n1\n\nX\n\nInteger\n\nNo. of similar\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\nreturned\n\nconfigurations\n\n1\n\n1\n\n1\n\n1\n\n1\n\n0\n\n62\n\n6\n\n1\n\n1\n\n0\n\n1\n\n1\n\n0\n\n54\n\n15\n\n1\n\n1\n\n0\n\n0\n\n1\n\n0\n\n50\n\n20\n\n0\n\n1\n\n0\n\n0\n\n1\n\n0\n\n18\n\n15\n\n0\n\n0\n\n0\n\n0\n\n1\n\n0\n\n2\n\n6\n\n5\n\n4\n\n2\n\n2\n\nX\n1\n\n5\n\nX\n\n3\n\n2\n\nX\n1\n\nX\n\n4\n\n2\n\n5\n\nX\n5\n\nX\n\nX\n\n5\n\n5\n\nX\nFor an error free STL and sufficiently large resolution, when the voxel size is smaller than\nthe thinnest section in the model, the voxels of type 4 and 5 from the above table should\nnot be present. These are the voxels with only one or two face connected neighbours and\n\n51\n\nrepresent a one or two dimensional structures at voxel level. If such voxels are found,\nthey can be treated as errors and can be reset to  ̳0‘.\nIf a sphere is voxelized, then voxels at various locations have configurations as shown\nbelow in figure 5.2. The numbers outside the bracket are the integers returned from bit\nstring.\n43(16)\n\n58(18)\n50(20)\n\n42(15)\n\n51(18)\n\n46(13)\n\n62(16)\n\n54(19)\n\n15(12)\nY\n\n22(13)\n\n14(10)\nX\n\n30(10)\n\nFig.5.2 Voxel intensities for a sphere\nDeciding voxel for a particular neighbouring configuration requires visualization and\njudgment. The voxel intensity values are rated on a scale of 20, as 0 is very dark to 20\nwhich is bright color. Table 5.2 is the intensity look-up table which holds the intensity\nvalues for various integers returned from bit string.\nFor every filled voxel, the bit string value is determined. Then the returned integer is\nsearched for in the intensity look-up table. When a match is found, corresponding\nintensity is returned and process moves to next voxel. In OpenGL , the point color is\ndefined as (0, currIntensity, 0) where currIntensity = (Intensity value / 20). It is taken into\nconsideration that while display, screen is Z = 0 plane. Therefore, considering the light\nfrom top right hand corner, the intensities are appropriately determined.\n\n52\n\nTable 5.2 Intensity look-up table\nIndex\n\nInteger\n\nIntensity\n\nIndex\n\nInteger\n\nIntensity\n\n1\n\n2\n\n20\n\n32\n\n26\n\n16\n\n2\n\n1\n\n12\n\n33\n\n19\n\n14\n\n3\n\n16\n\n20\n\n34\n\n49\n\n15\n\n4\n\n8\n\n14\n\n35\n\n41\n\n15\n\n5\n\n32\n\n20\n\n36\n\n13\n\n13\n\n6\n\n4\n\n10\n\n37\n\n21\n\n15\n\n7\n\n36\n\n18\n\n38\n\n50\n\n20\n\n8\n\n24\n\n16\n\n39\n\n42\n\n15\n\n9\n\n3\n\n14\n\n40\n\n14\n\n10\n\n10\n\n48\n\n20\n\n41\n\n22\n\n13\n\n11\n\n20\n\n14\n\n42\n\n27\n\n12\n\n12\n\n12\n\n20\n\n43\n\n39\n\n16\n\n13\n\n40\n\n16\n\n44\n\n60\n\n20\n\n14\n\n17\n\n14\n\n45\n\n15\n\n12\n\n15\n\n5\n\n16\n\n46\n\n43\n\n16\n\n16\n\n9\n\n12\n\n47\n\n51\n\n18\n\n17\n\n33\n\n14\n\n48\n\n23\n\n14\n\n18\n\n18\n\n20\n\n49\n\n46\n\n13\n\n19\n\n6\n\n18\n\n50\n\n58\n\n18\n\n20\n\n10\n\n16\n\n51\n\n54\n\n19\n\n21\n\n34\n\n20\n\n52\n\n30\n\n10\n\n22\n\n52\n\n14\n\n53\n\n45\n\n13\n\n23\n\n2\n\n20\n\n54\n\n57\n\n18\n\n24\n\n44\n\n20\n\n55\n\n53\n\n19\n\n25\n\n56\n\n16\n\n56\n\n29\n\n10\n\n26\n\n35\n\n14\n\n57\n\n61\n\n16\n\n27\n\n7\n\n16\n\n58\n\n62\n\n17\n\n28\n\n37\n\n16\n\n59\n\n47\n\n13\n\n29\n\n38\n\n18\n\n60\n\n55\n\n16\n\n30\n\n25\n\n12\n\n61\n\n31\n\n12\n\n31\n\n11\n\n12\n\n62\n\n59\n\n18\n\nVoxel with bit string corresponding to 63 is completely inside the solid body and hence\nnot visible.\n\n53\n\n5.2 Geometric analysis of voxel model\nThe regular arrangement of the voxels along the coordinate axes makes the addressing\nindividual voxels very easy as the index of a voxel is directly related to it‘s actual location\nin the 3D coordinate space. Though, this imposes some limitations on the manipulations\nthat could be done on the voxel model such as rotation of model or handling multiple\nbodies. This limitation however, can be overcome by appropriately modifying the original\nSTL model itself before voxelization. As the fundamental base with voxelization\nalgorithm and voxel model storage scheme is ready, to implement any end application\nover this base, few low level functions are required which can efficiently handle the voxel\nmodel. Such small functions include the functions to read, write individual voxel,\nhandling voxel bodies, display functions and others as listed below. The following set of\nfunctions is developed which provide modularity to the system and makes it easy to\nextend it‘s scope by addition of new applications over the same voxel framework.\nRead voxel with location (x,y,z)\nSet/reset given voxel\nGet voxel array index given it‘s (x,y,z) location\nGet voxel intensity code given (x,y,z)\nGet voxel intensity value given intensity code\nCopy entire voxel body\nDelete entire voxel body\nDisplay entire voxel body\nDisplay a single voxel\nDisplay a section in the voxel volume at specified location\nFind neighbour to given voxel along given direction at specified distance\nFind distance between two given voxels in terms of cell-distance\nRemove skin- reset surface voxels\nUsing these low level functions, some geometric applications are developed which are as\nfollows.\n\n54\n\n5.2.1 Progressive sectional display\nPlanar sections can be taken normal to any of the coordinate axes through the voxel\nmodel (fig. 5.2.1). These sections can be displayed to reveal interior of the voxel model at\nspecified location. The layered structure used for storing voxel model, makes the section\ndisplay very trivial along those planes. For the other two directions, little more recursions\nare required for accessing respective voxels from successive layers. The section is\nessentially a layer one voxel dimension thick. The advantage with voxel model is that it\ncan show the solid interiors in contrast to surface models.\n\nSuccessive section planes\nFig.5.2.1Progressive sectional display\n5.2.2 Skin removal simulation\nIn the voxel model, surface voxels can be exclusively identified. Surface voxels will be\nnon-zero with at least one neighbour missing. This condition will give certain number of\nvoxel intensity codes. So, by traversing through the entire voxel model, surface voxels\ncan be identified and reset to simulate one skin layer removal. The problem being that\neach voxel identified as surface voxel can not be reset immediately and then move to next\nvoxel for examination. this is because the rest voxel will change the original neighbour\nconfiguration for the next voxel to be examined. This problem is solved by traversing the\nvoxel model layer by layer. The structural layers are selected for ease of implementation.\nThen, first layer is examined and the indices of surface voxels are stored in temporary\narray without resetting any voxel. Then the next successive layer is examined for surface\nvoxels and similarly the indices of surface voxels identified are stored in\n\na temporary\n\narray. Now before moving to the third layer, the surface voxels from the first layer can be\nreset without affecting the original voxel configuration as the configuration of second\nlayer is already stored separately. Thus, every time a voxel layer which is one before the\nprevious is reset. The skin removal can be simulated one layer at a time\n55\n\nSurface voxels reset\n\nFig.5.2.2 Successive skin removal simulation\n5.2.3 X-ray scan\nThe voxel model can be scanned along any of the coordinate axes to generate X-scan\nimage of the model. This X-ray scan is useful for thickness analysis of the model. This\nreveals the interior thickness distribution in the model which is normally difficult to\nvisualize. The X-ray scan generates image wherein the intensity varies proportional to the\nthickness along the scan direction. Three options are provided for determining the\nintensity as the Minimum, Maximum and Total thickness along the scan direction at\nevery point. To generate X-ray scan image of a voxel model of resolution  ̳R‘, model is\nscanned along the scan direction for R2 rays. The voxel configuration along each of the\nrays is determined and the intensity at the point of projection of the ray on the image\nplane is determined according to the selected option.\n\nX-ray\n\nVoxel configuration along scan-line\n\nIntensity proportional\nto no. of voxels\n2\n\nMINIMUM\n8\nMAXIMUM\n14\nTOTAL\nFig.5.2.3 X-ray scan: Intensity variations proportional to thickness\n\n56\n\nChapter 6\n\nImplementation and results\nThis chapter presents the results of implementation of the developed voxelization\nalgorithm and the voxel model representation scheme. The memory and time required for\nvoxelization of various models of varying complexities is included. Chapter also includes\nthe display images generated by the system for various models with different resolution\nsettings. The images of display output from the functions like section display, skin\nremoval and X-ray scan are also presented.\n\n6.1 Voxelization\nThe voxelization and display algorithm developed is tested for various solid models.\nFollowing parameters are included in the results.\n1) Voxelization time for different resolutions\n2) Memory required for voxelization\n3) Display images of different resolution, point sizes and orientations\nThe implementation is done on a system with following configuration.\nIntel(R) Pentium, 2.40 GHz processor, 2GB RAM.\nThere are two sets of solid models considered for testing. One is a set of simple regular\nshapes. The other includes some engineering and non-engineering objects. Tables 6.1.1\nand 6.1.2 give the details of voxelization results for these solids respectively. Figures\n6.1.1, 6.1.2 and 6.1.3 show the graph plots for these results.\n\n57\n\nTable.6.1.1 Voxelization results for standard shapes\nResolution\nSr.\nNo.\n\nSTL file name\n\nSize\nKB\n\nNo. of\nFacets\n\n100\n\n200\n\n400\n\n500\n\n800\n\n1000\n\nM\n\nT\n\nM\n\nT\n\nM\n\nT\n\nM\n\nT\n\nM\n\nT\n\nM\n\nT\n\n1\n\nPyramid\n\n2\n\n6\n\n0.27\n\n0.078\n\n1.16\n\n0.407\n\n8.18\n\n2.453\n\n15.70\n\n4.468\n\n63.60\n\n16.36\n\n123.6\n\n30.64\n\n2\n\nPrism\n\n3\n\n8\n\n0.27\n\n0.141\n\n1.24\n\n0.704\n\n8.25\n\n3.985\n\n15.60\n\n7.171\n\n63.60\n\n25.43\n\n123.8\n\n46.98\n\n3\n\nDouble pyramid\n\n3\n\n8\n\n0.15\n\n0.031\n\n1.16\n\n0.156\n\n8.18\n\n0.875\n\n15.60\n\n1.532\n\n63.60\n\n5.25\n\n123.6\n\n9.58\n\n4\n\nCube\n\n4\n\n12\n\n0.24\n\n0.172\n\n1.23\n\n0.984\n\n8.27\n\n6.297\n\n15.60\n\n11.73\n\n63.60\n\n44.08\n\n123.6\n\n83.42\n\n5\n\nBlock\n\n4\n\n12\n\n0.36\n\n0.093\n\n1.33\n\n0.500\n\n8.35\n\n3.188\n\n15.70\n\n5.937\n\n63.70\n\n22.17\n\n123.7\n\n42.47\n\n6\n\nBlock\n(rotated)\n\n4\n\n12\n\n0.30\n\n0.141\n\n1.30\n\n0.719\n\n8.50\n\n4.015\n\n16.10\n\n7.125\n\n64.10\n\n25.56\n\n123.6\n\n44.17\n\n7\n\nBlock with hole\n\n33\n\n112\n\n0.60\n\n0.125\n\n1.70\n\n0.656\n\n7.40\n\n3.844\n\n13.06\n\n6.984\n\n47.4\n\n25.31\n\n89.5\n\n47.22\n\n8\n\nCylinder\n\n39\n\n136\n\n0.70\n\n0.171\n\n2.10\n\n0.906\n\n10.00\n\n5.500\n\n17.96\n\n9.922\n\n67.00\n\n36.50\n\n127.9\n\n68.11\n\n9\n\nSphere\n\n652\n\n2352\n\n1.80\n\n0.219\n\n4.00\n\n1.016\n\n13.50\n\n4.922\n\n22.30\n\n8.610\n\n73.80\n\n29.39\n\n136.2\n\n53.31\n\n10\n\nCup\n\n788\n\n2814\n\n1.90\n\n0.172\n\n3.54\n\n0.640\n\n9.70\n\n2.531\n\n14.75\n\n4.047\n\n42.56\n\n11.02\n\n75.2\n\n17.84\n\nM = Memory required for voxelization (MB), T = Time required for voxelization (sec)\n\n58\n\n90\n\n70\n60\n\n100\n200\n\n50\n\n400\n500\n\n40\n\n800\n1000\n\n30\n20\n10\n\nSolid model\n\nFig.6.1.1 Time for Voxelization of standard shapes with different resolution\n\n59\n\nC\nup\n\ner\ne\nSp\nh\n\ner\nC\nyl\nin\nd\n\nle\nw\nith\n\nBl\noc\n\nk\n\nk(\n\nro\nta\n\nte\n\nho\n\nd)\n\nk\nBl\noc\n\ne\n\nBl\noc\n\nra\npy\nbl\ne\n\nD\nou\n\nC\nub\n\nm\nid\n\nm\nPr\nis\n\nam\n\nid\n\n0\n\nPy\nr\n\nVoxelization time (sec)\n\n80\n\nTable 6.1.2 Voxelization results for various solid models\nResolution\nSr.\nNo.\n\nSTL file name\n\nSize\nKB\n\nNo. of\nFacets\n\n100\n\n200\n\n400\n\n500\n\n800\n\n1000\n\nM\n\nT\n\nM\n\nT\n\nM\n\nT\n\nM\n\nT\n\nM\n\nT\n\nM\n\nT\n\n1\n\nValve\n\n354\n\n2352\n\n0.60\n\n0.140\n\n1.60\n\n0.594\n\n6.60\n\n2.782\n\n11.50\n\n4.656\n\n41.50\n\n14.26\n\n78.3\n\n24.50\n\n2\n\nEnd shield\n\n951\n\n3714\n\n2.30\n\n0.281\n\n4.80\n\n1.00\n\n15.30\n\n3.766\n\n24.50\n\n5.89\n\n77.30\n\n15.45\n\n140.6\n\n24.67\n\n3\n\nCrank\n\n1651\n\n6184\n\n1.80\n\n0.125\n\n3.50\n\n0.375\n\n12.20\n\n1.215\n\n20.68\n\n1.734\n\n76.00\n\n4.40\n\n133\n\n7.15\n\n4\n\nBody cap\n\n1948\n\n7430\n\n2.43\n\n0.187\n\n4.57\n\n0.532\n\n13.50\n\n2.250\n\n21.50\n\n3.531\n\n67.80\n\n9.219\n\n123.6\n\n14.81\n\n5\n\nCover\n\n2599\n\n15776\n\n7.10\n\n0.656\n\n13.10\n\n2.578\n\n29.60\n\n9.281\n\n41.40\n\n14.47\n\n99.10\n\n37.00\n\n163\n\n58.50\n\n6\n\nGanesha\n\n4140\n\n19298\n\n5.30\n\n0.328\n\n8.50\n\n1.062\n\n17.35\n\n3.610\n\n23.80\n\n5.531\n\n55.50\n\n14.11\n\n90.55\n\n22.58\n\n7\n\nPelvis\n\n8978\n\n41100\n\n10.30\n\n0.859\n\n15.60\n\n2.203\n\n30.70\n\n6.313\n\n41.80\n\n9.047\n\n97.20\n\n20.92\n\n158.9\n\n32.15\n\n8\n\nValve top\n\n12355\n\n73912\n\n17.40\n\n1.61\n\n25.40\n\n4.89\n\n43.28\n\n17.06\n\n53.90\n\n25.80\n\n96.70\n\n64.33\n\n137.1\n\n99.95\n\n9\n\nTest piece\n\n12648\n\n45892\n\n8.90\n\n0.453\n\n11.90\n\n1.078\n\n19.85\n\n4.047\n\n24.95\n\n6.078\n\n48.40\n\n15.84\n\n72.75\n\n25.91\n\n10\n\nNaval crest\n\n20787\n\n75260\n\n11.5\n\n0.484\n\n13.56\n\n1.156\n\n19.26\n\n3.844\n\n22.90\n\n5.937\n\n35.50\n\n14.30\n\n47.45\n\n22.39\n\nM = Memory required for voxelization (MB), T = Time required for voxelization (sec)\n\n60\n\n120\n\nVoxelization time (sec) .\n\n100\n\n80\n\n100\n200\n400\n500\n800\n1000\n\n60\n\n40\n\n20\n\n0\nValve\n\nEnd shield\n\nCrank\n\nBody cap\n\nCover\n\nGanesha\n\nPelvis\n\nValve top Test piece\n\nSolid model\n\nFig.6.1.2 Time for Voxelization of various solid models with different resolution\n\n61\n\nNaval\ncrest\n\n160\n\n180\n\n140\n\n160\n140\n\nMemory required (MB) .\n\n100\n\n100\n\n200\n400\n\n80\n\n500\n800\n\n60\n\n1000\n\n40\n\n120\n\n100\n200\n400\n500\n800\n1000\n\n100\n80\n60\n40\n\n20\n20\n\nup\n\nV\nEn alv\ne\nd\nsh\nie\nld\nC\nra\nBo nk\ndy\nca\np\nC\nov\ne\nG\nan r\nes\nha\nPe\nVa lvis\nlv\ne\nTe to\np\nst\npi\nN\nav ece\nal\ncr\nes\nt\n\nC\n\nub Blo\nck\ne\nBl (rot\nat\noc\ne\nk\nwi d)\nth\nho\nle\nC\nyli\nnd\ne\nSp r\nhe\nre\n\n0\n\nC\n\nub\ne\nC\n\nis\nm\nhe\ndr\non\n\nTe\ntra\n\nm\nra\n\nPr\n\nid\n\n0\n\nPy\n\nMemory required (MB) .\n\n120\n\nSolid model\n\nSolid model\n\n(a)\n(b)\nFig.6.1.3 Memory required for Voxelization of standard shapes and various solid models with different resolution respectively\n\n62\n\n6.2 Voxel display\nDisplaying voxel model as collection of points requires point size to be controlled\nproperly in relation to  ̳resolution‘ as well as the object display size on the screen. As a\nvertex is drawn as a pixel or a group of pixels, the size in terms of pixels is properly set.\nTo reduce the aliasing effect and also have smooth variation in color shades, standard\nantialiasing and smoothening is used from graphics utility. Figure 4.2.1 shows the images\nof sphere and pyramid at resolution of 20 with Point smooth Off and On.\n\n(a) without smooth and blend\n\n(b) with smooth and blend\n\nFig.6.2.1 Voxel images with point-smooth Off and On (R=20)\nFigure 6.2.2 shows the images of sphere drawn for resolution of 200 with different\ndisplay sizes. Display size is determined by the  ̳zoom‘ level set by the Z-value of origin\nin relation to object. Here, S= size of the point in terms of pixels, which represents\nindividual voxel. It is observe that as the object display size increases, the image\nsmoothness reduces. This is because the point size also increases, and then the effect of\nintensity smoothening is reduced in the interior of a point, which is a considerable area\nfor larger point sizes.\n\n(a) S=2\n(b) S=3.2\n(c) S=4\n(d) S=4.5\nFig.6.2.2 Voxel images with Zoom and corresponding change of point size(S)\n(Resolution=200)\n63\n\nFigure 6.2.3 shows the images of sphere with same size of display but with different\nresolutions and corresponding point size. It is quite clear that, as the resolution increases,\nthe intensity variation becomes very gradual and image looks smooth. This is because of\nthe fact that as resolution increases, the point size reduces, and moreover, the effect of\nsmoothening is more evident. But, this comes at a cost of more time and memory for\ndisplay.\n\n(a) R=100\n\n(b) R=200\n\n(d) R=800\n\n(c) R=400\n\n(e) R=1000\n\nFig.6.2.3 Voxel images with different resolutions (R)\nFigure 6.2.4 shows the sphere displayed as voxel model with resolution of 200 from\nvarious angles of views. The variation in this case is effect of the intensity set in the\nintensity look-up table for various voxel configurations.\n\n(a) 30\n\n(b) 60\n\n(d) 120\n\n(c) 90\n\n(e) 150\n\nFig. 6.2.4 Voxel images with different angles of rotation about Y-axis (Resolution= 200)\n\n64\n\nAs can be seen in figure 6.2.5, when the Ganesha model is imported in FreeForm, the\nvoxel model in the form of *.cly format, which is native format for FreeForm had errors.\nAs can be seen the trunk got connected to the body though it is not so originally. This\nhappened at resolutions of 200 and 400 also. But, the voxelization algorithm in this\nproject, that error is not generated. Also when attempted to get voxel resolution of 800 or\n1000 in FreeForm, the memory requirement goes up to 500-800 MB, and the size of\nsimple cube model in *.cly format becomes of the order of 40-50 MB. Also, the\nfunctioning and display becomes very slow for resolutions above 500. So, the results from\nthe voxelization algorithm proposed in the project are very much comparable to FreeForm\nif not better. But, it is remembered that the application intended from developed voxel\nmodel may be different and not haptic modeling as FreeForm. Still, the display of the\nvoxel model in the current project needs to be improved for quality and moreover time.\nCurrently, the time taken for display is of the order of 2minutes for cube with resolution\nof 1000.\n\nVoxel display\n\nFreeForm display\n\nFig.6.2.5 Voxel model from the project and from FreeForm (Resolution= 200)\nFigures 6.2.6 shows the voxel display images of various solid models considered. All\nimages are at resolution 400, with point display size of 3 pixels and view rotated. Figures\n6.2.7, 6.2.8, 6.2.9 show voxel display images of Ganesha model, pelvis model and\ncylinder block model at various resolutions respectively.\n\n65\n\nValve\nCover\n\nGanesha\n\nEnd shield\n\nPelvis\n\nCrank\n\nValve top\n\nBody cap\n\nTest piece\n\nFig.6.2.6 Voxel display images of various solid models with resolution of 400\n66\n\nNaval crest\n\n(a) R=100\n\n(a) R=100\n\n(b) R=200\n(c) R=400\n(d) R=800\nFig.6.2.7 Display Images fro Ganesha model with different resolutions (R)\n\n(b) R=200\n(c) R=400\n(d) R=800\nFig.6.2.8 Display Images of pelvis model with different resolutions(R)\n67\n\n(e) R=1000\n\n(e) R=1000\n\n(a) R=100\n\n(b) R=200\n\n(c) R=400\n\n(d) R=800\n\nFig.6.2.9 Display Images of cylinder block with different resolutions(R)\nThe results of the display algorithm developed are quite satisfactory as far as the\nrendering quality is considered. The display is smoother and more realistic than the\nsimple display rendering individual voxel faces. But still the algorithm takes longer time\nto render models of high resolutions. Currently it takes less than 2 seconds to generate an\nimage of resolution up to 200. The time required to render higher resolution images\ndepends upon the object shape and varies in the range 2-150 seconds. The rendering time\ncan be further reduced by implementing the concept of  ̳display-list‘. This is simplified\nlisting of visible voxels which can be directly rendered. But, this is valid for voxel models\nwhich do not change. If any change is made in the voxel configuration of the model, a\nnew display-list has to be generated after every such change.\n\n68\n\n6.3 Voxel section display\nSections of voxel model can be displayed along the coordinate axes. Sections normal to\nZ-axis is very trivial as the voxel model is stored as a stack of X-Y planes. For display of\nsections normal to X or Y plane, it requires more computations to find the appropriate\nvoxels in different Z-planes. The sections can be displayed at a specified point or also as\nsuccessive incremental sections.\n\nFig.6.3 Sectional Display Images of cylinder block and Ganesha model with different\nresolutions(R)\n\n69\n\n6.4 Skin removal\nThis is a very novel function which allows voxel model to be pealed off layer by layer.\nThis operation ultimately points to the thickest portion of the model on continuous skin\nremoval till last filled voxel. In principal, at every skin removal, surface voxels are\nidentified and reset to zero. Surface voxels are those which are filled but are not\ncompletely inside the object. Surface voxels have at least one face free.\n\nFig.6.4 Successive Skin removal Images of cylinder block with resolution 200\n\n70\n\n6.5 X-ray scan display\nX-ray scan can be performed along any of the coordinate axes. In X-ray scan, there are\nthree options as follows.\na) Minimum thickness- the intensity at any point is proportional to the minimum section\nthickness found along the corresponding scan ray.\nb) Maximum thickness- the intensity at any point is proportional to the maximum section\nthickness found along the corresponding scan ray.\nc) Total thickness- the intensity at any point is proportional to the total of all section\nthicknesses found along the corresponding scan ray.\nX-ray scan is particularly useful in analyzing internal thickness variations in a model\nwhich is difficult to visualize otherwise. The three options provided are very much useful\nand eliminate the limitation of normal X-ray scan which does not identify individual\nsections as minimum or maximum. Figures 6.5.1 and 6.5.2 show the X-ray scan images\ngenerated for Ganesha model and cylinder block model. the white spots or stray lines\nindicate the errors in voxelization as missing voxel segment or extra voxel segment\nrespectively.\n\n71\n\nFig. 6.5.1 X-ray scan images of Ganesha model with minimum, maximum and total thickness options respectively (R=200)\n\n72\n\nFig. 6.5.2 X-ray scan images of Cylinder block model along two directions and with different thickness options (R=200)\n\n73\n\nChapter 7\n\nConclusions\n\nSolid modeling is essential for all CAE implementations and other computer integrated\nprocesses in engineering businesses. Voxel based solid modeling techniques provide\ncapabilities additional to conventional surface modeling which enable processing of very\ncomplex, free-form parts and assemblies. The advances in computer technology have\nmade possible to implement voxel based systems on desktop PCs with sufficient accuracy\nand efficiency. Though voxel based techniques may not replace surface modeling, they\noffer much better solutions for certain problems, especially involving volumetric\ninformation and analysis. The focus of the work has been on resolving the problems of\nmemory and time for high resolution voxel models and to develop completely new\nflexible voxel based modeling environment adaptable to various applications. The aim is\nto use capabilities of volumetric modeling into engineering fields as a supplement to\nconventional surface modeling.\n\n7.1 Summary of work done\nThe main goal of the project was to develop a voxel based model representation and\ndisplay module which can efficiently handle up to 1 billion voxel models. This gives\nvoxel resolution of 1000 along all coordinate axes which is sufficient for most of the\ncases. A completely new and custom designed voxel based modeling environment is\ndeveloped. The basic framework to generate, store and handle voxel models of\nresolutions up to 1billion voxels is implemented. The results of voxelization are\nsatisfactory. The developed voxel representation considers cubic voxels aligned with\ncoordinate axes. Spatial enumeration is used to store these binary voxel models. A stack\nof bit-arrays is used to store voxel model. A new point based voxel display method is\nimplemented which gives refresh rate of less than 2seconds for resolutions up to 200. The\nintensity variation in voxel image is achieved through intensity look-up table which gives\nintensity values corresponding to various voxel configurations. The display is much more\nrealistic than simple cube surface display. Using this basic voxel representation and\n\n74\n\ndisplay scheme, few low level geometric routines are written. These can be used to\ndevelop high end geometric analysis functions and application. Sectional display, X-ray\nscan and skin removal are the modules implemented over the developed voxel base. The\nvoxel modeling system is tested for numerous engineering as well as non-engineering\nmodels.\n\n7.2 Future scope\nThe main goal of the project has been successfully achieved. The system works very well\nfor resolutions up to 400. Though, further improvements are necessary for efficient\nhandling of voxel models with resolution of 1000. This may require custom designed\nhardware modifications. Special memory architectures may solve the problem. This will\nalso allow for interactive viewing of high resolution voxel models which is currently not\npossible. The voxel file format is proposed which uses concept of  ̳run-lengths‘. Standard\nconversion routines can be written to read and write such voxel files. On the similar basis,\na gray scale voxel based system can also be devised. Also, system could be modified to\nhandle multiple voxel models simultaneously. This will allow standard Boolean\noperations over different voxel models.\nMore specifically, over the present system, immediately possible improvements may\ninclude the following. The display could be further enhanced by tuning the intensity\nvalues. The voxelization errors can be minimized by considering voxelization from\nmultiple directions and then combining the resulting voxel models. The display could be\nimproved to include colors and transparency. Currently, the rotation of view is\nincorporated as view direction change with light positioned stationary. But, with simple\nglobal rotation variables, a changing intensity can be implemented so as to depict object\nrotation. Also, the display could be made faster by using  ̳display lists‘ which will store\nvoxel information in more ready to display form for a fixed voxel model.\nUsing the basic framework developed, a voxel based application module can be\ndeveloped for engineering applications such as casting analysis. The system can be\ncoupled with a good user interface and controls. The voxel based module can also be\nadded to existing applications as a supplement.\n\n75\n\nAppendix A\n\n‘STL’ file format\nThere are various file formats for storing solid model data like STL, IGES, STEP, etc.\nThe  ̳.stl‘ or stereolithography format is an ASCII or binary file used in manufacturing.\nSTL stands for Stereolithographic Tessellated Language. It is a list of the triangular facets\nthat describe a computer generated solid model. This is the standard input for most rapid\nprototyping machines. The ASCII .stl file starts with the lower case keyword solid and\nend with endsolid. Within these keywords are listings of individual triangles that define\nthe faces of the solid model. Each individual triangle description defines a single normal\nvector directed away from the solid's surface followed by the xyz components for all three\nof the vertices.\nThe STL files have typical advantages of use as they constitute a simple data structure\ninvolving facets, which is repeated throughout the file. Also, the file is easy to read and\nthe connectivity relations between the facets, edges and vertices are easy to store.\nFollowing is a sample ASCII description of a single triangle within an STL file.\nsolid\n...\nfacet normal 0.00 0.00 1.00\nouter loop\nvertex 2.00 2.00 0.00\nvertex -1.00 1.00 0.00\nvertex 0.00 -1.00 0.00\nendloop\nendfacet\n...\nendsolid\n\n76\n\nAppendix B\n\n3D discrete topology\nThe 3D discrete space is a set of integral grid points in 3D Euclidean space defined by\ntheir Cartesian coordinates (x, y, z). A voxel is the unit cubic volume centered at the\nintegral grid point. The voxel value is mapped onto {0,1}: the voxels assigned  ̳ ̳1‘‘ are\ncalled the  ̳ ̳black‘‘ voxels representing opaque objects and those assigned  ̳ ̳0‘‘ are the\n̳ ̳white‘‘ voxels representing the transparent background [Kaufman, 1993]. Sometimes\nthe voxel value is mapped onto the interval [0,1] representing either partial coverage,\nvariable densities, or graded opacities. Due to its larger dynamic range of values, this\napproach supports 3D antialiasing and thus supports higher quality rendering.\nEvery voxel has 26 neighboring voxels. Two voxels are 26-adjacent if they share either a\nvertex, an edge, or a face (Fig. A2). Accordingly, face-sharing voxels are defined as 6adjacent, and edge-sharing and face-sharing voxels are defined as 18-adjacent. A\nsequence of voxels having the same value (e.g.  ̳ ̳black‘‘) is called an N-path if all\nconsecutive pairs are N-adjacent. A set of voxels W is N-connected if there is an N-path\nbetween every pair of voxels in W. An N-connected component is a maximal N-connected\nset.\nGiven a 2D discrete 8-connected black curve, there are sequences of 8-connected white\npixels (8-component) that pass from one side of the black component to its other side\nwithout intersecting it. This phenomenon is a discrete disagreement with the continuous\ncase where there is no way of penetrating a closed curve without intersecting it. To avoid\nsuch a scenario, it has been the convention to define  ̳ ̳opposite‘‘ types of connectivity for\nthe white and black sets.  ̳ ̳Opposite‘‘ types in 2D space are 4 and 8, while in 3D space 6\nis  ̳ ̳opposite‘‘ to 26 or to 18.\n\n77\n\nFig. A2 Voxel connectivity\n\n78\n\nReferences\n\n[1] Acker, D.E., Sobierajski, L., Cohen, D., Kaufman, A., Yagel, R., ―A fast display\nmethod for Volumetric data‖, The Visual Computer: International Journal of\nComputer Graphics, Vol. 10, No. 2, pp.116-124, 1993.\n[2] Chandru, V., Manohar, S., and Prakash, C.E., ―Voxel based Modeling for Layered\nManufacturing‖, IEEE Computer Graphics and Applications, Vol. 15, No. 6, pp. 4247, Nov 1995.\n[3] Cohen, M.F., Greenberg, D.P., ―A Radiosity solution for complex environments‖,\nComputer Graphics, Vol. 9, No 3., pp. 31-40, July 1985.\n[4] Elvins, T.T., \"A Survey of Algorithms for Volume Visualization\", Computer\nGraphics, Vol. 26, No.3, pp. 194-201, 1992.\n[5] Fang, S., Hongsheng Chen, ―Hardware accelerated voxelization‖, Computers &\nGraphics, Vol. 24, No. 3, pp. 433-442, June 2000.\n[6] Fang, S., Liao, D., ―Fast CSG Voxelization by Frame Buffer Pixel Mapping‖,\nIEEE/ACM Proceedings of Volume Visualization and Graphics Symposium, Salt\nLake City, UT, U.S.A., pp. 43-48, 2000.\n[7] ―Gaussian file format‖, http://astronomy.swin.edu.au/~pbourke/geomformats/cube/,\nDec 2000.\n[8] Huang, J., Yagel, R., Filippov, V., Kurzion, Y., ―An accurate method for voxelizing\npolygon meshes‖, Proceedings of the 1998 IEEE symposium on Volume\nvisualization, pp. 119-126, 1998.\n[9] Jense, G.J., ―Voxel-based methods for CAD‖, Computer-aided design, Vol. 21, No. 8,\npp. 528-533, Oct 1989.\n[10] Jones, M.W., ―The Production of Volume Data from Triangular Meshes Using\nVoxelisation‖, EuroGraphics, Computer Graphics Forum, Vol.15, No. 5, pp. 311-318,\n1996.\n[11] Jones, M.W., Satherley, R.A., ―Shape representation using space filled sub-voxel\ndistance fields‖, International Conference on Shape Modeling and Applications, pp.\n316-325, May 2001.\n[12] Kaufman, A., Shimony, E., ―3D scan-conversion algorithms for voxel based\ngraphics‖, Proceedings of the 1986 workshop on Interactive 3D graphics, pp. 45-75,\n1987.\n\n79\n\n[13] Kaufman, A., Cohen, D. and Yagel, R.,  ̳ ̳Volume Graphics‘‘, IEEE Computer, Vol.\n26, No. 7, pp. 51-64, July 1993.\n[14] Lorensen, W.E., Cline, H.E., ―Marching Cubes: A high resolution 3D surface\nreconstruction algorithm‖, Computer Graphics, Vol. 21, No. 4, pp. 163-169, July\n1987.\n[15] Lu, S.C., Rebello, A.B., Cui, D.H., Yagel, R., Miller, R.A., Kinzel, G.L., ―A\nVisualization Tool For Mechanical Design‖, Proceedings of the 7th conference on\nVisualization, pp. 401-404, 1996.\n[16] Nooruddin, F. S., Turk, G., ―Simplification and Repair of Polygonal Models Using\nVolumetric Techniques‖, IEEE Transactions on Visualization and Computer\nGraphics, Vol. 9, No. 2, pp. 191-205, April-June 2003.\n[17] Prakash, C.E., Nandy, S.K., ―Voxel based modeling and rendering irregular solids‖,\nMicroprocessing and Microprogramming, Vol. 30, No. 1-5, pp. 341-346 , Aug 1990.\n[18] Stytz, M.R., Frieder, G., Frieder, O., ―Three-Dimensional Medical Imaging:\nAlgorithms and Computer Systems‖, ACM Computing Surveys, Vol. 23, No. 4,\nDecember 1991.\n[19] TeraRecon Inc., ―Voxel file format‖, http://www.terarecon.com /downloads /support/\nvp1000_voxelfileformat.pdf, 2002.\n[20] Wang, S.W., Kaufman, A.E., ―Volume sampled voxelization of geometric\nprimitives‖, Proceedings of the 4th conference on Visualization, pp. 78-84, 1993.\n[21] Yagel, R., Lu, S.C., Rebello, A.B., Miller, R.A., ―Volume based reasoning and\nvisualization of Diecastability‖, Proceedings of the 6th conference on Visualization,\npp. 359-362, 1995.\n\n80\n\n","pages":{"startPosition":[0,5000,9998,14995,20000,25001,29992,34999,39998,45000,49998,54994,60000,64994,69999,74998,80001,85001,89995,94986,99995,105000,109997,114993,119992,125001]}},"html":{"comparison":{"identical":{"groupId":[],"source":{"chars":{"starts":[],"lengths":[]},"words":{"starts":[],"lengths":[]}},"suspected":{"chars":{"starts":[],"lengths":[]},"words":{"starts":[],"lengths":[]}}},"minorChanges":{"groupId":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"source":{"chars":{"starts":[7071617,7071635,7071643,7071664,7071672,7071694,7071702,7071721,7071729,7071750,7071758,7071782,7071790,7071859,7071878,7071886,7071904,7071912,7071936,7071944,7071962,7071970,7071987,7071995,7072017,7072025,7072044,7072052,7072070,7072078,7072097,7072105,7072124,7072132,7072156,7072164,7072186,7072194,7072212,7072220,7072239,7072247,7072269,7072277,7074783,7074807,7074815,7074835,7074843,7074862,7074870,7074889,7074897,7074928,7074936,7074953,7074961,7074982,7074990,7075011,7075019,7075042,7075050,7075069,7075077,7075103,7075111,7075134,7075142,7075161,7075169,7075195,7075203,7075268,7075290,7075298,7075315,7075323,7075348,7075356,7075378,7075386,7075406,7075414,7075439,7075447,7075474,7075482,7075504,7075512,7075530,7075538,7075564,7075572],"lengths":[2,1,5,1,6,1,3,1,5,1,8,1,6,3,1,2,1,8,1,2,1,1,1,6,1,3,1,2,1,3,1,3,1,8,1,6,1,2,1,3,1,6,1,7,8,1,4,1,3,1,3,1,12,1,1,1,5,1,5,1,7,1,3,1,10,1,7,1,3,1,10,1,2,6,1,1,1,9,1,6,1,4,1,9,1,11,1,6,1,2,1,10,1,7]},"words":{"starts":[101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101552,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650,101650],"lengths":[22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25]}},"suspected":{"chars":{"starts":[53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,53613,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674,54674],"lengths":[119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144]},"words":{"starts":[8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8227,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384,8384],"lengths":[21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19]}}},"relatedMeaning":{"groupId":[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"source":{"chars":{"starts":[7070661,7070686,7070694,7070727,7070735,7070809,7070840,7070848,7070867,7070875,7070896,7070904,7070925,7070933,7070951,7070959,7070984,7070992,7071010,7071018,7071037,7071063,7071087,7071095,7071119,7071127,7071149,7071175,7071202,7071210,7071232,7071240,7071320,7071344,7071352,7071370,7071378,7071402,7071410,7071429,7071437,7071457,7071465,7071491,7071499,7071517,7071525,7071544,7071552,7071575,7071583],"lengths":[5,1,17,1,11,12,1,3,1,5,1,5,1,2,1,9,1,2,1,3,1,8,1,8,1,6,1,11,1,6,1,3,8,1,2,1,8,1,3,1,4,1,10,1,2,1,3,1,7,1,7]},"words":{"starts":[101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525,101525],"lengths":[26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26]}},"suspected":{"chars":{"starts":[53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363,53363],"lengths":[166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166]},"words":{"starts":[8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190,8190],"lengths":[23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23]}}}}},"version":3}