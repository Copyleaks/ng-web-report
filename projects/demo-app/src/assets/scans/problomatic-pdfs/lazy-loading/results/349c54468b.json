{"statistics":{"identical":562,"minorChanges":3,"relatedMeaning":2},"text":{"comparison":{"identical":{"source":{"chars":{"starts":[40213,40311,40611,40799,40895,40990,41068,41248,41329,41353,41456,41480,41669,41963,42442,42638,42774,42850,42971,43112,43295,43517,43581,43605,43890,44023,44091,44189,44295,44443,44636,44751,45050],"lengths":[45,39,23,21,19,19,37,35,23,17,23,29,53,39,23,51,23,31,51,53,39,31,23,37,59,19,43,35,19,45,43,21,23]},"words":{"starts":[5805,5835,5907,5943,5963,5982,5999,6044,6068,6080,6096,6108,6135,6198,6280,6311,6353,6374,6400,6436,6489,6537,6558,6570,6623,6665,6684,6714,6752,6779,6829,6862,6914],"lengths":[22,19,11,10,9,9,18,17,11,8,11,14,26,19,11,25,11,15,25,26,19,15,11,18,29,9,21,17,9,22,21,10,11]}},"suspected":{"chars":{"starts":[2198,2277,2361,2385,2429,2453,2516,2615,2708,2770,2794,2988,3050,3356,3511,3720,3795,3819,3883,3971,4173,4260,4350,4412,4584,4858,4963,5049,5155,5225,5311,5466,5490],"lengths":[45,39,23,21,19,19,37,35,23,17,23,29,53,39,23,51,23,31,51,53,39,31,23,37,59,19,43,35,19,45,43,21,23]},"words":{"starts":[334,361,390,402,416,428,452,488,524,548,560,604,624,683,722,768,797,809,833,864,923,959,994,1018,1066,1132,1152,1188,1231,1255,1291,1332,1344],"lengths":[22,19,11,10,9,9,18,17,11,8,11,14,26,19,11,25,11,15,25,26,19,15,11,18,29,9,21,17,9,22,21,10,11]}}},"minorChanges":{"source":{"chars":{"starts":[40259,43086],"lengths":[8,7]},"words":{"starts":[5828,6433],"lengths":[1,0]}},"suspected":{"chars":{"starts":[2247,3942],"lengths":[8,3]},"words":{"starts":[358,860],"lengths":[1,0]}}},"relatedMeaning":{"source":{"chars":{"starts":[43094],"lengths":[17]},"words":{"starts":[6434],"lengths":[1]}},"suspected":{"chars":{"starts":[3952],"lengths":[17]},"words":{"starts":[862],"lengths":[1]}}}},"value":"-4 FRXMEIirORK FOR EXPERIMEXTS IS CSPS\n\nGeorge Katsirelos\n\nA thesis submitted in conformity with the requirements\nfor the degree of MSc\nGraduate Department of Cornputer Science\nUniversity of Toront O\n\nCopyright @ 2001 by George Katsirelos\n\nNational Library\n\nBibliothéque nationale\ndu Canada\n\nAcquisitions and\nBibliographie Services\n\nAcquisitions et\nservices bibliographiques\n\n395 Wellington Street\nOttaweON K1AON4\n\n395, nie Wellington\nOttawa ON K1 A W\n\nCanada\n\n-da\n\nThe author has ganted a nonexclusive licence aiiowing the\nNational Library of Canada to\nreproduce, loan, distrilmte or seil\ncopies of this thesis in microform,\npaper or electronic formats.\n\nL'auteur a accordé une licence non\nexclusive permettant à la\nBibliothèque nationale du Canada de\nreproduire, prêter, distribuer ou\nvendre des copies de cette thèse sous\nla fome de microfiche/film, de\nreproduction sur papier ou sur format\nélectronique.\n\nThe author retains ownership of the\ncopyright in this thesis. Neither the\nthesis nor substantid extracts fiom it\nmay be printed or otherwise\nreproduced without the author's\npermission,\n\nL'auteur conserve la propriété du\ndroit d'auteur qui protège cette thèse.\nNi la thèse ni des extraits substantiels\nde celle-ci ne doivent être imprimés\nou autrement reproduits sans son\nautoisation.\n\nA framework for experiments in CSPs\nGeorge Kat sirelos\n\niL1Sc\nGraduate Department of Cornputer Science\nUniversity of Toronto\n\n200 1\n\nThe Constraint Satisfaction Problem (CSP) is an NP-cornplete problem. which allows\nflexible and intiiit ive representation of real-world problems.\nIn this thesis, we present a consistent view of existing search algorithms and variable\nordering heuristics. We t hen examine several aspects of building a CSP solver to accommodate t heir requirements in a generic way. We demonstrate the feasibility of using t his\nsolver t o perform experiments in common problems. Finally, we present and examine the\nperformance of a new heuristic method t o manipulate existing CSP models by conjoin-\n\ning constraints in order to improve their performance when used with the GAC search\nalgori t hm.\n\nContents\n1 Introduction\n\n1\n\n.....................\n\n1\n\nApplications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n2\n\n1.2.1\n\nOptirnalGolombRuler . . . . . . . . . . . . . . . . . . . . . . . .\n\n2\n\n1.2.2\n\nAssembly line sequencing . . . . . . . . . . . . . . . . . . . . . . .\n\n3\n\n1.2.3\n\nScheduling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n3\n\n1.3 Research in CSPs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n3\n\n1.3.1\n\nAIgorithms and Heuristics . . . . . . . . . . . . . . . . . . . . . .\n\n4\n\n1.3.2\n\nRepresentations . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n5\n\nContributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n6\n\n1.1 The constraint satisfaction problem\n1.2\n\n1.4\n\n2 Previous Work\n\n8\n\n.................................\n\nY\n\n2.2 C0nstra.int Propagation . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n9\n\n2.2.1\n\nLocalcoosistency . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n9\n\n2.2.2\n\nForward Checking (FC)\n\n.......................\n\n12\n\n2.2.3\n\nMaintaining Generalized Arc Consistency(MGAC) . . . . . . . . .\n\n12\n\n2.2.4\n\nMaintaining Arc Consistency (MAC)\n\n................\n\n13\n\n...........................\n\n14\n\nBackjumping(BJ) . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n16\n\n2.1\n\nBacktracking\n\n2.3 Intelligent Backtracking\n2.3.1\n\n2.3.2 Conff kt directed BackjumpingfCBJ) . . . . . . . . . . . . . . . .\n\nt7\n\nValue specific Cooflict directed Backjurnping (vsCBJ) . . . . . . .\n\n18\n\nCombining Constraint Propagation with Intelligent Backtracking . . . . .\n\n19\n\n2.4.1\n\nFCCBJ, GACCBJ . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n20\n\n2.4.2\n\nCFFC,CFGAC . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n\n2.4.3\n\nA unified view . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n2.3.3\n2.4\n\n2.5\n\nHeuristics\n\n2.5.1\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n\nWhy heuristics work (or not )\n\n....................\n\n3 Implementation\n3.1\n\n--\n\n39\n\n25\n\n27\n\nBasic Infrastructure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n\n3.1.1\n\nVariables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n3.1.2\n\nConsiïaints\n\n:30\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n\n3.2\n\nAlgorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n35\n\n3.3\n\nKeuristics\n\n...................................\n\n41\n\n4 Experiments\n\n44\n\n4.1\n\nOverview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n44\n\n4.2\n\nAutomatic conjunction of constraints\n\n....................\n\n44\n\n4.3\n\n4.4\n\n4.5\n\n4.2.1\n\nWhy conjoining causes more pruning\n\n................\n\n-15\n\n4.2.2\n\nWhen to conjoin constraints . . . . . . . . . . . . . . . . . . . . .\n\n46\n\nOptimal Golomb Rulers\n\n47\n\n4.3.1\n\n...........................\nRepresent at ions . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n47\n\n4.3.2\n\nResults . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n49\n\nRandom 3-SAT instances . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n56\n\n4.4.1\n\nRepresentations . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n56\n\n4.4.2\n\nResults . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n56\n\n..................................\n\n5s\n\nConclusions\n\n5 Conciusions\n\n5.1\n\nFuture Work. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\nA Availability\n\nBibliography\n\n59\n\n59\n\nChapter 1\nIntroduction\n1.1\n\nThe constraint satisfaction problem\n\nA Constraint Satisfaction Problem P is a tuple (V, D,C), where\nV is a set of variables\n\nD is a set of domains indexed by variable\n0\n\nC is a set of constraints, where each constraint is over a set of variables. denoted\nVarsOf(C).\n\nWe can assign to a variable V a value x from its domain, which we denote C. c x.\nAn assignment A is a set {& c r l , . . . , V;, t x,),\n\nsuch that C.; # V;. i # j. This\n\nmeans that no variable can be assigned more than one value. Mie define C'orsOf (A) to\n\nbe {K, ..., Vm}.\n\nA constraint C is a set of assignrnents to VarsOf(C). Each tuple that belongs to\nthe constraint is said to satisfy it. A constraint is fully instantiated by an assignment\n\nA if VarsOf(C) C VarsOf (A). Moreover A satifies C if the subset A' of A that has\nVarsOf (C) = VarsOf ( A ) satisfies\n,\nC.\n\nThe a r d y of a constra.int is 11 VarsOf(C)[l.The arity of a problem is the maximum\narity of its constraints. Therefore, a binary CSP is one that only has biuary or unary\nconstraints.\n\nOften binary CSPs are represented by a constraint graph. In it, vertices represent\nvariables of the CSP and edges represent constraints between variables. This representation has no information about the structure of the individual constraints, but it lends\nitself to an analysis of the problem using a graph theoretic approach. Yon-binary CSPs\ncan be represented using a hypergraph.\n\nA solution to a CSP is an assignrnent of values to al1 the variables. such that it\nsat isfies a11 constraints.\nThe sat isfiability problem is a speciai case of the couetraint satisfaction problern.\nwhere the domains of ail the variables are {O, 11, even though there are other ways to\nencode a SAT problem as a CSP [34,%].A polynomial translation can be performed from\n\nCSP to SAT, as well [34, 151. Therefore? the CSP is an NP complete problem. Hocvever.\nthere are instances of the problem that are solvable and useful. In fact. CSPs are widely\napplicable, as we will see in the next section.\n\n1.2\n\nApplications\n\n1.2.1\n\nOptimal Golomb Ruler\n\nA golornb ruler is a set of n numbers, called marks, such that the n(n - 1)/2 differences between every pair of them is unique. An optimal golornb ruler is one such that\nmax, - min, is minimal, where max,\n\nand min, are the maximum and minimum\n\nmarks, respectively.\nI t has been noted that finding an optimal golomb d e r is very hard [31]. even for\ns m d l numbers of marks. However, it has applications in many areas of engineering, such\nas wireless communications.\n\nThis probtem will be discussed in more detaif tater, when we wiH examine how it can\nbest be represented and solved as a CSP.\n\n1.2.2\n\nAssembly line sequencing\n\nThe problem of assembly line sequencing [BI involves finding a sequence that items will\nbe placed on an assembly lines, while not exceeding the capacity of various resources in\nthe line and a t the sarne tirne completing the sequence in the srnallest time possible.\nThis problem obviously has wide applications in rnanufacturing environment S. In\naddition, it is possible to come up with numerous variations on the basic problem. such\nas:\n\na Variety for the workers on the line, to maintain their interest and ski11 sets.\n\nLimitations can be set on the possible transitions between items. For example.\nfor a painting machine, an item that must be painted white should not be placed\nimmediately after one that should be painted red, so that it does not end up with\na pink color.\n\n1.2.3\n\nScheduling\n\nThe car sequencing problem is a special case of t he scheduling problem [IO], which involves\nassigning jobs to machines. There are many constraints that limit the possible solutions\nto this problem, including what kinds of jobs each machine can handle and in what\nsuccession, what jobs need to be completed and so on.\n\nIn addition, scheduling is a problem that can have a vast nurnber of solutions, al1\nacceptable given t h e constraints. However, only some of them may be desirable.\nTherefore, scheduling is suitable for the use of techniques in optimization, as well\nas hard and sofi constraints (hard constraints need to be satisfied for a solution to be\n\nreported, whereas soff constraints, when vioIated, increase a penalty value for the solution\nand the goal is to minimize the penalty [29]. )\n\n1.3 Research in CSPs\nResearch in the area of CSPs is very experimentally intensive. This is because there is\nusually no way to completely determine how a new algorithm or dynamic variable ordering heuristic will work wit hout actually trying it in real world problems. Moreover. the\nperformance characteristics of each algorithm can Vary widely between different problems. The best way to solve a given problem generally involves choosing a combination\nof algorit hm, heuristic and representation. The best representat ion for one algorit hm\nmay not be the best for another.\n\n1.3.1\n\nAlgorit hms and Heuristics\n\nAs will be discussed in chapter 2, there are many different approaches to solving CSPs.\nThe main aspects that affect the efficiency of solving a CSP. given a specific representation, are\n\n0\n\nThe choice of algorithm\n\n0\n\nThe heuristic for choosing which assignment to make next.\n\nEven though theoretical comparisons of algorithms and heuristics are possible. the\nactual performance of an algorit hm is a function of the tradeoffs t hat it rnakes and how\neffective they are for a given problem. In chapter 2, we will discuss these tradeoffs and\n\nexamine how they affect performance.\n\nBy far the most challenging aspect of CSPs is coming up with an efficient representation\nto solve a CSP. These are the most important features of a representation:\na\n\nNumber of variables\n\na\n\nSize of domains\n\na\n\nUniformity of domain sizes\n\na\n\nNumber of constraints\n\na\n\nArity of constraints\n\na\n\nDistribution of constraints in the constraint graph\n\nO\n\nPruning strength of constraints\n\nAl1 the above characteristics influence the effectiveness of a representation. Moreover,\nwe have to balance other characteristics, depending on the algorithm used. For example.\n\nintelligent backtracking algorithms can deduce better backjumps with certain type of\nconstraints. Also, we may be able to do more efficient constraint propagation by taking\nadvantage of domain knowledge. Finally, adding redundant constraints, although it\nincreases the cost of consistency checks, can prove beneficial by enabling the constraint\npropagation algorit hms to perform more pruning.\nConsider the example of the n-queens problem [23]. One possible representation is to\nrepresent each square with a variable whose domain is {O, 11, which means that there is\nor there is not a queen in that square, respectively. In addition, there will be a constraint\nbetween every pair of variables, that only allows a queen to be placed in both squares if\nthey do not \"see\" each other. So, for the Cqueens problem, there will be 16 variables\n\nand 120 binary constraints. In ot her words, t his represent at ion needs 0 ( n 2 )miables\nand 0 ( n 4 )constraints.\n\nOn the other hand, me cm represent the probkm using one variable for each cotumn\nof the chess board. The domain of each variable will be { 1 . .. n), representing the row\nwhere a queen will be placed on that column. We also post a constraint between every\ntwo variables, which will be true if the placement of the queens in the corresponding\ncolumns is such that they do not -seeu each other. In other words, we use O(n j variables\nand O (n2) const raints. This representat ion uses much fewer variables and const raints,\n\nby taking advantage of the knowledge that there can be only one queen at each column\nof the board.\n\nOne common benchmark problem, t hat is much more difficult and realistic t hat the\nn-queens problern discussed above, is the Optimal Golomb Ruler problem. Smith et\n\nal. [31] study various represeritations and find that a good representation is one that\nhas 0 ( m 2 )variables, instead of O ( m ) ,but uses a more efficient constraint propagation\n\nalgorit hm. It also uses ternary constraints and one constraint of very !arge arity. whereas\nthe original representat ion uses quaternary const raints. A t heoretical cornparison showed\nthat either representation used could, in different situations, be better t han the ot her.\nTheir empirical results, however, show t hat the representation with ternary constraints\nwas consistently much better. Moreover, this paper shows that, contrary to comrnon\n\npractice, t h e Brélaz variable ordering heuristic actually performs worse than a static\n\nlexicographie heuristic for this problem. We will discuss these results again in chapter 4.\n\n1.4\n\nContributions\n\nIt becomes clear that research in the field of CSPs is heavily dependent on access t o an\nexperimental tool. However, there is a wide array of available algorithms, heuristics, as\n\nwell as transformations that can be done o n a model, so that it is not obvious how t o\nimplement them al1 in a consistent and extensible way.\n\nIn this thesis, we present a consistent view of existing dgorithms and heuristics in\n\nchapter 2, examine s\n\nd aspects of buitding a CSP soiver t o accommodate these and\n\naddress them al1 in a generic way in chapter 3. We then demonstrate the feasibility of\nusing this solver to solve some common benchmark problems, in chapter 4.\n\nThe purpose of this work is to provide a framework for supporting the empirical\ninvestigations required to do research in this area.\n\nChapter 2\nPrevious Work\nBacktracking\nOne way t o generate al1 solutions for a CSP is to generate al1 the possible sets of assignments and discard those that fail to satisfy al1 the coostraints.\nThe idea behind backtracking [SI is that instead of generating an assignment to the\nvariables and then checking it, we can check it as we create it. .A backtracking algorithm\nassigns a value t o a variable, then tries to assign another variable and so on. With each\nassignment that it makes, it makes sure that ail the fully instantiated constraints are\nsatisfied. It continues until there are no more variables left, in which case it has found a\nsolution, or a constraint that has been falsified. In the first case it reports the solution\nfound and continues as if it had failed. In the second case, it tries another value for the\ncurrent variable. When al1 values in the variable's domain are exhausted, i t tries the next\nvalue for the previous variable. The search is over when al1 values of the first variable\nhave been exhausted.\nChecking sets of assignments as we build them can Save an exponential amount of tirne\n\nin solving the problem. Consider the case of a problem with n variables, ail of which have\nthe same domain size d. Consider, furt her, that the backtracking algorithm instantiates\n\nk variabtes when it Ends that this partial assignrnent falsifies some constraint. ft witt now\nbacktrack, trying other values for the k variables that it has instantiated. The number\nof assignments that it has avoided considering is (n - k ) d .\nBacktracking can be seen as a search in a tree, where each node is a partial assignment\nand its children are nodes whose corresponding assignment is the same except th-\n\nhave\n\none more assigned variable. The leafs of the tree are complete assignments or assignrnents\nthat fail to falsify some constraint.\n\nSeen this way, the benefit of backtracking over generate-and-test is that it reduces\nthe size of the explored search tree by avoiding searching sorne subtrees t hat contain no\nsolut ion. These subtrees can be of exponential size.\n\nConstraint Propagation\n2.2.1\n\nLocal consistency\n\nUsing any of the algorithms that we will discuss later, the tirne t hat it takes to find a\nsolution for a CSP depends on the size of the search tree. which is? in the worst case, the\nsize of the product of the domains of al1 the variables in the problem. CVe can reduce the\nsize of the search tree by examining the constraints individually and pruning values that\nare locally inconsistent .\nLocal inconsistency is the inverse of local consistency. We will consider the following\nthree types of local consistency.\n\n0\n\nNode consistency\n\nA problem is node consistent when al1 the values in the domains of its variables\nsatisfy d unary constraints.\na\n\n.4rc consistency [19]\n\nA vdue is arc consistent for a binary constraint when there is a satisfying set of\nassignments to the variables of the constraint that contains t his value. A constraint\nis said to be arc-consistent when al1 of the vaLues of its variables are arc-consistent.\n\nA problern is arc-consistent when al1 its binary const raints are arc-consistent .\nO\n\nGeneralized arc consistency (201\n\nA value is arc consistent for a constraint when there is a satisfying set of assignments\nto the variables of the constraint t hat contains this value. A constraint is said to be\narc-consistent when al1 of the values of its variables are arc-consistent. A problem\nis arc-consistent when al1 its constraints are arc-consistent .\nWhen enforcing these forms of local consistency, we find inconsistent values and prune\nthern.\nNode consistency is easier to implement ,as we only have to consider unary const raints.\nTherefore, finding node inconsistent values has time complexi ty only O(d) for the domain\nof one variable, where d is the size of the variable's domain. Since arc consistency (AC)\n\ndeals with binary constraints, it has to examine d2 pairs of values, therefore its complexity\nis O(&).Similarly, generalized arc consistency (GAC) has complexity O ( d k ) ,where k is\nthe arity of the constraint being checked.\nOn the other hand, since node consistency only considers unary constraints, it can\ngenerate lit t le, if any. pruning. AC considers binary constraints. while G AC considers\nall constraints. Each is more powerful and can generate more prunings.\nAnother thing to note is that AC and GAC have cascading effects. This rneans\nthat when a value is pruned from the domain of one variable, aII the constraints in\nwhich this variable participates must be reexunined for AC (or GAC). Consider three\nvariables VI, b,\n\nwith domains {l,2,3) and constraints ClV2= {{1,2), (2,311 and\n\nCzv3= {{2,3)). Enforcing AC on ClS2will prune Vi t 3 and L$ t 1. Similarly making\n\nCZJ arc consistent will prune 1/2 + 1, & t 3 and L$\n\nt 1,113 c 2.\n\nIf, however, we\n\nenforce AC on both of them, pruning & + 3 wiII force reexamination of\n\nand that\n\nwill cause VI t 2 to be pruned as well.\nWhat we see is a trade-off between processing time for enforcing different types of\nlocal consistency and how much pruning (therefore reduction in the size of the search\ntree) t hey achieve.\nCVe can further reduce the size of the search subtree below the current node by enforcing some form of local consistency at each node [14, %].\nWhen w e make an assignment, we effectively reduce the arity of al1 constraints that\nthis variable participates in by 1. The new constraints are satisfied by the subset of\ntuples from the original constraints that contain the value we just assigned. This means\nthat each assignment can potentially generate new binary and unary constraints, so that\nwe can apply NC and AC on the subproblem.\n\nThe above techniques allow us to view enforcing local consistency as a dynamic procedure rather than a static one that only occurs before we start solving the problem,\ntherefore enabling us to reduce the size of the search subtree lurther at each node that\nwe visit.\nSimilarly, when we make an assignment, it can be viewed as reducing its current domain to a singleton domain. This means that the rest of its values get pruned. Therefore.\nrve now have a set of prunings that GAC can propagate.\nNote, however, that when a constraint propagation algorithm prunes a variable, it has\ndone so because it has discovered a reason for its pruning. Therefore, when this reason no\nlonger exists, these values should be restored to the domain of its variable. That reason\ncan be cornplex, but invariably contains the assignment that was made when that value\nwas pruned. Therefore, we introduce the notion of the prune letle1 of a value. When\n\nthe assignment made at level I causes a value to be pruned, its prune level is set to i.\nWhen the algorithm backtracks aad undoes the assignment made at 1, al1 values that\nnere pruned to level 1, are restored to their original domains.\n\nOn the other hand, constraint propagation at each node can rnean that we end up\ndoing more work than is necessary. This can happen when a constraint propagation\nalgorithm prunes the dornain of a variable that is never assigned in the subtree below.\n\nIn this case, al1 the checks that were made to prune the domain of this variable were\nwasted.\n\n2.2.2\n\nForward Checking (FC)\n\nForward checking [17] is an algorithm that tries to enforce node consistency at each node\n\nthat it visits.\nAfter it makes an assignment\n\nt x, it goes over a11 the constraints C in which i(\n\nparticipates that only have one uninstantiated variable left (after the assignment\n\nt x).\n\nFor every =lue y of the unassigned variable V,, it takes the current assignment A and\nchecks the constraint against the assignment A u V, t y. If the check fails, the value y\nis pruned from the dornain of V,.\n\n2.2.3 Maintaining Generalized Arc Consistency(MGAC)\nMGAC [19]does exactly what its name implies: it enforces generalized arc consistency\nat each node ?-kited by the search procedure.\n\nTo enforce GAC on a constraint, the algorithm goes over al1 the variables participating\nin this constraint. For every value of each variable, it checks to see that there is a tuple\nthat contains t his value and satisfies the constraint. This is called a supporting tuple for\nthe value, or simply support. If there is no supporting tuple for a valueo it gets pruned\nfrom the domain of its variable.\nTo keep the problem GA consistent, the algorithm has to go over al1 the constraints\nat least once. When it prunes a value, however, it can mean that another value has lost\nits supporting tuple. So, it has to make sure again t hat al1 the values t hat may have had\nsupport on it still have some support, otherwise they must be pruned.\n\nA naive way to do that woufd be to go through al1 the constraints and ensure that\neach value in every ciornain has a supporting tuple and repeat t h e process until no more\n\nvalues get pruned. This method is called AC-O.\nA significantly better way to do that is to rnaintain a queue of pairs < C ' V >.\nInitially, al1 such pairs are inserted into the queue. The algorithm repeatedly removes\npairs from the queue and checks the GA consistency of the values of V with respect\nto C. Whenever a value gets pruned from the domain V, al1 < C f , Vf > pairs such\nthat C r # C, V t E VarsOf(Cf) and V t # V are inserted into the queue if they are not\nalready there. This way, if a value x of variable V gets pruned and it is possibly part of\na supporting tuple for value x' of variable V', al1 values of Vf are going to be reexamined\nfor al1 constraints that constrain both V and V t . This method, called AC-3 [19] enforces\n\nGAC much faster than AC-O.\nIt should be noted that other structures can be used instead of the queue, such as a\nstack or a priority queue. That is, the algorithm does not depend on the FIFO property\n\nof the queue.\nThere are even better ways to keep track of supporting tuples and further improve\n\nAC-3. AC-4 [22] has been proposed and has been proven to be optimal in time cornplexity.\nVariations u p to AC-7 have also been proposed (AC-5 [18], AC-6 [4], AC-; [SI, lazy AC7 [30])but they only improve the running time hy a constant factor and have a significant\nspace cornplexity.\n\n2.2.4\n\nMaintainhg Arc Consistency (MAC)\n\nMAC [19] is just a specid case of MGAC, where only constraints that have two uninstantiated variables left are inserted into the queue.\n\nIntelligent Backtracking\n\n2.3\n\nWhereas constraint propagation tries to reduce the size of the search tree, intelligent\nbacktracking tries to reduce the size of the esplored search tree. That is, it tries to\nreduce the number of nodes that it actually visits, even though it does not necessarily\nprune any values.\nAn intelligent backtracking algorithm tries to discover a reason why the current subtree fails to contain a solution. The search can then backtrack far enough to invalidate\nthis reason. To understand how this can be accomplished, we introduce the concept of\nnogoods.\n\nA nogood is a set of assignments that is not part of any solution. Note that any\nsuperset of a nogood is also a nogood.\nThere are an exponential number of nogoods that an algorithm can learn. The a l g e\nrithms that we discuss associate each assignment with the level of the search tree where\nit was made.\n\nThe nogoods that they learn are then represented as sets of levels. This\n\nrepresentation restricts the set of nogoods that are learned to subsets of the current\nassignment .\n\nIn fact, these algorithms learn two kinds of nogoods:\n0\n\nA nogood t hat directly violates a constraint .\nThese are encountered whenever the search finds a value t hat violates a constraint.\n\nThey consist of al1 the assignrnents made to variables that belong to the constraint\nthat was violated.\n0\n\nA nogood t hat results from the unioning of ot her nogoods.\n\nWe will discuss the following two types of unioning nogoods\n\n- Unioning nogoods that cover the domain of a variable. When we have a set of\nnogoods that cover the domain of a variable V, we can union these nogoods\n\nminus the assignments to V and get a new nogood.\nIn other words, when we exhaust the domain of V and discover a reason for\neach of its values to not be a part of any solution, the union of the nogoods\ndiscovered presents a reason why the rest of the assignments made so far\ncannot be extended to a solution. This is because a solution has to contain\na n assignment to every variable and we have found a reason why there exists\nno solution that extends the current assignment with an assignment to V.\n\n- Constraint-filtered unioning. When we have a constraint CvIv2and a set of\nnogoods that cover the support (as defined for GAC) of & t x on V2,we can\nget a new good from the union of these nogoods minus the assignments to \\$\nplus 6 t x. If, for example, the supports of V, c r on 1/2 are\n\nt y1 and\n\nV2 + y*, and we have discovered the nogoods\n\nthen w e learn the nogood\n\nhtuitively, this means that if we have discovered a reason why the current\nset of assignments cannot be extended to a solution that contains the set of\nsupports of\n\nt x on 112, then this is also a reason why t h e current set of\n\nassignments cannot be extended to a solution that contains k; t x. This can\nbe explained by noting that any solution that contains C.; t x also has to\ncontain its support ing values.\n\nA conflict set for a value x of a variable V is a set of assignrnents A, such that\nA U {V t r ) is a nogood.\nWe can also add pruning to an algorithm that maintains conflict sets. Whenever we\ndiscover a conflict set for V i- x, we can prune that value to the deepest level where\n\na n assignment of the conflict set was made. In other words, when the search discovers\n\na conflict set C F for V t x' it means that C F U { V e x) is a nogood. As long as all\nthe reasons for this being a nogood are valid, the algorit hm does not need to try this\nassignment, since it wiil fail. Therefore, x can be pruned from the domain of V and\nremain pruned until at least one of the assignments in CF is undone. This tvill occur at\nlevel rnax(levelo/(V')), V' E C F ; and this will be the prune level of x.\n\nBJ [141 maintains one conflict set for each variable.\nWhen it attempts to assign a value to a variable, it finds the earliest level 1 that this\nassignment becomes inconsistent. The conflict set that i t discovers at t his point consists\n\nof ail the assignments at level 1 and above in the tree. Since the structure of al1 the\nconflict sets is always the same (al1 the levels from 1 to l ) , it simply stores 1.\nAs a n example, consider that BJ tries to make the assignment V t x, but this\n\n~ Ci;,v, ,v.while mriables\nassignment fully instant iates and violates coostraints Cv,J , , and\nVI, V2,V3, CS are instantiated a t level 1, 2, 3 and 4 respectively. In this case, the earliest\npoint where the assignment to V is inconsistent with the prior assignments is 3, therefore\n\nthe conflict set BJ discovers for V c x consists of the assignment at levels {1.2,3).\nThe conflict set for a variable is t h e maximum level 1 discovered for al1 of its values.\n\nBJ can jump back t o 1 when it exhausts the domain of that variable.\nSuppose that, in the above example, BJ tries a11 values in the domain of V and finds\n\nt hat i is the level it should jump back to. By doing this, it has discovered a new set of\nnogoods of the form:\n\nwhere b$ is the variable that has been assigned at level i.\nBy unioning these nogoods, since they cover the domain of V . it gets a new nogood\n\nTherefore, the new conflict set for L$ t X I is the one that consists of al1 the âssignments made at Ievels I . . .1 - 1.\nThis rneans that BJ is only able to jump back only once. To jump back further? it\nfirst has to explore another subtree. In other words, it can only jump back from leafs.\nnot from interna1 nodes of the tree.\n\n2.3.2\n\nConflict directed Backjumping(CBJ)\n\nCBJ [24] improves on BJ by learning better nogoods. Instead of learning a nogood that\nonly consists of al1 the assignments made at Ievels 1 . ..l, it takes advantage of the specific\ninformation provided by a failed coustra.int. Specifically, when the assignrnent I.*t x\nfails to satisfy a coostra.int Cvkl,...,vkm,v,the conflict set that CBJ learns for x consists of\nthe assignments made t o the variables Vk,,.. . ,Vkm. This conflict set is unioned into the\nconflict set for the entire variable.\nAfter iterating over the entire domain of the variable, the conflict set discovered for\nthe variabIe is the union of the c o d i c t sets for dl its values. In other words, it is the\n\nunion of a set of nogoods that cover its domain, minus the assigoments to this variable.\nTherefore, this conflict set is itself a new nogood.\n\nCBJ can now jump back to the deepest level where an assignment in the conflict set\nof the variable was made. It is safe to do so, because as long as none of the assignments\nin the nogood are undone, t here is no solution.\n\nThe nogood discovered minus the assignment at the level CBJ jumps back to is a\nconflict set for the assignment made at that level. Therefore, this conflict set can be\nunioned into the conflict set for the variable a t the jurnpback level.\nBecause CBJ maintains finer-grained conflict sets than BJ. it is possible for it to jump\nback not only from leafs, but also from interna1 nodes.\nFor example, suppose that variables Vil b,\n\nhave been instantiated at levels 1,\n\n2, 3 and 5 , respectively. Further, the algorithm has reached level 10, where i t instantiates\nvariable V wit h domain {a, 6 ) . The assignment V t a violates the constraint Cr;,v,,v5,~.\nwhile the assignment V t b violates the constraint Cv,,v,,v5,v.The conflict set for V t a\nwill be {1,2,5) and the one for V t b will be {%,3,5). The conflict set for V is the\nunion of these, which is { 1,2.3,5} and t herefore CBJ jumps back to level 5 and sets the\ntentative conflict set for & to {1,2,3}. Now, the algorithm assigns other values to 1.;.\nSuppose that the other nogoods that it finds for\n\nare subsets of its current conflict\n\nset, therefore the conflict set after CBJ exhausts K's domain is still {1.2,3). Now it\nwili jump back to tevel 3. In contrast, BJ would aiso jump back to Ievei 5. but it would\nthen only be able to step back to level4. CBJ is able to jump further back because it\nmaintains more detailed conflict sets than BJ.\n\n2.3.3\n\nValue specific Confiict directed Backjumping (vsCBJ)\n\nvsCBJ [Il improves upon CBJ by maintaining a conflict set for each mlue of a variable.\nWhen it discovers a conflict set for a value, it simply keeps it for this value and does\nnot union it into a single conflict set for the variable.\n\nThis aIIows it to take advantage of constraint-fiItered unioning of nogoods to discover\nmore powerful nogoods on backtrack. It produces the constraint-filtered nogood for the\nvalue assigned to the variable at the jumpback level, using either a constraint between\nthe current variable and the jumpback variable or the universat constraint. It can also\nuse a constraint which has al1 of its variables, except the two in question, assigned at\nlevels above the jumpback level.\nAs an example. consider the case of a CSP, where the assignment V t x is made\nat level f i , V' +- t' is made at level II > f i and at level l3 > i2, the domain {a. 6, c ) of\nvariable V\" is exhausted, without finding a solution in the subtrees. kloreover. t h e solver\ndetermines that it is safe t o jump back to level 12. Using CBJ, it will now set the conflict\nset of V' t x' to be the union of the conflict sets for V +- a, V t 6, V t c. Consider\nhowever, if there is a constraint Cv,vI,p and the tuple {V t x, C.' t x'. V\" t c) does\nnot satisfy it. This means that as long as there exists a reason for V\" t a and V\" t b\nto be inalid and the assignrnent V + x is not reverted, the assignment V' t x' will\nalso be invalid, regardless of the status of V\" t c. In other words. the conflict set for\n\nV' t x' can b e set to be union of the nogoods of the values of variable V\". filtered by\nthe constraint Cv,vt,vlc\n\n2.4\n\nCombining Constraint Propagation with Intelli-\n\ngent Backtracking\nConstraint propagation and intelligent backtracking utilize two different techniques to\nspeed up the seuch. Constraint propagation tries to reduce the size of the search tree\nbelow the current node, while intelligent backtracking tries to reduce the size of the\nexplored t ree.\n\nWe can combine the two approaches to achieve even greater speed ups. Intenigent\nbacktracking algorithms discover nogoods for values in two points in the search:\na When checking that the current assignrnent is consistent\na When backtracking\n\nConstraint propagation discovers nogoods only when enforcing some form of local\nconsistency after making an assignment. The nogood that it discovers for the values that\nit prunes consists only of the level at which they were pruned. In other words, it is the\nsame type of nogood that BJ discovers: one that consists of al1 the assignrnents made\nuntil the current level. CVe can apply the same reasoning as we did for BJ and improve\n\nFC and GAC first to FCCBJ and GACCBJ and then to CFFC and CFGAC.\n\n2.4.1\n\nFCCBJ, GACCBJ\n\nFCCBJ [24] and GACCBJ [25] perform the same kind of pruning as FC and GAC. The\nonly difference is that when they prune a value From the domain of a variable, they use\nthe constraint that caused the pruning to generate a conflict set for that value and union\nit into the conflict set of the corresponding variable.\n\nFCCBJ can simply set the conflict set of the pruned value to be the set of assignments\nmade to the rest of the variables of the constraint that caused the pruning.\n\nWhen\n\ndoing GACCBJ, however, it is not as simple to know exactly what caused the pruning.\nTherefore, the c o d i c t set for the pruned value is set to be the set of assignments made\nto variables of the constraint being checked unioned with the conflict sets of the rest of\nthe pruned values in the variables of the constraint.\nT o demonstrate t his, consider enforcing GAC on the constraint Cv,,v,,v,. wit h al1 t hree\nvariables having the original domain {1,2,3), after having pruned & i\n,b and d + c\n\nand making the assignment Vi t 6. The constraint has the following satisfying tuples:\n\nAt this point, V2 t a should be pruned. Its conflict set h a to include. besides the conflict\nset derived from the previously assigned variables of the constraint , the conflict set for\n\nV, t a .\n\ne b and L$ i\nC. This is because if any of these values were not pruned,\n\n.\nia would still have support and would not be pruned.\n\nTherefore, the conflict set\n\nhas to include the reason for these prunings as well. In fact, it should be the union of\nthe conflict sets of the pruned values that appear at least once in any of its supporting\ntuples for the constraint Cv,,v,,v,. This knowledge, however, requires t ime exponent ial in\nthe arity of t be constraint to figure out.\n\n' Using the union of the conflict sets of the rest.\n\nof the pruned values in the variables of the constraint can produce less powerful conflict\nsets, but it is rnuch easier to compute.\nWhen the search reaches a leaf, i t rneans t hat it has reached a variable t hat has had\nits domain wiped out by pruning done at previous levels. It can then use the nogood\nt hat i t has learned t o jurnp back furt her than the previous level. *\nThese two algorithms propagate the nogoods that they have discovered to previous\nlevels in the same way as CBJ: by unioning them into the conflict set of the variable they\njump back to. This rneans that they are also able to jumpback from interna1 nodes.\n\nCFFC, CFGAC\nSimilar to FCCBJ and GACCBJ, CFFC and CFGAC [l] are versions of FC and GAG\nthat use constraint filtered unioning of nogoods.\n'Actudly, this knowledge is available when using GAC4, which explicitly stores al1 the supports for\nevery value. It still requires time exponential in the arity of the constraint to cornpute, however (albeit\noniy a t the beginning of the search) and aiso requires a lot of space, which can be Iimiting for larger\nCSPs*\n'Actually, the reason that a variable has had its domain wiped out has to contain the assignment\nmade at the previous [evel. Therefore, neither algorithm will jump back more than 1 level from a leaf.\nIt is possible, however, t o jump back more than 1 level from intemd nodes.\n\nThe nogoods that these aigorithms Iearn from constraint propagation are the same\nthat FCCBJ and GACCBJ learn. They differ only in the backtracking algorithrn, where\nthe CF versions perform const raint filtered unioning of the per-value nogoods.\n\n2.4.3\n\nA unifled view\n\nWe can now group the algorithms discussed according to the nogoods that t hey learn\nbecause of constraint propagation and during the search.\n.4n algorithm can learn these types of nogoods because OF constraint propagation:\n\nNogoods from forward checking\nNogoods from enforciog GAC\n\nSimilarly, it can learn these types of nogoods during search\n\nO\n\nBJ-style nogoods (1 . ..1 )\n\nO\n\nNogoods resulting from the union of a set of nogoods covering the domain of variable\n\nr Const raint filtered unioning of nogoods\n\nThis way, we can create a grouping of the algorithms as shown in figure 2.1.\nEach problem might produce more powerful nogoods in only one of the dimensions.\n\nIt is worthwhile to explore different ways of solving it by trying t o do more work in one\nof t hese dimensions or balancing t hem.\n3So much so, that the pruning routines used in the implementation discussed in chapter 3 are the\nsame for FCCBJ and CFFC and for GACCBJ and CFGAC.\n\nFigure 2.1 CTassificatioa of algorithm by Ievel of nogoods learned\nNogoods from search\n\n2.5\n\nNogoods from constraint propagation\n\nBJ\n\nCBJ\n\nvsCBJ\n\nNone\n\nBJ\n\nCBJ\n\nvsCBJ\n\nFC\n\nFC\n\nFCCBJ\n\nCFFC\n\nGAC\n\nGAC GACCBJ CFGAC\n\nHeuristics\n\nThe backtracking algorithms discussed in previous sections al1 center around the notion\nof exploring a search tree and using techniques to minimize its size.\n\nOne factor that affects the size of the search tree and tiiat these algorithms do not\naddress is the order in which the variables of the problern are instantiated. The only\nconstraints that they place on which variable should be instantiated next are\nO\n\nIf a variable has had its domain wiped out, it should be selected next for instantiation. When a domain is wiped out, it means that no solution can exist in the\nsubtree below the current node. Therefore, there is no reason to search it anymore.\nIn addition, we need to select the wiped out variable for the next level, so that an\nappropriate jumpback level can be computed.\n\n0\n\nIf a variable has been reduced to a singleton variable, it should be instantiated\nnext. This is just an o p t i m i ~ a t i o n . ~\n\nBy finding a better order in which variables are instantiated the algorithm can Save\nan exponential amount of time in learning some nogoods.\n\nThere are two main strategies for selecting the next variable. We can either use a\nstatic ordering or a dynamic ordering.\n41t can however be critical to the performance of the algorithm, like in [Il].\n\nThe static ordering can resuit from processing the probiem before the search has\nbegun.\n\nA dynarnic ordering, on the other hand, examines the state of the problem each\ntime if tries to instantiate a new variable and then uses a heuristic to select which one to\ninstantiate. Using a dynamic variable ordering can have dramatic effects on the efficiency\nof problem solving.\n\nMinimum Remaining Values The most commonly used heuristic is currently the\n\"minimum remaining va,luesWheuristic, or dom [ l i ] . Aside from the constraints mentioned\nearlier, the variable it chooses to instantiate next is the one with the srnailest remaining\ndornain size. This heuristic attempts to minimize the size of the search tree below the\ncurrent node.\nMoreover, we hope that by instantiating variables with smaller domain sizes. ive can\ncause more pruning when using a constraint propagation algorit hm.\n\nMinimum Remaining Values with tie-breaking by degree The drawback of dom\nis that it treats the constraint hypergraph as a complete graph. This means that in a\nsparse graph, the next variable will be chosen arbitrarily among those that have an equal\n(minimum) domain size, with no regard to the connectivity of the variable. This is not\ndesirable, because even though two variables c m have the same domain size, when one\nof them is more constrained that the other, it can potentially cause much more pruning\nwhen we make an assignment to it.\nTherefore, we can create a new heuristic, MRV with tie breaking by degree, or\ndom+deg [9]. The degree of a variable is number of active constraints (i.e. constraints that\n\nhave not yet been fuily instantiated) on that variable. MRV with tie breaking chooses\nthe next variable among those with minimum dornain size and among t hose and selects\nthe one with maximum degree.\n\nMaximum degree CVhen the constraint graph is sparse, the size of the variables'\ndomains can be less important than their degree in choosing the next variable. So, we\nc m use the heuristic deg [12] for such CSPs.\n\nRatio of domain size over degree Bessière and Régin [7] have observed that depending on how constrained a CSP is, di fferent heurist ics perform opt imally. Speci fically,\nwhen the constraint graph (or hypergraph) is sparse (small number of constraints), the\nheuristic deg perlorms better than either dom or dom+deg. On the other hand, when the\nconstraint graph is dense, dom and dom+deg perform better.\nThey proposed that a better heuristic to use would be dom/deg, where the variable\nchosen for instantiation next would be the one with the minimum ratio domainsize/degree.\nIn experiments they performed, using ranclom CSPs,dom/deg perforrned at least as\nwell as either of the other heuristics, but never significantly better than the second best.\nThis indicates that although this heuristic does not produce better results that what was\npossible with the other heuristics, it does provide a way to get the best results without\nhaving to make a choice.\nIt should be noted, however, that their results only apply to randomly generated\n\nCSPs. They may not be applicable to other classes of problems.\n\n2.5.1\n\nWhy heuristics work (or not)\n\nThe reason why each heuristic works for a specific problem has not been determined. It\nhas been suggested that the reason that dom in particular works is that it tries to fail in\n\nhigher levels of the seatch tree. It has been proven, however, t hat t his is not the case [33],\nas heuristics that try to fail early generate search trees with many branches, which slow\n\ndown the search.\nInstead, it seems that a heuristic should try to achieve a balance between failing early\n\nand generating trees wit h few branches. How to rneasure the difference and est imate the\n\nqudity of a heuristic without actualty sotving the probiem is a problem that has not been\n\naddressed yet .\n\nFinally, it should be noted that finding the optimal variable ordering for a problem\nis itself an NP-hard problem, therefore the closest we can get is using heuristic approximations (321.\n\nChapter 3\n\nImplementation\n3.1\n\nBasic Infrastructure\n\nAl1 algorithms discussed in the previous chapter can be viewed as specializations of the\nalgorit hm in figure 3.1.\nThis is a recursive algorit hm. It is called by the user prograrn for level 1. In line 2, i t\ngoes through al1 the uninstantiated variables and uses a heuristic to choose one.\nIn line 3, it checks if no uninstantiated variables remain. in which case it has found a\nsolution, which it processes in line 4.\nIn lines 6-17, it tries to assign each value in the current domain of the selected variable\nand thcn recursively calls itself for the next level. This reqcires going through al1 the\nunpruned values of the current variable and assigning t hem to it .\n\nIn line 7 it makes the assignment. In line S it makes sure that this assignment is\nconsistent with the rest of the assignments made so Far. In effect , it has to go through al1\nthe constraints in which this variable participates. For each constraint that has become\n\nfully instantiated, it checks that it is satisfied.\nIf the assignment is consistent, then it does any constraint propagation needed in line\n\n9. Constraint propagation generally has to go over dl the constraints t hat the variable\n\nFigure 3.1 An abstraction of the atgorithms discussed\nAlgorithm genericBT(leve1)\n\nV\n\nChoose next variable\n\nif no variables l e f t then\ns o l u t ion f ound\n\nendif\nfor each value\n\nu\n\nmake assignment\n\ni n the domain of\n\nI/'\n\nVt v\n\nif assignment i s c o n s i s t e n t then\ndo constraint propagation\nbackt rackleuel = genericBT(leve1 + 1)\n\nundo current assignment\n\nif\n\nbacktracklevel\n\n< leuel then\n\nreturn backt rackleuel\nendif\nendif\nendfor\nunselect( V\n\n)\n\nbacktracklevel = computebacktrackleve1(~ewe~)\nupdateconf lictsets,atletreïs(backtrackleuel, level - 1)\nreturn backt rackleucl\n22 end genericBT\n\nparticipates in. For each constraint. it goes over the current domain of future variables\nand determines which values no longer have support on the domains of the rest of the\nvariables. Forward checking will only do t his for constraints wi t h only one uninstant iated\nvariable, while GAC will do that for al1 constraints and will cascade any removals.\n\nOnly after t hese steps does the algorit hm call itself recursively in line 10. The recursive\n\ncall will either return the current level to indicate that the search should continue in this\nlevel or something less than level t o either signal a jump back or temination of the\nsearch (when backtracklevel == 0 ) .\nUndoing the current assignment in line 11 means that the values that have been\npruned because of it need to be restored to their original domains. Therefore? the dg*\n\nrithm aiso needs to keep track of which vahes have been pruned at each LeveI.\nLines 19-20 use the nogoods discovered during search to determine to what level the\nprogram should jump back to and t o update the conflict sets of the d u e s assigned\nt o variables at intermediate levels. This involves determining the maximum level in a\nconflict set (Iine 19) and unioning the conflict sets of values at the current level and levels\nbetween the current and the jumpback level.\nNote that the actual implementation of some parts of this abstract algorithm (lines\n\n8, 9, 19 and 20) may be empty for some of the algorithrns. For example, the FC and\n\nGAC variants only have consistent values in the current domains of Future variables and\ntherefore do not need to do any consistency checks. Similarly, algorithms that do not\nmaintain conflict sets - and t herefore only step back, as opposed to jumping back - do\nnot need to do anything for lines 19 and 20, other than:\nbackt rackleuel = level\n\n-1\n\nreturn backtrackleuel\n\nTo implement these algorithms we want to provide representations for each of the\nfollowing problem elements. as well as methods for manipulating those:\n\na Variables\n\na\n\nVariable domains\n\na Confiict sets\n\na Constraints of arbitrary arity.\n\nMoreover, we will discuss other aspects of the algorithms that need t o be provided\n\nfor by our implementat ion.\n\n3.1.1\n\nVariables\n\nVariables are objects of ciass Var. Each object contains information about the variable's\ncurrent domain size and degree, as well as the values in its initial and current domain.\nThey also contain information about the membership of t his variable in the const raints\nof the problem. Internally, the variable objects are identified by a numeric id. In the\ngraph coloring problem, for enample, each vertex would correspond to a variable. but\nwould be referenced by its id.\nT h e framework maintains a global array of such objects, called thevars. This allows\nconstant t ime access to the variables by indexing.\nIn addition, there is an array of uninstantiated variables, which is initialized to contain al1 the variables before the solver begins. This array allows us to iterate over the\nuninstantiated variables only, instead of iterating over al1 of t hem and skipping those\nthat are already instantiated. This can Save time. especially at deeper levels of the tree.\nThe relevant methods for the above manipulation are provided by the methods\n\nSolver: :selectNxtVar (which corresponds to line 2 of figure 3.1) and unselectvar\n(line 13 of figure 3.1).\n\nVariable domains\nThe generic algorithm discussed earlier deals with variable domains in the following ways:\n\nIt iterates over dl the values of a variable, when manipulating conflict sets (line\n16).\n0\n\nIt iterates over al1 the unpruned values of the variable (lines 513). It is preferable\n\nif it does this without having to go through and discard those that are pruned.\na The pnuiing routines (line 8) need to remove values from anywhere on the list of\n\nunpruned values in constant time.\n\nO\n\nThe backtracking part of the aIgorithrn (line IO) needs to add values back to their\n\nWe use an object of c ï a s s Val to represent a value of a variable.\nInternally, d u e s are identified by their numeric id. The user part of the program is\nresponsible for treating the numeric id as the corresponding value in the problem domain.\n\nA value object also knows whether it has been pruned and at what I~vel,what its\nconflict set is and what its variabIe is,\nFor each variable, its values are kept in an array indexed by value id. which is simply\nits numeric value. In addition, each object in the array contains next and prev pointers\nto link these objects in a list, as shown in figure 3.2. Only unpruned values remain in\nthis iist. This dual structure is used to faciIitate the types of access that the algorithms\nneed over the domain of a variable, as mentioned above.\n\nFigure 3.2 Storing the values in a variable's domain\n\nVax\n\nvals\n\n0\n\n1\n\n2\n\n3\n\n4\n\nhdval s\n\nIn addition, pruned values are kept in lists, one per level. This is to facilitate adding\nthem back to their domains, ivhen we undo the assignments that pruned them.\nAccess to the unpruned values of a variable v is provided by the container ValListOfVar(v).\nAllValListOfVar(v).\n\nSimilarly, the array of al1 values is accessed using\n\nValues get pruned using the method Undo : :removeVaI(val, I e v e l ) , which removes\nv a l from the domain of its variable and places it on the pruned values list for that level.\n\nWhen backtracking, the met hod Undo : :restoreVals(leve1) restores al1 the variables pruned a t a l e v e i to their original domains.\n\nConflict sets\n\nWe also maintain conflict sets for each value. This is used by the intel-\n\nligent backtracking algorit hms.\n\n'\n\nT h e following operations are performed on conflict sets: deriving a conflict set from\na constraint (lines 7,s); unioning two conflict sets during backtracking (line L6); and\nfiguring out the maximuni level that an assignment in a conflict set was made (line 15).\nThese conflict sets are maintained as sorted linked lists of ranges of levels. Each node\nof this list is a class C f c e l i . It has members h i and 10. So, the conflict set 1.2,4,5,6,9\nwould be represented as a list of 3 nodes: [1,2] ,[4,6],[9,9]. Lists of this type can be easily\nmerged, in linear time. Moreover, we can easily figure out the jumpback level for an\nintelligent backtracking algorithm, by examining the h i member of the last node of the\nlist. To make this operation constant tirne, we also store a pointer to t h e last node of\nthe list.\nThis class, besides the data members t hat it keeps, also provides convenience met hods\nthat perform unioning or constraint filtered unioning of the conflict sets.\n\n3.1.2\n\nConstraints\n\nConceptually, a constraint C over k variables is simply a set of tuples of length k. such\nthat each tuple is an assignment to the k variables constrained by C. Each tuple is an\n'We do not maintain a conflict set for the variables, despite the fact that they are needed by the\naigorïthms that learn CBJ-style nogoods during search. This is because the conffict set for the variable\nis implicitly the union of the conflict sets of ail its values. We do not suffer a loss of efficiency for not\nmaintaining a conflict set for a variable, because either way the dgorithm learns conflict sets for a value\nand unions them into the variable's conflict set. There is only a space inefficiency, which cannot be\navoided, since we also irnplement algorithms that Iearn value specific nogoods.\n\nassignrnent that satisfies C. T h e size of the set can be exponential in k. Therelore, the\nonly useful operations that CM be performed with a constraint are:\na query it on whether it constrains a variable\na given an assignment to the variables it constrains. find out whether it satisfies the\n\nconstraint .\nT h e first item can further be refined to checking whet her a single variable is constrained and whether a pair of variables is constrained.\n\nIn general, constraints are accessed in loops of the following form:\nAlgorithm constraintAccess(Var v )\n\nforeach constraint C\nif C constrains u\nA = CreateAssignment CC)\n\nifd E C\n// do something\nend constraintAccess\n\nor, alternatively :\nAlgorithm constraiatAccess2(Var v 1, Var u 2 )\n\nforeach constraint C\nif C constrains v l A C constrains v 2\nA = CreateAssignment (Cl\n\nifd E C\n\n// do something\nend constraintAccess2\n\nChecking constraint membership\nThe first operation mentioned actually has two facets. The one is having an object\nVar *v and an object Cons *c and checking whether c constrains v. This is done by\nsimply checking that c->constrains (v) is true. The supporting structure is little more\n\nt h m a bit vector.\n\nThe other facet of this operation is finding, and iterating over, the constraints that\nconstrain a variable or a pair of variables.\n\nThis is done by accessing the container\n\n~ons~ist~fVar(v)\nor CvarListOfVar(v1, v2) respectively.\nThese containers are simply wrappers around lists that are maintained for the variable\nobjects. Each such variable object v contains a Iist of al1 the constrains that constrain\nthis variable. In addition an array of lists is kept. For each variable v2. the list at index\n\nv2->id contains al1 the constrains the constrain both v and v2. This arrangement is\nshown in figure 3.3.\nIn this figure, w e see the data structures maintained for variable Pi. This variable\ny, The list cons contains pointers to\nparticipates in the constraints Cv,,v,,v,, CL;,^, , Cc;\n\neach of these constraints. In addition, a list of per-variable constraints is kept in cvar.\nThe list for Vl is always empty, while the list for\n\npoints to Cv,,if2,~;\nand CVltv2\nand\n\nthe list for 113 points to Cv,,v,,v, and CV,,~,.\nThe same structures are kept for each of the\nother variables, but are not shown in the figure. Pointers from the constraints back to\nthe variables are also kept, but not shown in the figure.\nThese lists are filled when completing the initialization of the CSP.\n\n-\n\nFigure 3.3 Associating a variable with the constraints it participates in\n\nChecking const raint satisfaction\nThe actual reason that constraints exist at al1 is to check whether or not assignments\nsatisfy t hem.\nHowever, the representation of a constraint is not easily abstracted. One common\nabstraction is the extensional representation, where a boolean value is used to indicate\nwhether an assignment satisfies a constraint. For a constraint of arity n. we store these\nboolean values in an n-dimensional array, where the index For dimension k is the id of\nthe value assigned to the kth variable of the constraint.\nThis representation, however, can be very space-inefficient for problems with constraints of large arity or large domains, as the space complexity of this structure is\n\nO(nd),\nwhere n is the arity of a constraint and d is maximum of the sizes of the variable\ndomains. Not only that, but the construction of this array also has time cornplexity\n\nO ( n d ) . On the other hand, a procedural representation for the same constraint might\nhave constant initialization time complexity and constant space complexity\nTherefore, we need a way for thc user of the framework to provide a procedural\nrepresentation of their own, or use the extensional representation if this is convenient.\nTo provide for this, we define a base class ConsRep, which abstracts the functionality\nof the constraint representation. This class provides a virtual function checkAssgn, which\nmust be overridden by derived classes to return the truth value of an assignment. Thus.\na ConsRep* can be an interface to any kind of constraint checking mechanism.\nThe\n\nframework\n\nprovides\n\nLibfntent ionalconsRep.\n\ntwo\n\nbuiltin\n\nclasses,\n\nExtensionalConsRep\n\nand\n\nThe former provides the O ( n d ) extensional representa-\n\ntion discussed abave. The latter d o w s the user to define constraint checking functions\nin a shared library, load this library dyuarnically at runtirne and forward the checking\nto the functions in the shared library.\nGiven d l that, objects of c l a s s Cons a c t u d y do not do any checking. Instead,\nthey maintain a list of objects of cl ass ConsRep. When calling c->checkAssgn() for\n\na constraint c, what it actudly does is go through every ConsRep object in its list and\nask them whether the assignment satisfies them. It returns the conjunction of t h e results\n\nthat it gets.\nThe reason we use a list of ConsRep objects for each constraint is that the framework\nsupports posting only one constraint over one set of a variables. This is not a limitation\non what kinds of problems can be represented, since a constraint t hat is the conjunction\nof several constraints over the same variables is equivalent to them (but can cause more\npruning when doing GAC propagation). It can, however, be inconvenient for the user\nto have to manually conjoin two constraints that are logically separate in the mode1 of\nthe CSP she is trying to solve. Therefore, ive provide a way for the user to define tivo\nlogically distinct constraints over the same set of variables and have them automatically\nconjoined by the framework.\n\nPropagators\nThe final aspect of constraint checking that we have to address is constraint propagation.\nConstraint propagation can be in the form of forward checking, enforcing various\nforms of arc consistency checking or sornethiog more elaborate. It could be argued that\nwhether we do forward checking or arc consistency is actually a matter of the which\nalgorithm we chowe (a variant of FC or of GAC). However, a unified view of constraint\npropagation helps to better structure the code. Moreover, some types of constraints can\nhave a speciai structure, such that an algorithm can be developed for doing constraint\npropagation wit h a time complexity significantly smaller t han that of standard const raint\npropagation. This type of const raint propagation could be used by al1 types of algori t hms.\nConsequently, each constraint maintains a list of appropriate propagators.\n\nWhen\n\nan algorithm makes an assignrnent, it can choose to cal1 these propagators and take\n\nadvantage of their domain knowledge. The difference between VSCBJ, FC and GAC is\nthat the first two will just accept the results of the propagation, while GAC d l regard\n\nit as just a more efficient way of enforcing GAC on a constraint.\nLike constraint representations, there is no generic way to implement a constraint\npropagator. The implernentation has to be abstracted to a base class propagator that\nprovides the interface for propagation. The derived classes have t O provide im p lement ations for virtual functions related to initialization, propagation, backtracking and management of the queue for GAC. Specifically, when doing propagation, t h e derived class is\nnotified of which values have b e n pruned? so it can update its interna1 representation (if\nany). Each propagator has to return a list of values that it has decided should be pruned\nand the variables that are affected by this pruning.\nEach constraint has a list of associated propagators with it. The reason for having\n\na list, instead of a single propagator is, as with constraint representation, the ability to\n\nhave logically separate implementations and have the frarnework take care of conjoining\ntheir results, instead of having to manually do it.\n\nPropagator example: the AIlDiff propagator The AllDiff constraint is a special\ntype of constraint.\n\nIt dictates that the value of its variables are al1 different. In a\n\nCSP, it can be implemented either by a clique of binary not-equals constraints for al1\nthe concerned variables or as a constraint of arity n. Either of t hese will find the same\nsolutions.\nHowever, when doing GAC propagation, their effects are quite different. Consider the\nexample of an AllDiff constraint among the variables h lhl\n\nwith domains (1.21, {1,%)\n\nand {1,2,3} respectively. Enforcing GAC on the binary not-equals representation will\nnot prune any variables. Doing it on the constraint of arity n however will prune values 1\nand 2 from the domain of K. The complexity of enforcing GAC on a constraint of arity\n\nn, however, has time complexity O(nd),\nwhich is prohibitively expensive.\n\nJ.C. Règin [26]has proposed a special purpose propagator for this type of constraint,\nwhich allows us to have stronger arc consistency with small complexity. The idea is that\n\nwe transforrn the constraint into a bipartite graph. The vertices in one partition, X,\nrepresent variables and the vertices in the other partition, Y, represent values. An edge\nbetween two vertices means t hat the value is in the dornain of the variable.\nNext, we find a matching on the bipartite graph. A rnatching is a set of edges such\nthat each vertex is adjacent to at most one of the edges comprising the rnatching. A\nmatching that covers a set of vertices is simply a matching such that all vertices are\nadjacent to exactly one of the edges in the matching.\nGiven that, finding an assignment that satisfies the constraint translates to finding a\nbipartite matching that covers the partition .Y.\nWe can use this idea to also do constraint propagation. Specifically, given a matching\nthat covers .Y,w e can decide whether thcre is any matching that contains a given edge.\nThe conditions for this are that the edge either belongs to the current matching, or to\nan alternating path of even length, or an alternating cycle.\n\nThe complexity for this, for the worst case that the propagator gets called to remove\nthe values of each variable one by one is 0 ( n 2 d 2 ) . If we make the crude assumption that\nthe time spent in the propagator is equally divided among the nodes along the pat h to\na leaf of the search tree, then t h e complexity at each node is O ( n 8 ) . In contrast, the\ncornplexity for generic GAC enforcing for t his coustra.int tvould be O(dnd) at each node.\nThe routines described in (261 map exactly to the virtual functions that the class\nwe derive from Propagat o r has to implement . Therefore, the implementation is rather\nstraightforward.\n\n3.2\n\nAlgorithms\n\nThe implementation of the dgorithms discussed is relatively straightforward, once t 6e\nrest of the framework is in place.\nThey are simply translations of the pseudocode in figure 3.1, calling functions to do\n\nconsistency checking ( t h e 81,constraint propagation (iine 9) and conffict set rnaniputat ion\n(Iines 19 and 20, as well as inside the functions for consistency checking and constraint\npropagation).\n\nCSP : :assgnConsistent checks whether the latest assignment made is consistent with\nthe previous assignments and returns the first constraint that is inconsistent or NULL if\nthe assignment is still consistent.\nThe following functions do conflict set manipulation:\nC f c e l l : :setConsConfïict - sets the conflict set of a value t o be the set of levels where assignments where made to the variables of a constraint. excluding the\ncurrent variable.\n0\n\nC f c e i l : :s e t c o n f l i c t S e t - sets the conflict set of a value to be the union of the\n\nconflict sets of al1 the values t hat are compatible with it in the domain of another\n\nvariable.\n0\n\nCf ce11 ::setCBJConflictSet - sets the conflict set of a value to be the union of\nthe conflict sets of al1 the values in the domain of another variable\n\nO\n\nCf ce11 : :rnergecf s - unions two conflict sets.\n\nFinally, the functions t hat need to be called for pruning:\nO\n\nFCPrune - forward checking, without conflict set manipulation\nFCCf P ~ n - eforward checking, set t ing conflict sets for pruned mriables.\n\nFCCf LookBackPrune - forward checking, setting the conflict set of the pruned vari-\n\nable to be the union of the conflict sets of al1 the values t hat support at the current\nlevel.\nGACPrune - maintains arc consistency at the current node, using a flag for whether\n\nto use confiict sets.\n\nGACPrnne GACh-une is the oniy function that is not trivial to imptement using the\nunderlying framework.\nGACPrune has to use propagators t o enforce GAC as efficiently as possible. As de-\n\nscribed in chapter 2, AC-3, the version of AC that we implement, stores pairs < C: C >\nin a queue. Whenever it processes one such pair, it makes sure that al1 the values of V\nare GA consistent with respect to C. Processing a pair involves invoking the propagator\nfor that pair and pruning the values that the propagator decides are GA-inconsistent.\nAfter that, it determines which variables have had their domain pruned. For each such\n\nvariable V', it finds al1 variables V\" that are constrained with V' via a constraint C\" and\ninserts every pair < V\", C\" > into the queue. The reasoning for this is that since V' has\nhad its dornain pruned, then some of the values of VI' may have lost their support for\n\nconst raint CM.\nHowever, it is not always desirable t o insert every possible pair into the queue. There\nare two reasons why this is so:\n0\n\nThe user may have requested that GAC is not enforced for some constraints under\nspecific circumstances:\n\n- Because it is too expensive t o do so a t that point (for example, we may want\nto enforce GAC on a 10-ary constraint oniy when at least 7 of the variables\nare instantiated. This is equiualent in time complexity to enforcing GAC on\n\na 3-ary constraint)\n\n- Because there is a cheaper way to do perform the same task (When ive use\nredundant constraints)\na\n\nThe propagator may examine dl the variables of a constraint at once. Such an\nexample is the AllDiff propagator, which needs to have its constraint inserted into\nthe queue only once each time that sorne of t h e variables it constrains have their\ndomain pruned.\n\nTherefore, before inserting a pair <\n\nC > into the queue, the algorithm asks the\n\nconstraint representation for this if it wants to be inserted into the queue. This is user\ncontrollable and corresponds to the first of the items listed above. If this succeeds, it\nthen asks the appropriate propagator if it wants to be inserted into the queue. This is not\nuser controllabie, but rather intrinsic to t h e propagator. For example. a general purpose\n\nGAC propagator will need to be inserted into the queue For every pair, but an AllDiff\npropagator should not be in the queue more than once a t any given moment.\nCurrently, GACPrune uses a queue, but it really only needs a structure that supports\nthe properties of a set:\na Insert an item in the set if it is not already there\na Remove an item from the set\n\nTherefore, we might use a stack or a priority queue instead of a queue. Depending\non the problem currently being solved, it can benefit the speed of enforcing GAC.\n\n3.3\n\nHeuristics\n\nCurrent ly, the only heuristics supported by the framework are D VO (dynamic variable\nordering) heuristics.\n\nThe user program selects what kind of DVO heuristic should be used. The frarnework\nprovides some heuristics, but it is fairly easy to write other ones as needed.\n\nThe user program has to cd1 the algorithm like this:\nfnpt (1, heuristic) ;\nWhere heuristic is an object of a subclass of class Heuristic with operator()\ndefined. When the algorithm needs to select the next variable to assign. The operator\n\nneeds to get Solver: :unasgnVars, which is an array of unassigned variables and return\n\nan index into this array. The user program passes this on to the seIectNxtVar to do df\nthe bookkeeping work of selecting this variable.\nUsing objects like this allows us to implernent heuristics that are more easily customized to the needs of the specific problern. The obvious alternative, using pointers to\nfunctions does not allow this without using non-obvious means of communication between\nthe problem setup code and the heuristic code, such as global variables.\nTo make this clear, consider the case of two common heuristics: dom and rdom. The\nfirst one simply selects the variable with the smallest remaining domain size, while the\nsecond one only considers some of the variables of the problem and applies dom to the\nselection and considering the rest of the variables only after al1 the first variables have\na11 been assigned to. This can be used in problems where we use auxiliary variables to\nenlorce stronger constraints, but we do not want to initialize those variables earlier than\nthe primary ones.\nImplementing dom with either method should be trivial. However. we cannot implement rdom using pointers to lunctions, without using a global variable (or global\nstructure) to indicate which variables are considered auxiliary. Using objects, on the\nother hand, makes this easy, as we simply incorporate this information into the subclass\nwhich we use to compute the heuristic.\nAs a convenience. three heuristics are provided by the framework: dom+deg,\nlexicographie and dom/deg.\n\nOne thing that is not enforced by the framework is the fact that if t here are variables\n\nwhose domains have been wiped out, one of these should b e returned by the heuristic.\n\nThis is required for better performance, since t here is no solution in a subtree where one\nvariable has had its domain wiped out. It is however also required for ail the constraint\npropagating dgorithms to work correctly. Similady, if no variable has had a domain\nwipeout, the heuristic should prefer a variable that has a singleton domain. This is a\n\nCHAPTER\n3. IMPLEMENTATION\nmat ter of performance\n\n43\n\nhaving no impIications on the correctness of the aIgorithms.\n\n'As rnentioned, this optimization can be critical to the performance for algorithms like DavisPutnam Ill]-\n\nChapter 4\nExperiments\n4.1\n\nOverview\n\nIn this chapter, we will demonstrate how the framework that we described allows u s to\neasily perform experiments to evaluate the performance of algorit hms and heuris t ics on\ndifferent problems. We will present an automatic method of manipulating a mode1 and\npotentially improve it when using the GAC family of algorithms. We mil1 test this method\nin two problems: the optimal golomb ruler problem and the random 3SAT problem. In\naddition, we will examine the results of [31] on the optimal golomb d e r problem and\ncompare the results obt ained.\n\n4.2\n\nAutomatic conjunction of constraints\n\nBessière and Régin suggested in (61 that it is possible to use GAC on conjunctions of\nconstraints to increase pruning and therefore reduce the size of the search tree. They\nasserted that models in practical application are usudly created by identifying constraints\nas a conjunct ion of subconstraints and using the subconstraints to mode1 the problem.\n\nHowever, GAC on the subconstraints is not as powerful, in terms of pruning, as GAC on\nthe original constraint .\n\nBessière and Régin d s o suggested that it is possibIe to conjoin constraints that are\nnot semant ically related.\n\nIn addition, they prove that it is possible to enforce GAC on a conjunction of the\nconstraints in O(dllua\n\n(cs)ll),\nas opposed to O(d11\n\n( c , ) I Ifor\n) each const raint i.\n\nFinally, they present experimental results to prove that it can be beneficial in terrns\nof cpu time as well as well as number of backtracks performed, even though the benefits\nin terms of cpu time only exist in harder problems.\n\nIn this chapter, we wil1 examine the reason why conjunctions of constraints afford\nmore pruning and develop a heuristic for choosing constraints that shouid be conjoined.\n\n4.2.1\n\nWhy conjoining causes more pruning\n\nThe set of assignments that satisfy the conjunction CI A C2of two constraints is the set\n\nWhere Ac, is the projection of A on the VarsOf(Cl). This implies that A is the\nunion of two satisfying tuples For Ci and C2?\nsuch that the assignments to t heir cornmon\nvariables are the same. In other words, not every pair of tuples satisfying the original\nconstraints will satisfy the conjoined constraint.\n\nThis means that for a value of a variable to not be pruned when enforcing GAC on\nthe conjoined constraint, we have to find a satisfying tuple for the conjoined constraiot.\nwhich depends o n a stronger condition being satisfied than simply that a satisfying tuple\nexists for each of the constraints Ci, C2.\n\nIn addition, the condition becomes stronger as the two constraints have more variables\nin common. Consider the following cases:\n\nIn this case, a satisfying tuple for Cl A C2 is sirnply the union of any supporting\ntuple of Cl and C2.This is no stronger than GAC on Cl and C2individually.\n\nIn this case, when checking whether the assignment V t x, where V is the common\nvariable, is GA-consistent, ail the GAC algorithm has to do is find a supporting\ntuple for V t x in both Ci and Cz,without any additional constraints. This is\nwhat GAC on the original constraints does as well, so t his case is also no s t ronger\nt han GAC on the original constraints.\n\nIn this case, the tu ples t hat sat isfy the conjunct ion are no longer simply the union of\nany two satisfying tuples of the original constraints. Instead, the number of tuples\nthat can be unioned to create a satisfying tuple for the conjunctive constraint\nbecomes smaller. as they have to have more common assignments. The relative\nstrength of GAC in the conjunction increases as well.\n\nThis reasoning can be extended to the case when we conjoin n constraints, by applying\npairwise conjunct ions.\n\n4.2.2\n\nWhen to conjoin constraints\n\nBased on the above observations, we can develop a heuristic method to determine which\nsets of constraints shouId be conjoined and create the set CS of a11 such sets:\n1. initialize t h e set C S to be the set {{Ci}Vz), which means that each constraint is\n\nplaced in a set by itself.\n\n2. If Ci E CS A Cj E CS A II VarsOf (Ci u Cj)II - maxcec,uc, II VarsOf(C)II 5 !CI, then\nremove Ci and Cjfrom CS and insert Ci U Ci.Ci 'iCj is the conjunction of the\nconstraints in Ci and C,.\n\nIn other words, if the arity of the constraint that results\n\nfrom conjoining the constraints in Ci and Cj is no more than M greater than the\n\naxity of any of the original constraints, then conjoin ail the constraints in Ci and\n\nC j.\n3. Repeat 2 until no more conjunctions can be made.\nT h e parameter M limits the constraints that can be conjoined. When il1 = 0, two\nconstraints will only be conjoined when one is over a subset of the variables that the other\ncovers. In this case, the complexity of GAC does not increase at all. since the constraints\nof higher arity are not created, while the advantages of conjoining constraints remain.\n\nAs M increases, the complexity of GAC increases as well. It depends on the problem\nat hand what the value of M should be. In the following sections, we will examine two\nsuch problems.\n\n4.3\n\nOptimal Golomb Rulers\n\nA golomb ruler is a set of non negative integers, ma,.... m,, called marks, such that the\ndistances mi - m j , i > j,Vi, j are distinct.\nMoreover, the length O/ a golomb ruler is defined as max(mi - m j ) ,Yi,j . T h e first\nmark is typically O, so the length of the ruler is actually max(mi)Vi.An optimal golomb\n\nruler is one such that no ruler of smaller lengt h wit h the same number of marks exists.\n\nSmith e t al. in [3t] have studied various alternative representations? heuristics and\nextra constraints that one can add to make solving the problem more efficient. We wiIl\ntry t o reproduce some of their results here.\n\n4.3.1\n\nRepresentations\n\nThis problern can be represented as a Constraint Satisfaction Problem, by posting a\nconstraint mi - mj # mk - ml,Vi > j,k > 1. This also implies that we post ternary\nconstraints, for the special case when i = I. To limit the number of symmetric solutions,\n\nwe d s o post the constraints mi < m j , tli < j and also 7722 - ml < m, - m,-~ to etiminate\nsymmetric solutions. Using this representation, we post the iollowing constraints over\nevery set of 4 variables:\n\nThe first 3 constraints are quaternary constraints, while the other 4 are ternary.\nIt should be noted that these are not al1 the constraints that the formula mi - m, $\nrnk\n\n- ml, V i > j, k > 1 irnplies. There are many constraints that are essentially duplicated\n\n(e.g xi - x0 f\n\n$3\n\n- 52 is equivalent to x3 - 32 # X I - xo) or otherwise redundant\n\n(x2 - x g # X I - x0 is impIied by the fact that xo < xl < x?).\nSmith et al. [31] assert that the obvious representation is not optimal. They propose\n\nan alternate representation, where each mark is a variable in the CSP, as well as m ( m 1112 auxiliary variables. For every two mark variables, an auxiliary variable is used to\nrepresent their difference and a constraint to that effect is posted among these three\nvariables.\n\nIn addition, we post a not-equals constraint between every two auxiliary\n\nvariables. The aut hors prove t hat t his representation will generate more pruning t han\nthe one with quaternaxy constraints in every case except when the quaternary constraint\nis actually a ternary constra.int of the form Cv.,v,,v,,vk.\nThis representation can be further improved if a single dldiff constraint is posted over\n\na11 the auxiiiary variabres instead of a clique of binary const raints.\n\n'\n\nMoreover, different dynamic variable ordering strategies are compared for the best\nrepresentation, comparing a static lexicographie ordering, the dom heuristic and the rdom\nheuristic (dom rest ricted to the mark variables).\n\n4.3.2\n\nResults\n\nSince we use different software, as well as hardware, from what Smith et al. used, the results are not directly comparable. It should also be noted that they used an optimization\nleature to discover the optimal golomb ruler, something rvhich is not currently provided\n\nby Our framework. CVe can, however, reproduce their comparative results.\n\nComparing representations\nIn addition to the representations studied by Smith et al., we study an additional representation, which is automatically derived from the one using quaternary constraints by\napplying the heuristic discussed earlier with the parameter M set to iCI = 0.\n\nWe count the nurnber of recursive cails made to find a ruler of the given length (or\nprove that none exists). The results are s h o w in figure 4.1. In this table, the first two\ncolumns show the size of the problem tested, the fint being the nurnber of marks and\n\nthe second the length of the d e r . After that, we have two colurnns for each of the four\nrepresentations tested: the original one using quatemary constraints, the conjunctive\none which d s o uses quaternary constraints and the two representations using ternary\nconstraints Smith et al proposed. The first column for each representation shows the\nnumber of backtracks performed by the solver and the second shows the cpu t ime it used\nto solve the corresponding problem.\nNote that the representation using conjunctive quaternary constraints fares much\n'Régin [26] discusses the advantage of a single aiidiff constraint over a clique of binary not-equals\nconstraints as weil as a way to efficiently irnplement it.\n\nbetter than the originaI quaternary representation. TIie resuIting singIe conjunctive constra.int generates much more pruning when doing GAC propagation.\n\nFigure 4.1 Backtracks perforrned and cpu tirne to find (F) a golomb ruler of a given size\nand prove ( P ) its optimality. \"-\" indicates that the solver w a s unable to find a solution\nafter\n\nz3' consi aint checks\nQuaternary\n\nConj Quat\n\nTernary\n\n1 size length\n\n8\n\n34 ( F )\n\n8\n\n33 (P)\n\n9\n\n44 (F)\n\n9\n\n43 (P)\n\n10\n\n55 (F)\n\n10\n\n54 (P)\n\n11\n\n72 (F)\n\n11\n\n71 ( P )\n\nWe notice that the conjunctive quatemary representation is approximately as powerful\nas the temary+not-equals representation, while enjoying rnuch bet ter t imes due to the\n\nsimplicity and smaller number of constraints *.\n\nWe c m also see that the representation that used the A l l D i f fpropagator does not\nperform as well as the one in the commercial product ILOG Solver that was used in 1311,\nbut its relative performance compared to the representation using a clique of not-equds\nconstraints is what is expected.\n' ~ c t u a l l ~both\n,\nrepresentations have 0(m4)constraints, but the representation with conjunctive\nquaternary representations has O(m) variables as opposed to 0(m2)variables\n\nIn generd, the higher times produced here can be attributed to the impiementation\nof the GAC-enforcing algorithrn, which is based on AC-3. In contrast, ILOG Solver uses\nan algorithrn based on AC-7, which scales better than AC-3.\n\nIn addition to this test, we performed a test using different levels of conjoining for\nthe quaternary represent at ion, shown in figure 4.2.\n\nFigure 4.2 Backtracks and cpu time to find (F) a golomb ruler of a given size or prove ( P )\nits optimality. \"-\" indicates that the solver was unable to find a solution after reaching\n10' leafs\n\nQuat\n\nProblem\nsize goal\n\n1\n\n+ Tern\n\nConj Quat\n\nI\n\n+ Tern Conj Quat only\n\nI\n\nI\n\nThe first colurnn in that table shows the original quaternary representation. while\nthe last columns show the conjoined representations. In the second column, we show\nthe results for an intermediate representation (which was not generated automatically ) ,\nwhich consists of a conjunction of the quaternary constraints, but without the ternary\nconst raints.\nThe results are not surprising, other than the fact that the first two representations\nperform the exact sarne number of backtracks in every case. This can be explained by\nthe fact that the 3 quateniary constraints posted every set of 4 variables are actually\n\nCHAPTER\n4. EXPERIMENTS\nequivafent. The constraints are:\n\nIt turns out that we only need to post the first of these constraints. as the others are\nimplied. In particular, we can add x2 - x l to 4.1 to get 4.2, while 4.3 is implied by the\norder constraints between the variables (x, < x,, i < j ) .\nThis demonstrates the fact that conjoining constraints is not only an automatic way\nto improve a model, but also good for analysis. Aspects of the rnodel which ivere not\npreviously clear can be revealed by analyzing the behavior of the derived models.\nFrom this point on, al1 results wiI1 report on the conjoined quaternary representation\ninstead of the original quaternary representation.\n\nComparing variable ordering strategies\nWe will compare two orderings for this problem: a static lexicographic and the dom+deg\nheuris t ic.\nSurprisingly, the lexicographic ordering turns out to be the best strategy for this\nproblem, as shown in figure 4.3.\nWe actuaily see a different behavior for the two heuristics, depending on whether ive\nuse the representation with quaternary constraints or the one with ternary constraints\n\nand the -4lldiff propagator.\n\nThe lexicographic ordering gives better results in d l cases when using ternary constraints. The reason for this is that selecting the variable wit h the minimum remaining\ndomain size can often select one of the auxiliary variables. The value of these variables,\nhowever, depends entirely on the value of the mark variables it is constrained with- When\n\nFigure 4.3 Kurnber of backtracks (ieafs) to find (F) a goIomb d e r of a given size and\nprove (P) its optimality using different DVO heuristics\nr\n\n1\n\nProblem\n\nQuaternary\n\nTernary+ Alldiff\n\ndom+deg lexicographic\n\ndom+deg lexicographic\n\nsize\n\nlength\n\n7\n\n25 (F)\n\n90\n\n90\n\n7\n\n24 (P)\n\n824\n\n594\n\n8\n\n34 (F)\n\n491\n\n492\n\nS\n\n33(P)\n\n6231\n\n7131\n\n9\n\n44 (F)\n\n4947\n\n4920\n\n9\n\n43 ( P )\n\n42844\n\n52568\n\n10\n\n55 (F)\n\n30962\n\n36666\n\n10\n\n54(P)\n\n250822\n\n373375\n\n11\n\n72 (F)\n\n183960\n\n234069\n\n11\n\n71 (F)\n\n-\n\n-\n\nnone of the other two variables have been assigned, it will cause minimal pruning. Because the total number of auxiliary variables is relatively high (O(m2)),\nthere is a high\nprobability that this will happen often. Therefore. the system spends much time doing\nwork that does not gain anything.\nInstead, the lexicographic ordering makes sure that the mark variables are assigned\nfirst.\n\nWe also notice t hat when using quaternary constraints, the dom+deg heurist ic does\nnot significantly improve the performance of the solver. This cm be attributed to the\nnature of the problem and the representation. In the original definition of the problem,\nal1 mark variables are equivalent. Therefore, there are many syrnmetric solutions. When\nsolving this problem, the dom+deg heuristic would be expected to perform much better\nthan the lexicographic heuristic.\n\nHowever, we do not want to report a11 symmetric soIutions. Therefore, we impose the\nFollowing constraints to break symmet ries:\na\n\nmi < m,,i < j. This constraint eliminates an exponential number of symmetric\n\nsolut ions.\nrn\n\nmz - mi < mk - mi-1, where k is the length of the ruler. This constraint only\neliminates one symrnetric solution.\n\nOf these, the first type of constraint is the one that makes the difference. Because of\nit, al1 mark variables are no longer equivalent. In fact, the optimal ordering should almost\nalways be very close to the lexicographic ordering of the variables. This is because, al1\nother things being equal, as more variables become instantiated in lexicographic order.\nthe tighter the constraints become for the next variables and therefore more values get\npruned from domains.\n\nComparing algorithms\nThe authors of [31] used ILOG's Solver for their experirnents. This solver uses AC-; to\nenforce GAC, instead of AC-3 used by our implementation. This causes their results to\nshow GAC stronger in terms of time than ours. However, they do not consider FC and\nconflict filtered backt racking algorithms at all.\n\nThe table in figure 4.4 shows that using CFFC instead of GAC type algorithms can\ndramatically improve the performance of finding a solution. Similarly, CFGAC performs\nbetter that GAC, both in terms of time and number of recursive caIls.\nFrom this table, we can see that CFGAC is better than GAC at finding a solution\nboth in the nurnber of backtracks performed, as well as in cpu time. CVhen proving the\noptimality of a given d e r , it is better in terms of recursive calls and comparable in terms\nof cpu time. This means that maintainhg the conflict sets is an overhead that pays off\nwhen finding the optimal d e r but not when proving that it is optimal.\n\nFigure 4.4 Number of backtracks and cpu time to find (FI a golomb ruier of a given\nsize and prove ( P ) its optirndity using different dgorithms\nProblem\n\nCFGAC\n\nGAC\n\n1 size length 1\n\n1\n\nCFFC\n\n1\n\n1\n\nCFFC is significantly better than both GAC and CFGAC in terms of time. As\nexpected, the number of backtracks performed is higher, but only by a factor of Less than\n\n2 when fmding the optimal d e r and less than an a factor of 3 when proving optimality.\n\nThe factor gets better as the size of the problem increases and it reaches fewer leaves\nthan GAC (but more than CFGAC) when finding the optimal ruler with 11 marks. The\nfact that it does so much less work at each node makes it faster overall, usually around\nan order of magnitude better.\n\nWhat this shows is tbat the c o d i c t sets discovered by CFFC allow the algorithm to\njump approximately back to the point where GAC would reach a leaf. Not only that.\n\nbut after that point, any jumps further back are almost the same ones performed by\n\nCFGAC. In other words, CFFC explores approximately the same portion of the search\nspace as CFGAC, only it has to reach a deeper level before performing each backtrack.\n\nThe size, however, of the subtree that CFFC explores and CFGAC does not is Iinear in\nsize, as opposed to exponential for the general case.\n\n4.4\n\nRandom 3-SAT instances\n\nWe will use the CSP representation to solve random instances of the 3-SAT problem.\nGiven .N and C, the number of variables and the number of clauses, we generate instances\nby randornly selecting 3 Iiterals out of the 21V (positive and negative) Iiterais. discarding\ntautologies. \\Ne then construct the clause ii v i2 v Z3.\nUsing CSPs to solve SAT problems is not optimal, since CSP search algorithms do\nnot take advantage of the special structure of SAT constraints (i.e. 3-clauses). SAT can.\nhowever, be used as an interesting benchmark to compare CSP algorithms. It has been\nshcwn\n\n[II that CFFC is the best algorithm for solving this type of problems, if we use a\n\nCSP soiver.\nlnstead, we will focus on GAC and the use of conjunctive constraints.\n\n4.4.1\n\nRepresent at ions\n\nThe first representation we use is one where we simply post a ternary constraint for each\n\nclause.\nThe second representation is derived from the first one, by applying the heuristic\ndescribed with the parameter LM = 1. The resuiting mode1 contains a mix of ternary and\nquaternary constraints.\n\n4.4.2\n\nResults\n\nWe ran the Solver for both representations at the crossover point c / n = 1.26 [31]for a\nnumber of variables ranging from 60 to 100 with a step of 10. We count the average\n\ncpu tirne and average number of backtracks performed by the soIver, using the GAC\nalgorithm. The results are shown in figure 1.5.\n\nFigure 4.5 Average number of backtracks and cpu time to prove whether a problem is\nsatisfiable or not. The last colurnn indicates the percentage of instances where the solver\nperformed better if constraints were conjoined\n\n1#\n\navg leafs\n\n(\n\nVariables # Instances original\n\nT-Tl\n\n1 iv/conj original w/conj perc\n\nIt is worthwhile noting in this case that there were instances where the solver actually performed more backtracks when using conjoined constraints than it did in the\noriginal problem. This anomaly can be attributed to the fact that 3-SAT has a special\nstructure, which is not accounted for in the DVO heuristic used. Therefore, even t hough\nthe conjunctive constraints cause more pruning, they end up making the search slower.\n\nThis anomaly can probably be eliminated by using one of the heuristics that have been\ndeveloped for SAT solvers.\nIn the instances where the solver performed fewer backtracks with conjunctive constraints, the cpu time used is at most 10% worse t han the time used to solve the problem\nusing the original model. This shows that the overhead of performing GAC on the conjoined constraints is alleviated by the extra pmning that it causes. The refined results\nare shown in figure 4.6.\n\nFigure 4.6 Average number of backtracks and cpu time to prove whether a probtem is\nsatisfiable or not. The last column indicates the percentage of instances where the solver\nperformed better if constraints were conjoined. Only instances for which conjoining\nstraints did not interfere with the behavior of the DVO heuristic are counted\navg leafs\n\navg time\n\n1 # Variables 1 # Instances ( original\n\n4.5\n\nConclusions\n\nIn this chapter, we demonstrated the ability of the framework described in chapter 3 to\nsupport experiments in the field of CSPs. CVe tested it on two widely used benchmark\nproblerns, the optimal golomb ruler problem and the random 3SAT problem.\nIn addition, we proposed a simple technique to automatically improve the efficiency of\na mode1 when using the GAC algorithm. We demonstrated the ability of the frarnework\nt o support this new technique and used it to show that it can indeed produce better\nmodels. We did note possible problems that it can introduce by interfering with the\n\nDVO heuristic used, but overall the results were encouraging.\n\nChapter 5\nConclusions\nIn this thesis, we have examined existing CSP search algorithms in a consistent rnanner\nwhich allows for their implementation in a common frarnework. Specifically, we found t h e\nalgorithms examined differ only in the Ievel of constraint propagation that they perform\n\nand in the granularity of the conflict sets that they maintain. This enables us to treat\n\nthem uniformly, at least from the point of view of what they require to work and how to\nprovide t hat .\nSimilarly, we provided an overview of commonly used variable ordering heuristics and\nshowed how t hey can be treated consistently.\nThe CSP solver that was implemented based on these findings is a general-purpose,\nflexibie solver that not only can be extended to accommodate new algorithms and new\nvariable ordering heuristics, but also allows for experimenting with models, special purpose propagators and extensions of the CSP modei.\n\n5.1\n\nFuture Work\n\nThe framework that was developed for this thesis can be used to facilitate research in\nthe following oreas:\n\nfntegration of CSP algorithms with other search techniques. One example of this\nmight be integrating a CSP solver with integer programming algorithms.\nModeling. We havealready demonstrated (in chapter 4) that it is possible to use the\nframework developed here not only to test alternative representations to solve the\nsame problem, but also to automatically aply transformations to an existing model\nas a way to improve solver performance. Not only that, but pre-existing known\n\ntransformations (e.g. frorn a non-binary problem to a binary one. using either the\ndual [13] or the hidden variable [2î] transformation) are hard to apply manually.\nInstead, it is easier to define a mode1 and have a routine do the transformation.\nThis allows us to perform experiments on a wide array of problems to test the\nefFect iveness of di fferent model ing techniques.\nSearch algorithms. We have implemented here several of the most popular a l g e\nrithms used for solving CSPs and implementing new ones in an efficient manner\nshould be straightforward.\n0\n\nDynamic variable and value ordering heuristics. As rnentioned, little is understood\nabout the implications of dynarnic variable ordering heuristics on the performance\nof the search algorithms discussed. It would be interesting to study the behavior\n\nof known heuristics in problems other than random CSPs [î, 33, 161.\nExtension of the CSP model. It has been proposed to extend the CSP model to\nallow the use of hard and soft constraints (e.g VSCP [29]) or other approaches to\noptimization. This field, however, has not been explored in depth.\n\nAvailability\nThe resiilt of the work described in this thesis can be obtained online a t\nhttp://vvw.cs.toronto.edu/~gkatsi/efc.tar.gz\n\nBibliography\n[Il Fahiem Bacchus. Extending forward checking. In Pn'nciples and Practice of Constraint Prograrnming, pages 35-5 1, 2000.\n\n[2] H. Bennaceur. The sat isfiability problem regarded as a const raint satisfaction problem. In Proceedings of the 12th ECA I, pages 155-159, 1996.\n\n[3] Michael E. Bergen, Peter van Beek. and Tom Carchrae. Constraint-based vehicle assembly line sequencing. In Proceedings of the 14th Cnnadian Conference on A rtificial\nInteliigence, pages 88-99, Ottawa, Ontario, 200 1.\n141 C. Bessière. Arc-consistency and arc-consistency again. In Artzficial Intelligence 65.\n\npages 179-190, 1994.\n\n[5] C. Bessière, E.C. Freuder, and J.C. Régin. Using inference to reduce arc-consistency\ncomputation. In Proceeding of the 14th IJCAI, Montréal, Canada, 1995.\n\n[6] C. Bessière and J.-C. Régin.\n\nLocal consistency on conjunctions of constraints.\n\nIn Proceedings of the ECAI'98 Workshop on Non-binary const raints, pages 53-59,\nBrighton, UK, 1998.\n\n[7] Christian Bessière and Jean-Charles Régin. MAC and combined heuristics: Two\nreasons to forsate FC (and CBJ?) on hard problems. In Principles and Practice of\nConstraint Prograrnming, pages 61-75, 1996.\n\n[8] J. R. Bitner and E. M. Reingoid. Backtrack programming techniques. Comm. .4C%f,\n18:651-656. 1975.\n\n[9] D. Brélaz. New methods to color the vert ices of a graph. In Communications O/ the\n\nACM, 22, pages 251-256. 1979.\n\n[IO] P. Burke and P. Prosser. The distributed asynchronous scheduler. In M. Zweben\nand M. S. Fox, editors, Intelligent Scheduling, pages 309-339. Morgan Kaurmann\nPublisbers, 1994.\n[11] W. Davis. G. Logeman, and D. Loveland. A machine program for theorem proving.\nCommunication of A CM, ,5394-397, 1962.\n[12] R. Dechter and 1. Meiri. Experimental evaluation of preprocessing techniques in\nconstraint satisfaction problems. ArtiJieial Intelligence, 6521 1-242, 1994.\n[13] R. Dechter and J. Pearl. Tree clustering for constraint networks. Artificial Intelligence, 35:353-366, 1989.\n1141 J. Gaschnig. Experimental case studies of backtrack vs. Waltz-type vs. new algorithms for satisficing assignment problerns. In Proceedings of the Second Canadian\nConference on ArtiJicial Intelligence, pages 268-277, Toronto, Ont.. 1975.\n\n[15j R Genisson and P. Jegou. Davis and putnam were already fortvard checliing. Ln\nProceedings of the 12th ECAI, pages 180-184, 1996.\n(161 1. P. Gent, E. MacIntyre, P. Prosser, B. M. Smith, and T. Walsh. An enipirical study\n\nof dynamic variable ordering heuristics for the constraint satisfaction problem. In\n\nE. C. Freuder, editor, Principles and Practice of Constraint Progmmrning, pages\n179-193. Springer, 1996.\n[l?] R. M. Haralick and G . L. Elliott. Increasing tree search efficiency for constraint\nsatisfaction problems. Artificial Intelligence, 14:263-313, 1980.\n\n[18j P.van Henteryck, Y. DeviHe, and C. Teng. A generic arc consistency aigorithm and\n\nits specializations. In Artificial Intelligence 57, pages 291-321, 1992.\n[19] A. Mackworth. Consistency in networks of relations. In Artificial Intelligence 8,\npages 99-118, 1977.\n[20] A. K. Mackworth. On reading sketch maps. In Proceedings of lhe Fifth International\nJoint Conference on Artificial Intelligence, pages 595-606, Cambridge. Mass.. 1977.\n\n[%II D. Mitchell, B. Selman, and H. Levesque. Hard and easy distributions of SAT\nproblems. In Proceedings ojthe Tenth National Conference on Artijkial Intelligence,\npages 459-465, San Jose, Calif., 1992.\n\n(221 R. Xohr and T.C. Henderson. Arc and path consistency revisited. In rlrti/icial\nIntelligence 28, pages 225-233, 1986.\n\n[231 B. A. Nadel. The consistent labeling problem and its algorithms: Towards exact-case\ncomplexit ies and t heory-based heuristics, 1986.\n[24] P. Prosser. Hybrid algorithms for the constraint satisfaction problem. Computational\n\nIntelligence, 9268-299, 1993.\n[25] P. Prosser. MAC-CBJ: Maintaining arc consistency with conflict-directed backjump\n\ning. Research Report 177, University of Strathclyde, 1995.\n\npz61 J. Règin. A filtering aigorithm for constraints of difference in csps. 1994.\n[2î] F. Rossi, C. Petrie, and V. Dhar. On the equivalence of constraint satisfaction\n\nproblems. Technical Report ACT-AI-222-89, MCC, Austin, Texas, 1989. A shorter\nversion appears in ECAI-90, pages 550-556.\n\n[28] D. Sabin and E. C. Freuder. Contradicting conventional wisdom in constraint satisfaction. In Proceedings of the I I th Eumpean Conference on Artificial Intelligence,\npages 125-129, Amsterdam, 1994.\n\n[29j T. Schiex and G. Verfaillie. VaIued constraint satisfaction problems: hard and\neasy problems. In Proeeedings O/ the Fourteenth International Joint Conference on\nArtifieial Intelligence, pages 63 1-639, Mont real, 1995.\n\n[30] Thomas Schiex, Jean-Charles Régin, Christine Gaspin, and Gérard Verfaillie. Lazy\nArc Consistency . In Proceedings of A A A 196, pages '16-221\n\nPortland, Oregon. USA.\n\n1996.\n[31] B. Smith, K. Stergiou, and T. Walsh. Modelling the golomb ruler problem, 1999.\n\n1321 Barbara M. Smith. The brlaz heuristic and optimal static orderings.\n[33] Barbara M. Smith and Stuart A. Grant. Trying harder to faii first. In European\nConference on A rtificial Intelligence, pages 249-253, 1998.\n1341 Toby Walsh. Sat vs csp. In Proeeedings of Cf-2000, pages 441-456, 2000.\n\n","pages":{"startPosition":[0,5001,9997,15000,19992,24998,29998,34999,40001,44997,49995,54995,59999,65001,70000,75000,80001,85001,90000,94999,99999]}},"html":{"comparison":{"identical":{"groupId":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32],"source":{"chars":{"starts":[3677845,3677862,3677870,3677887,3677895,3677912,3677920,3677937,3677945,3677962,3677970,3677987,3677995,3678012,3678020,3678037,3678045,3678062,3678070,3678087,3678095,3678112,3678120,3678137,3678145,3678162,3678170,3678187,3678195,3678212,3678220,3678237,3678245,3678262,3678270,3678287,3678295,3678312,3678320,3678337,3678345,3678362,3678370,3678387,3678395,3678696,3678713,3678721,3678738,3678746,3678763,3678771,3678788,3678796,3678813,3678821,3678838,3678846,3678863,3678871,3678888,3678896,3678913,3678921,3678938,3678946,3678963,3678971,3678988,3678996,3679013,3679021,3679038,3679046,3679063,3679071,3679088,3679096,3679113,3679121,3679138,3679146,3679163,3679171,3680867,3680884,3680892,3680909,3680917,3680934,3680942,3680959,3680967,3680984,3680992,3681009,3681017,3681034,3681042,3681059,3681067,3681084,3681092,3681109,3681117,3681134,3681142,3682014,3682031,3682039,3682056,3682064,3682081,3682089,3682106,3682114,3682131,3682139,3682156,3682164,3682181,3682189,3682206,3682214,3682231,3682239,3682256,3682264,3682642,3682659,3682667,3682684,3682692,3682709,3682717,3682734,3682742,3682759,3682767,3682784,3682792,3682809,3682817,3682834,3682842,3682859,3682867,3683246,3683263,3683271,3683288,3683296,3683313,3683321,3683338,3683346,3683363,3683371,3683388,3683396,3683413,3683421,3683438,3683446,3683463,3683471,3683779,3683796,3683804,3683821,3683829,3683846,3683854,3683871,3683879,3683896,3683904,3683921,3683929,3683946,3683954,3683971,3683979,3683996,3684004,3684021,3684029,3684046,3684054,3684071,3684079,3684096,3684104,3684121,3684129,3684146,3684154,3684171,3684179,3684196,3684204,3684221,3684229,3685140,3685157,3685165,3685182,3685190,3685207,3685215,3685232,3685240,3685257,3685265,3685282,3685290,3685307,3685315,3685332,3685340,3685357,3685365,3685382,3685390,3685407,3685415,3685432,3685440,3685457,3685465,3685482,3685490,3685507,3685515,3685532,3685540,3685557,3685565,3685829,3685846,3685854,3685871,3685879,3685896,3685904,3685921,3685929,3685946,3685954,3685971,3685979,3685996,3686004,3686021,3686029,3686046,3686054,3686071,3686079,3686096,3686104,3686129,3686146,3686154,3686171,3686179,3686196,3686204,3686221,3686229,3686246,3686254,3686271,3686279,3686296,3686304,3686321,3686329,3686694,3686711,3686719,3686736,3686744,3686761,3686769,3686786,3686794,3686811,3686819,3686836,3686844,3686861,3686869,3686886,3686894,3686911,3686919,3686936,3686944,3686961,3686969,3686994,3687011,3687019,3687036,3687044,3687061,3687069,3687086,3687094,3687111,3687119,3687136,3687144,3687161,3687169,3687186,3687194,3687211,3687219,3687236,3687244,3687261,3687269,3687286,3687294,3687311,3687319,3687336,3687344,3687944,3687961,3687969,3687986,3687994,3688011,3688019,3688036,3688044,3688061,3688069,3688086,3688094,3688111,3688119,3688136,3688144,3688161,3688169,3688186,3688194,3688211,3688219,3688236,3688244,3688261,3688269,3688286,3688294,3688311,3688319,3688336,3688344,3688361,3688369,3688386,3688394,3688411,3688419,3688436,3688444,3688461,3688469,3688486,3688494,3688511,3688519,3688536,3688544,3688561,3688569,3688586,3688594,3689874,3689891,3689899,3689916,3689924,3689941,3689949,3689966,3689974,3689991,3689999,3690016,3690024,3690041,3690049,3690066,3690074,3690091,3690099,3690116,3690124,3690141,3690149,3690166,3690174,3690191,3690199,3690216,3690224,3690241,3690249,3690266,3690274,3690291,3690299,3690316,3690324,3690341,3690349,3692647,3692664,3692672,3692689,3692697,3692714,3692722,3692739,3692747,3692764,3692772,3692789,3692797,3692814,3692822,3692839,3692847,3692864,3692872,3692889,3692897,3692914,3692922,3693697,3693714,3693722,3693739,3693747,3693764,3693772,3693789,3693797,3693814,3693822,3693839,3693847,3693864,3693872,3693889,3693897,3693914,3693922,3693939,3693947,3693964,3693972,3693989,3693997,3694014,3694022,3694039,3694047,3694064,3694072,3694089,3694097,3694114,3694122,3694139,3694147,3694164,3694172,3694189,3694197,3694214,3694222,3694239,3694247,3694264,3694272,3694289,3694297,3694314,3694322,3694878,3694895,3694903,3694920,3694928,3694945,3694953,3694970,3694978,3694995,3695003,3695020,3695028,3695045,3695053,3695070,3695078,3695095,3695103,3695120,3695128,3695145,3695153,3695509,3695526,3695534,3695551,3695559,3695576,3695584,3695601,3695609,3695626,3695634,3695651,3695659,3695676,3695684,3695701,3695709,3695726,3695734,3695751,3695759,3695776,3695784,3695801,3695809,3695826,3695834,3695851,3695859,3695876,3695884,3696321,3696338,3696346,3696363,3696371,3696388,3696396,3696413,3696421,3696438,3696446,3696463,3696471,3696488,3696496,3696513,3696521,3696538,3696546,3696563,3696571,3696588,3696596,3696613,3696621,3696638,3696646,3696663,3696671,3696688,3696696,3696713,3696721,3696738,3696746,3696763,3696771,3696788,3696796,3696813,3696821,3696838,3696846,3696863,3696871,3696888,3696896,3696913,3696921,3696938,3696946,3697388,3697405,3697413,3697430,3697438,3697455,3697463,3697480,3697488,3697505,3697513,3697530,3697538,3697555,3697563,3697580,3697588,3697605,3697613,3697630,3697638,3697655,3697663,3697680,3697688,3697705,3697713,3697730,3697738,3697755,3697763,3697780,3697788,3697805,3697813,3697830,3697838,3697855,3697863,3697880,3697888,3697905,3697913,3697930,3697938,3697955,3697963,3697980,3697988,3698005,3698013,3698030,3698038,3698928,3698945,3698953,3698970,3698978,3698995,3699003,3699020,3699028,3699045,3699053,3699070,3699078,3699095,3699103,3699120,3699128,3699145,3699153,3699170,3699178,3699195,3699203,3699220,3699228,3699245,3699253,3699270,3699278,3699295,3699303,3699320,3699328,3699345,3699353,3699370,3699378,3699395,3699403,3711844,3711861,3711869,3711886,3711894,3711911,3711919,3711936,3711944,3711961,3711969,3711986,3711994,3712011,3712019,3712036,3712044,3712061,3712069,3712086,3712094,3712111,3712119,3712136,3712144,3712161,3712169,3712186,3712194,3712211,3712219,3712449,3712466,3712474,3712491,3712499,3712516,3712524,3712541,3712549,3712566,3712574,3712591,3712599,3712616,3712624,3712641,3712649,3712666,3712674,3712691,3712699,3712716,3712724,3712749,3712766,3712774,3712791,3712799,3712816,3712824,3712841,3712849,3712866,3712874,3712891,3712899,3712916,3712924,3712941,3712949,3712966,3712974,3712991,3712999,3713016,3713024,3713041,3713049,3713066,3713074,3713091,3713099,3713116,3713124,3713141,3713149,3713166,3713174,3713191,3713199,3714469,3714486,3714494,3714511,3714519,3714536,3714544,3714561,3714569,3714586,3714594,3714611,3714619,3714636,3714644,3714661,3714669,3714686,3714694,3714711,3714719,3714736,3714744,3714761,3714769,3714786,3714794,3714811,3714819,3714836,3714844,3714861,3714869,3714886,3714894,3714911,3714919,3714936,3714944,3714961,3714969,3714986,3714994,3715011,3715019,3715036,3715044,3715061,3715069,3715086,3715094,3715111,3715119,3715136,3715144,3715161,3715169,3715186,3715194,3715617,3715638,3715646,3715667,3715675,3715696,3715704,3715725,3715733,3715754,3715762,3715782,3715790,3715810,3715818,3715838,3715846,3715867,3715875,3716229,3716246,3716254,3716271,3716279,3716296,3716304,3716321,3716329,3716346,3716354,3716371,3716379,3716396,3716404,3716421,3716429,3716446,3716454,3716471,3716479,3716496,3716504,3716521,3716529,3716546,3716554,3716571,3716579,3716596,3716604,3716621,3716629,3716646,3716654,3716671,3716679,3716696,3716704,3716721,3716729,3716746,3716754,3717086,3717103,3717111,3717128,3717136,3717153,3717161,3717178,3717186,3717203,3717211,3717228,3717236,3717253,3717261,3717278,3717286,3717303,3717311,3717328,3717336,3717353,3717361,3717378,3717386,3717403,3717411,3717428,3717436,3717453,3717461,3717478,3717486,3717503,3717511,3718135,3718152,3718160,3718177,3718185,3718202,3718210,3718227,3718235,3718252,3718260,3718277,3718285,3718302,3718310,3718327,3718335,3718352,3718360,3719062,3719079,3719087,3719104,3719112,3719129,3719137,3719154,3719162,3719179,3719187,3719204,3719212,3719229,3719237,3719254,3719262,3719279,3719287,3719304,3719312,3719329,3719337,3719354,3719362,3719379,3719387,3719404,3719412,3719429,3719437,3719454,3719462,3719479,3719487,3719504,3719512,3719529,3719537,3719554,3719562,3719579,3719587,3719604,3719612,3720534,3720551,3720559,3720576,3720584,3720601,3720609,3720626,3720634,3720651,3720659,3720676,3720684,3720701,3720709,3720726,3720734,3720751,3720759,3720776,3720784,3720801,3720809,3720826,3720834,3720851,3720859,3720876,3720884,3720901,3720909,3720926,3720934,3720951,3720959,3720976,3720984,3721001,3721009,3721026,3721034,3721051,3721059,3721489,3721506,3721514,3721531,3721539,3721556,3721564,3721581,3721589,3721606,3721614,3721631,3721639,3721656,3721664,3721681,3721689,3721706,3721714,3721731,3721739,3723212,3723229,3723237,3723254,3723262,3723279,3723287,3723304,3723312,3723329,3723337,3723354,3723362,3723379,3723387,3723404,3723412,3723429,3723437,3723454,3723462,3723479,3723487],"lengths":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]},"words":{"starts":[5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6068,6068,6068,6068,6068,6068,6068,6068,6068,6068,6068,6068,6068,6068,6068,6068,6068,6068,6068,6068,6068,6068,6068,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6108,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6353,6353,6353,6353,6353,6353,6353,6353,6353,6353,6353,6353,6353,6353,6353,6353,6353,6353,6353,6353,6353,6353,6353,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6537,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6570,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6623,6665,6665,6665,6665,6665,6665,6665,6665,6665,6665,6665,6665,6665,6665,6665,6665,6665,6665,6665,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6829,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914],"lengths":[22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]}},"suspected":{"chars":{"starts":[2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2198,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2277,2361,2361,2361,2361,2361,2361,2361,2361,2361,2361,2361,2361,2361,2361,2361,2361,2361,2361,2361,2361,2361,2361,2361,2385,2385,2385,2385,2385,2385,2385,2385,2385,2385,2385,2385,2385,2385,2385,2385,2385,2385,2385,2385,2385,2429,2429,2429,2429,2429,2429,2429,2429,2429,2429,2429,2429,2429,2429,2429,2429,2429,2429,2429,2453,2453,2453,2453,2453,2453,2453,2453,2453,2453,2453,2453,2453,2453,2453,2453,2453,2453,2453,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2516,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2615,2708,2708,2708,2708,2708,2708,2708,2708,2708,2708,2708,2708,2708,2708,2708,2708,2708,2708,2708,2708,2708,2708,2708,2770,2770,2770,2770,2770,2770,2770,2770,2770,2770,2770,2770,2770,2770,2770,2770,2770,2794,2794,2794,2794,2794,2794,2794,2794,2794,2794,2794,2794,2794,2794,2794,2794,2794,2794,2794,2794,2794,2794,2794,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,2988,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3050,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3356,3511,3511,3511,3511,3511,3511,3511,3511,3511,3511,3511,3511,3511,3511,3511,3511,3511,3511,3511,3511,3511,3511,3511,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3720,3795,3795,3795,3795,3795,3795,3795,3795,3795,3795,3795,3795,3795,3795,3795,3795,3795,3795,3795,3795,3795,3795,3795,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3819,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3883,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,3971,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4173,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4260,4350,4350,4350,4350,4350,4350,4350,4350,4350,4350,4350,4350,4350,4350,4350,4350,4350,4350,4350,4350,4350,4350,4350,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4412,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4584,4858,4858,4858,4858,4858,4858,4858,4858,4858,4858,4858,4858,4858,4858,4858,4858,4858,4858,4858,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5049,5155,5155,5155,5155,5155,5155,5155,5155,5155,5155,5155,5155,5155,5155,5155,5155,5155,5155,5155,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5225,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5311,5466,5466,5466,5466,5466,5466,5466,5466,5466,5466,5466,5466,5466,5466,5466,5466,5466,5466,5466,5466,5466,5490,5490,5490,5490,5490,5490,5490,5490,5490,5490,5490,5490,5490,5490,5490,5490,5490,5490,5490,5490,5490,5490,5490],"lengths":[45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23]},"words":{"starts":[334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,334,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,361,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,416,416,416,416,416,416,416,416,416,416,416,416,416,416,416,416,416,416,416,428,428,428,428,428,428,428,428,428,428,428,428,428,428,428,428,428,428,428,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,452,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,524,524,524,524,524,524,524,524,524,524,524,524,524,524,524,524,524,524,524,524,524,524,524,548,548,548,548,548,548,548,548,548,548,548,548,548,548,548,548,548,560,560,560,560,560,560,560,560,560,560,560,560,560,560,560,560,560,560,560,560,560,560,560,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,604,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,624,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,722,722,722,722,722,722,722,722,722,722,722,722,722,722,722,722,722,722,722,722,722,722,722,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,768,797,797,797,797,797,797,797,797,797,797,797,797,797,797,797,797,797,797,797,797,797,797,797,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,809,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,864,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,923,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,959,994,994,994,994,994,994,994,994,994,994,994,994,994,994,994,994,994,994,994,994,994,994,994,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1066,1132,1132,1132,1132,1132,1132,1132,1132,1132,1132,1132,1132,1132,1132,1132,1132,1132,1132,1132,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1152,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188,1231,1231,1231,1231,1231,1231,1231,1231,1231,1231,1231,1231,1231,1231,1231,1231,1231,1231,1231,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1255,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1291,1332,1332,1332,1332,1332,1332,1332,1332,1332,1332,1332,1332,1332,1332,1332,1332,1332,1332,1332,1332,1332,1344,1344,1344,1344,1344,1344,1344,1344,1344,1344,1344,1344,1344,1344,1344,1344,1344,1344,1344,1344,1344,1344,1344],"lengths":[22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]}}},"minorChanges":{"groupId":[33,33,34],"source":{"chars":{"starts":[3678424,3678487,3697281],"lengths":[2,5,7]},"words":{"starts":[5828,5828,6433],"lengths":[1,1,0]}},"suspected":{"chars":{"starts":[2247,2247,3942],"lengths":[8,8,3]},"words":{"starts":[358,358,860],"lengths":[1,1,0]}}},"relatedMeaning":{"groupId":[35,35,35],"source":{"chars":{"starts":[3697316,3697345,3697353],"lengths":[9,1,7]},"words":{"starts":[6434,6434,6434],"lengths":[1,1,1]}},"suspected":{"chars":{"starts":[3952,3952,3952],"lengths":[17,17,17]},"words":{"starts":[862,862,862],"lengths":[1,1,1]}}}}},"version":3}