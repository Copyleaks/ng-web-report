{"statistics":{"identical":648,"minorChanges":2,"relatedMeaning":1},"text":{"comparison":{"identical":{"source":{"chars":{"starts":[40213,40237,40311,40420,40611,40799,40895,40990,41068,41248,41353,41456,41669,41963,42442,42638,42662,42850,42971,43112,43235,43295,43389,43581,43914,44091,44115,44189,44271,44295,44443,44467,44660,44751,45050,45074,49931,58181,58259,63095,78554],"lengths":[23,21,25,27,23,21,19,19,37,35,17,53,57,33,23,23,37,37,55,53,19,27,29,61,35,23,19,35,23,19,23,29,19,21,23,27,49,47,37,31,61]},"words":{"starts":[5805,5817,5835,5866,5907,5943,5963,5982,5999,6044,6080,6096,6135,6198,6280,6311,6323,6374,6400,6436,6473,6489,6515,6558,6635,6684,6696,6714,6740,6752,6779,6791,6841,6862,6914,6926,8154,10008,10036,11091,14840],"lengths":[11,10,12,13,11,10,9,9,18,17,8,26,28,16,11,11,18,18,27,26,9,13,14,30,17,11,9,17,11,9,11,14,9,10,11,13,21,19,13,11,26]}},"suspected":{"chars":{"starts":[557,630,654,719,806,891,939,963,1026,1102,1283,1346,1432,1545,1715,1787,1937,2113,2182,2344,2430,2454,2520,2628,2799,2847,2895,2919,3000,3088,3248,3306,3389,3413,3485,3550,2713,2271,1868,774,1602],"lengths":[23,21,25,27,23,21,19,19,37,35,17,53,57,33,23,23,37,37,55,53,19,27,29,61,35,23,19,35,23,19,23,29,19,21,23,27,49,47,37,31,61]},"words":{"starts":[81,105,117,135,169,200,218,230,252,281,340,364,398,443,505,527,576,634,658,714,747,759,777,812,884,908,924,936,960,993,1038,1062,1094,1106,1130,1151,848,690,552,157,464],"lengths":[11,10,12,13,11,10,9,9,18,17,8,26,28,16,11,11,18,18,27,26,9,13,14,30,17,11,9,17,11,9,11,14,9,10,11,13,21,19,13,11,26]}}},"minorChanges":{"source":{"chars":{"starts":[43030,44225],"lengths":[7,2]},"words":{"starts":[6429,6732],"lengths":[0,0]}},"suspected":{"chars":{"starts":[2240,2955],"lengths":[5,3]},"words":{"starts":[687,954],"lengths":[0,0]}}},"relatedMeaning":{"source":{"chars":{"starts":[43104],"lengths":[7]},"words":{"starts":[6435],"lengths":[0]}},"suspected":{"chars":{"starts":[2330],"lengths":[13]},"words":{"starts":[712],"lengths":[1]}}}},"value":"Implementing Type-Based Deforestation\nby Marie-Christine (Kirsten) Chevalier\n\nResearch Project\nSubmitted to the Department of Electrical Engineering and Computer Sciences, University\nof California at Berkeley, in partial satisfaction of the requirements for the degree of Master\nof Science, Plan II.\nApproval for the Report and Comprehensive Examination:\nCommittee:\n\nProfessor A. Aiken\nResearch Advisor\n\n(Date)\n*******\n\nProfessor R. Fateman\nSecond Reader\n\n(Date)\n\n2\n\nContents\n1 Introduction to Deforestation\n1.1 What Is Deforestation? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1.2 Previous Work On Deforestation . . . . . . . . . . . . . . . . . . . . . . . . .\n1.2.1 Deforestation in Other Languages . . . . . . . . . . . . . . . . . . . .\n1.2.2 Wadler’s Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1.2.3 Shortcut Deforestation . . . . . . . . . . . . . . . . . . . . . . . . . .\n1.2.4 Warm Fusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1.2.5 Vanish Combinators . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1.2.6 Destroy/Unfoldr . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n5\n5\n7\n7\n8\n9\n11\n12\n13\n\n2 The Type Inference Algorithm for Deforestation\n2.1 Inlining and Deforestation . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.2 List Abstraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.3 Type-Based Inlining . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.4 Worker/Wrapper Splitting . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.5 The Type Inference Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.6 Type-Based Deforestation . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.6.1 Abstracting Over Multiple Lists . . . . . . . . . . . . . . . . . . . . .\n2.6.2 Polymorphically Recursive Worker Definitions . . . . . . . . . . . . .\n2.7 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n15\n15\n15\n16\n18\n19\n20\n21\n21\n22\n\n3 Implementing the Type Inference Algorithm\n3.1 GHC and External Core . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3.2 Implementation Details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3.2.1 Specializing Polymorphic Functions . . . . . . . . . . . . . . . . . . .\n3.2.2 List Abstraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3.2.3 Applying the Shortcut . . . . . . . . . . . . . . . . . . . . . . . . . .\n3.2.4 Eliminating Inefficient Workers . . . . . . . . . . . . . . . . . . . . .\n\n23\n23\n25\n26\n26\n29\n30\n\n4 Experimental Results\n4.1 The Nofib Suite . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n4.2 Experimental Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n4.3 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n4.4 Comparison with GHC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n4.5 Deforestation Can Make Performance Worse . . . . . . . . . . . . . . . . . .\n4.6 Measuring Lists Allocated . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n33\n33\n33\n34\n35\n36\n38\n\n4\n\nCONTENTS\n\n5 Conclusions and Future Work\n5.1 Type-Based Deforestation Is Effective . . . . . . . . . . . . . . . . . . . . . .\n5.2 Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n5.2.1 Integration with GHC . . . . . . . . . . . . . . . . . . . . . . . . . .\n5.2.2 Arbitrary Data Structures . . . . . . . . . . . . . . . . . . . . . . . .\n5.2.3 Programmer Annotations . . . . . . . . . . . . . . . . . . . . . . . .\n\n41\n41\n41\n41\n41\n42\n\nChapter 1\nIntroduction to Deforestation\nDeforestation is a program transformation to eliminate trees. It is usually applied to lazy\nfunctional languages, where it is important to efficiently compile common programming idioms that, if compiled naïvely, allocate excessive amounts of space at runtime. In this report,\nwe discuss some of the previous approaches to deforestation, followed by the type inference\nalgorithm for deforestation, which is our focus. After outlining the algorithm, we discuss\nour implementation of it in the Glasgow Haskell Compiler and the experimental results. We\nfound that type-based deforestation decreases the amount of memory allocated by a significant percentage of benchmark programs. We conclude that type-based deforestation can be\neffective when applied to real Haskell programs.\n\n1.1\n\nWhat Is Deforestation?\n\nIn functional languages, and particularly in lazy functional languages, programmers often\nstructure their programs as collections of many small functions that communicate with each\nother by means of intermediate data structures. The advantages of this style of programming\nhave been touted by advocates of lazy functional languages: elegance, improved program\nunderstandability and maintainability resulting from modularity, and separation of control\nflow from essential computation [Hug89]. On the latter point, consider writing a function\nthat constructs a list of numbers from 1 to n. In a strict language, this would have to be\ndone using a loop or recursion that checks whether the upper limit n has been reached, and\nincrements the index variable on each iteration, as in this Haskell function:\nintsTo n = intsFromTo 1 n\nwhere intsFromTo m n =\n(if (m == n) then\n[]\nelse\n(m:(intsFromTo (m+1) n)))\nThe essential computation (consing m on to the front of the list) is intermingled with control\nflow code (the if statement and the recursive call to intsFromTo. In contrast, the following\nequivalent Haskell function is more typical of the lazy language approach:\nintsTo n = take n ints\n\n6\n\nCHAPTER 1. INTRODUCTION TO DEFORESTATION\nwhere ints n = n:(ints (n+1))\n\nHere, the control flow, encapsulated in the call to (take n), is separated from the basic\ncomputation, performed by the auxiliary function ints. This definition of intsTo is more\nconcise and easier to understand than the first one, and these differences are even more\nnoticeable on a larger scale. However, the second definition constructs an intermediate data\nstructure: the list ints. Of course, the entire infinite list is not constructed, but as each\nelement of the list is demanded by the call to take, a new list cell is constructed and its\ncontents are copied into the result list, the list that is returned as the result of the call to\nintsTo. Allocating memory for these list cells takes time and resources, particularly since\nthey need to be garbage collected later. The first definition only creates one list: the list it\nreturns as its result.\nFor a slightly more complicated example, consider writing a function to return the sum of\nthe squares of the numbers between m and n. A straightforward recursive definition is as\nfollows:\nsos m n =\nif (m == n) then\n0\nelse\n(square m) + (sos (m+1) n)\nA more typical Haskell definition:\nsos m n = sum (map square [1..n])\n(The Haskell syntax [m..n] is syntactic sugar for a call to the function enumFromTo with\narguments m and n, which constructs the list of integers from m to n.) This definition is more\nconcise and easier to understand, as it uses existing higher-order functions (map, and foldr,\nwhich is used in the definition of sum and which we will examine more closely later). However,\nit creates two intermediate lists: [1..n] and (map square [1..n]), which is strange for\na function that solves a problem having nothing to do with lists on the surface. Actually,\nlaziness means that neither list is constructed explicitly all at once – each cell is created when\nit is demanded by sum or map, then freed – but again, the extra work necessary to allocate\nand garbage-collect these structures still makes a significant difference in performance. In\nfact, the first definition doesn’t execute in constant space either, because of the recursive\ncall to sos in non-tail position, but it is easy to see how to write a tail-recursive equivalent,\nwhereas this doesn’t apply to the second definition, since it contains no explicit recursion.\nWe would like the compiler to automatically transform definitions like the second definition\nof sos into a form closer to the form of the first definition above. An omniscient compiler\ncould optimize either of these definitions even further by replacing the recursive computation\nwith the non-recursive formula for the sum of the squares between m and n. However, this\ngoes beyond the scope of the kinds of optimizations most compilers attempt to do, so we\nsettle for a definition that, while not optimal, allocates less memory than the original does.\nDeforestation, a program transformation to eliminate trees, can achieve this goal of automatically transforming modular code into monolithic code. As originally stated, deforestation\ncan be applied to eliminating arbitrary data structures defined by Haskell-style algebraic\ndatatype declarations, but most work on deforestation has concentrated on eliminating lists,\nand list deforestation will be the focus of this report.\n\n1.2. PREVIOUS WORK ON DEFORESTATION\n\n1.2\n\n7\n\nPrevious Work On Deforestation\n\nDeforestation was originally described by Wadler in [Wad90], in which he coined the term\n“deforestation” for a program transformation to eliminate trees. As originally presented,\ndeforestation extended on Wadler’s “listlessness transformer”, [Wad85], a more limited deforestation algorithm that handled functions that manipulate lists rather than arbitrary\ntrees. This work in turn can be traced back to the more general program transformation\nframework described in [BD77]. Most work on deforestation has been done in the context of\npure, lazy functional languages (usually, Haskell), with a few exceptions.\n\n1.2.1\n\nDeforestation in Other Languages\n\nThere are two notable techniques, both of which predate most of the work on deforestation\nper se, that are similar to deforestation but apply to strict and impure languages. The first\nconcerns the efficient compilation of operations on arrays, the principal aggregate datatype\nin APL. [GW78] and [BT84] describe how compositions of operators drawn from a limited\nsubset of APL’s array-transforming operators can be transformed into a single operator,\navoiding multiple traversals of the same array. This work was more restricted than deforestation: it could only handle compositions of a few built-in functions, and each of these\nfunctions had to both consume and produce an array (unlike deforestation, in which functions\nmay consume a list but produce a value of a different type, and vice versa). Nevertheless,\nit was practical (exhibited by the fact that it was implemented in working APL compilers),\nand it is likely that most array expressions in APL were simple enough to be optimized by\neven this restricted algorithm.\nA somewhat more general technique is that of series expressions, which Waters discusses\nmainly in the context of Lisp, though a prototype version was also implemented for Pascal\n[Wat89]. A major advantage of this approach over all the other deforestation methods we\nconsider here is predictability: the compiler guarantees that all compositions of functions\noperating on the “series” datatype (analogous to the list type) will be deforested as long\nas certain constraints are satisfied, and warns the user about series expressions that cannot\nbe optimized. This is accomplished by adding the series as a new datatype, isomorphic\nto but distinct from lists (except that they are evaluated lazily), and providing a set of\nuseful operations for series (similar to the usual higher-order list functions provided by\nHaskell). Making series a distinct type allows a fairly simple, dataflow-based algorithm for\ndeforestation to be employed. It seems advantageous for the user to receive feedback from the\ncompiler about which expressions are and are not deforested, but on the other hand, creating\na new type that must be used wherever the programmer wishes deforestation to occur has\ndisadvantages. First, deforestation can never be performed unless the programmer writes\nher program in the specific style required for deforestation. Second, series must be coerced\ninto lists whenever the programmer wishes to use existing list operations on them, and this\nmay entail some inefficiency. Writing programs in the style required for deforestation does\nnot seem to be a very large burden; the restrictions it places on program form are similar\nto those imposed by other deforestation techniques, though here they are expressed in a\nsomewhat different way. Essentially, series must be consumed and produced in a uniform\nway, and series arguments to functions may not be used more than once. These are analogous\nto Wadler’s restrictions (see Section 1.2.2), but notably, Waters lifts the restriction that an\n\n8\n\nCHAPTER 1. INTRODUCTION TO DEFORESTATION\n\nexpression which is to be deforested must consist of compositions of functions that do not\nthemselves create intermediate data structures. This work has been implemented as a library\nfor Common Lisp [Ste90], and has been used in developing practical applications in Lisp.\nIt is interesting to contrast these two techniques with the work on deforestation in Haskell.\nBoth techniques are more limited, but have greater practical use to their credit – only\nrecently has deforestation been implemented in a usable and practical way in a Haskell\ncompiler [PJTH01]. They must impose certain restrictions due to their target languages,\nAPL and Lisp, being impure – the APL work is limited to compositions of operators drawn\nfrom a set of non-side-effecting functions, and the Lisp work uses a special type to ensure the\ncorrect deforestation of side-effecting expressions. In addition, both approaches are limited\nto linear data structures rather than general trees. However, both approaches seem to be\nwell-suited to handle the most common programming idioms in their respective languages,\nand are similar to shortcut deforestation for Haskell (see Section 1.2.3) in that the simplicity\nof their implementations relies on programmers’ use of a predefined set of combinators.\n\n1.2.2\n\nWadler’s Algorithm\n\nWadler’s algorithm attempts to handle programs like the modular definition of sos given\nabove that consist of compositions of several functions that consume or produce lists (actually, the algorithm applies to general tree-shaped data structures, but to simplify the\npresentation we will restrict it to lists here). More specifically, these functions must be in\ntreeless form, and fortunately, the functions sum, map, and enumFromTo can all be defined in\nthis form.\nTreeless form can be defined for a simple language consisting of variable references, data\nconstructor applications, function applications, and case-expressions as follows: A term is\ntreeless if:\n• Every argument of a function application and every scrutinee of a case-expression is\na variable.\n• All variables are linear – that is, used only once in the function where they are defined.\nThe first restriction ensures that the definition creates no intermediate data structures (function or constructor applications, which create data structures, may only appear as the result\nof the function – such an expression being examined by case or passed to another function implies creating a data structure that is not part of the result). The second restriction\nensures that inlining functions, an essential step of the deforestation algorithm, will not\nduplicate work.\nWadler’s algorithm can transform any composition of treeless functions to a single, treeless\nfunction. The algorithm consists of a number of transformation rules, but the most important\none is the case-elimination rule, as follows:\ncase (c t_1 ... t_k) of\n(c_1 v_1..v_n) -> e_1\n[...]\n(c_n v_1..v_n) -> e_n\n===>\n\n1.2. PREVIOUS WORK ON DEFORESTATION\n\n9\n\ne_i[t_1/v_1, ... , t_k/v_n]\nwhere c = c_i\nIn words, this rule takes a case-expression where the scrutinee is an explicit application of a\ndata constructor to some arguments. The case-expression has several alternatives, each corresponding to a particular data constructor in the type that c constructs. In this situation,\nwe already know which data constructor constructs the scrutinee of the case-expression, so\nwe can eliminate the case and replace it with the body of the relevant alternative, substituting the constructor arguments for the variables introduced by the case-pattern. This rule\nperforms deforestation: it eliminates an application of a constructor (c), which previously\ncreated an intermediate data structure.\nThe other transformation rules all attempt to get the program into a form where this rule\ncan be applied. For example, another rule performs inlining, or replacing a function call with\nthe function’s body, with the function’s arguments substituted for the formal parameters.\nThis illustrates the need for the linearity requirement as part of the definition of treeless\nform: under call-by-name evaluation, inlining a function that uses one of its arguments\nmore than once will duplicate work if the expression passed in for said argument is used\nmore than once. Inlining is necessary in order to bring function definitions together with\ntheir arguments: for example, without inlining, we wouldn’t be able to deforest the sumof-squares program, (sum (map square (enumFromTo [1..n]))). There are no explicit\ncase-expressions in the program as is, but if the definitions of sum, map, and enumFromTo\nare inlined, then opportunities to apply the case-elimination rule will appear.\nWadler’s algorithm has not been widely used in practice, due partly to its restrictiveness. For\nexample, the definition of treeless form given above excludes the definition of enumFromTo,\nbecause it creates an intermediate “tree” – (m+1)! It is possible to modify the definition so\nthat certain data types, such as integers, are not considered “trees” and so can be created by\ntreeless functions, but this only complicates things more. Moreover, there are compositions\nof functions we wish to deforest where the functions cannot or are not expressed in treeless\nform (Wadler’s algorithm doesn’t attempt to convert function definitions that are not in\ntreeless form, but could be rewritten in treeless form, into treeless form). Also, it is difficult to\nimplement the algorithm in a way that guarantees termination. However, Wadler’s algorithm\nhas served as inspiration for further research on deforestation.\n\n1.2.3\n\nShortcut Deforestation\n\nWhereas Wadler’s algorithm attempts to eliminate any list structures that are examined by\ncase-expressions, it is possible to simplify the approach by observing that many functions\nthat consume lists are defined in terms of the function foldr. Figure 1.1 illustrates the\nbehavior of foldr.\nIn this example, the application of foldr to the function (+), the starting value 0, and the\nlist [3, 4, 5] replaces all the cons ((:)) constructors in the list with the function (+), and\nall the nil ([]) constructors with the value 0. Evaluating the resulting expression gives 3 +\n4 + 5 = 12. In general, foldr consumes a list and produces an expression of type β, given\na function argument of type α− > β− > β, a nil value of type β, and a list of type [α].\nThe shortcut rule [GLP93] is inspired by this observation about foldr. On first glance, it\nseems easy to deforest applications of foldr. Since the first two arguments of foldr, k and\n\n10\n\nCHAPTER 1. INTRODUCTION TO DEFORESTATION\n\n:\n3\n\n+\n\n=>\n\n:\n4\n\n3\n4\n\n:\n5\n\n+\n\n[]\n\n+\n5\n\n0\n\nFigure 1.1: (foldr (+) 0 [3, 4, 5])\nz, replace (:) and [] in the list expression, if we see an application (foldr k z e), we can\njust replace every occurrence of (:) in e with k and every occurrence of [] with z. Indeed,\nthis works in simple cases (in the following example, the constant list is written using explicit\n(:)s and []s rather than Haskell’s syntactic sugar for lists):\nfoldr (+) 0 (1:(2:(3:[])))\n==>\n(1 + (2 + (3 + 0)))\n==>\n6\nwhich eliminates the intermediate list [1,2,3]. However, consider another example (++ is\nthe function which appends two lists):\nfoldr (+) 0 ([1,2] ++ [3,4])\n==> (inlining (++) and simplifying)\nfoldr (+) 0\n(let append xs ys =\ncase xs of\n[] -> ys\n(x:xs’) -> x:(append xs’ ys) in\nappend [1,2] [3,4])\n==>\nlet append xs ys =\ncase xs of\n[] -> ys\n(x:xs’) -> x + (append xs’ ys)\nThis code is not even type-correct, since it returns a list value in the [] case alternative,\nbut an integer in the other alternative. The problem is that (++) constructs its result\n\n1.2. PREVIOUS WORK ON DEFORESTATION\n\n11\n\npartially from list constructors in its second argument list, ys, and not just from explicit list\nconstructors. Consequently, in order to create a sound rule for deforestation using foldr,\nwe must introduce some extra syntactic complications.\nAny list-producing function that constructs its result using only explicit list constructors can\nbe written in terms of “abstract constructors” – for example, the recursive definition of map:\nmap f xs =\ncase xs of\n[] -> []\n(y:ys) -> (f y):(map f ys)\ncan be written with two extra arguments, c and n, as:\nmap c n f xs =\ncase xs of\n[] -> n\n(y:ys) -> (c (f y) (map c n f ys))\nThe type of this version of map is forall a b c . (c -> b -> b) -> b -> (a -> b) ->\n[a] -> b. Thus, it can construct a value of any type, depending on the types of the c and\nn it is applied to.\nTo complete the picture, we define a function build, which takes a “generalized list producer” like the second definition of map given above, and applies it to (:) and [], in effect\ntransforming a generalized list producer back into a regular list producer:\nbuild g = g (:) []\nNow we can finally define the shortcut rule:\nfoldr k z (build g) = g k z\nThe list eliminated is the list constructed by (build g): the result of the foldr is now\nconstructed directly by g, without the intermediate list resulting from the application of\nbuild.\nThough the shortcut rule is simple, its practical effectiveness depends on other transformations, such as inlining the bodies of functions that use foldr and build in order to bring\nfoldrs and builds together. Moreover, it depends on programmers’ willingness to define\ntheir list-producing functions using build, which is likely to be low, since build serves no\npurpose except to help out the deforestation algorithm by pointing out which list constructors construct the result list. The shortcut rule has been effective when commonly used\nlibrary functions are defined in terms of foldr and build; [PJTH01] describes the implementation of the shortcut rule that is currently used in the Glasgow Haskell Compiler, based\non rewrite rules. However, it is unlikely that shortcut deforestation by itself could ever be\neffective for deforestating compositions of user-defined functions.\n\n1.2.4\n\nWarm Fusion\n\nIn [LS95], Launchbury and Sheard present a method for automatically transforming arbitrary\nrecursive definitions into foldr/build form, a technique they call “warm fusion” (“fusion” is\n\n12\n\nCHAPTER 1. INTRODUCTION TO DEFORESTATION\n\nanother name for deforestation). Like Wadler’s algorithm, warm fusion is applicable to\narbitrary data types (since versions of foldr and build can be expressed for any algebraic\ndatatype), but we concentrate on list fusion here. The algorithm for warm fusion consists\nof two stages. In the first stage, function definitions are rewritten using foldr and build.\nGiven a definition of a list-producing function f, this rewriting is easy to do:\nf = \\ l -> body -- where body is some expression containing l\n==>\nf = \\ l -> build (\\ c n ->\nfoldr c n body[(foldr (:) [] l)/l])\nFirst of all, the entire function body is changed into a generalized list producer, which is easy\nto do: the existing function body is a list, so we just apply (foldr c n), where c and n are\nthe arguments that replace the list constructors, to the list. We apply build to the resulting\nexpression so that the function definition still returns a list-valued expression. Finally, in the\noriginal body of the function, we substitute (foldr (:) [] l) for any occurrences of the\nlist argument l. ((foldr (:) []) is equivalent to the identity function on lists.) The hope\nis that when we apply the next stage of warm fusion, the foldrs and builds we introduced\nhere will meet with other foldrs and builds and cancel by the shortcut rule.\nIn addition, certain list-consuming functions are also automatically rewritten in terms of\nfoldr. This only works for functions in which the outermost case expression deconstructs\nsome list-valued argument. Since many functions that consume lists are expressed in terms of\npattern-matching, with one case for the empty list and another case for a list consisting of an\nelement consed onto a list, the method is widely applicable. More precisely, it applies to some\ndefinitions which recurse uniformly over their list arguments. Essentially, the outermost case\nis replaced with an application of foldr whose first two arguments correspond to the (:)\nand [] alternatives of the case. For example, the recursive definition of map is transformed\nas follows:\nmap = \\x . \\f.\ncase x of\n[] -> []\n(y:ys) -> (f y):(map ys f)\n==>\nmap = \\x. \\f. foldr ((\\ x1 x2 f -> (f x1):x2) f) [] x\nNow that list-consuming functions are expressed in terms of foldr and list-producing functions are expressed in terms of build and foldr, fusion can proceed. In particular, compositions of functions that are defined in terms of foldr can be fused together into single\nfunctions, and using a system of rewrite rules, foldrs are brought together with builds and\nthe shortcut rule is applied.\nWarm fusion is quite complicated and expensive to implement, and is not widely used in\nreal compilers.\n\n1.2.5\n\nVanish Combinators\n\nIn [Voi02], Voigtlander presents an approach to deforestation which extends the shortcut\nrule to deforest certain combinations of list functions, essentially by treating these functions\n\n1.2. PREVIOUS WORK ON DEFORESTATION\n\n13\n\nas additional constructors for the list datatype. Since this method is closely related to the\ntype inference algorithm, we will defer discussion of it until Chapter 2.\n\n1.2.6\n\nDestroy/Unfoldr\n\nThere are some list functions that cannot be expressed in terms of foldr and build. Among\nthese, of course, are functions that do not express patterns of regular recursion over lists.\nBut there are other such functions as well. For example, consider the function zip, which\ntakes two lists [x1,..,xn] and [y1,..,yn] and returns the list [(x1,y1),..,(xn,yn)]:\nzip xs ys =\ncase xs of\n[] -> []\n(z:zs) -> case ys of\n[] -> []\n(z’:zs’) -> (z,z’):(zip zs zs’)\nWe would like to deforest expressions where zip is the list consumer, such as (zip [1..n]\n(map square [1..n])). However, zip cannot be defined in terms of foldr, since it does\nnot express a pattern of recursion over a single list. On the other hand, it can be expressed\nin terms of two functions called destroy and unfoldr [Sve02].\nThe function unfoldr constructs lists in a way analogous to the way in which foldr consumes\nlists. It takes a function f and a starting value b, and computes each successive element\nof the result list by applying f to the previous list element. f actually returns a value of\ntype Maybe: either it returns (Just (a,b’)), signifying that a should be consed on to the\nresult of recursively calling unfoldr on b’, or Nothing, signifying the end of the list. The\ndefinition follows:\nunfoldr f b =\ncase f b of\nNothing -> []\nJust (a,b’) -> (a:(unfoldr f b’))\nFor example, the enumFromTo function can be defined this way:\nenumFromTo m n =\nunfoldr (\\ x -> (if (x < n) then\nJust (x,x+1)\nelse\nNothing)) m\nThe function destroy, like foldr, consumes lists in a regular fashion. It takes a function\nargument g and a list argument xs, but the function g cannot examine xs directly. It can\nonly do so via a helper function that is supplied to it:\ndestroy g xs = g listpsi xs\nwhere listpsi [] = Nothing\nlistpsi (x:xs) = Just (x,xs)\n\n14\n\nCHAPTER 1. INTRODUCTION TO DEFORESTATION\n\nFor example, sum can be defined this way:\nsum xs = destroy sumDU xs\nwhere sumDU listpsi xs =\ncase (listpsi xs) of\nNothing -> 0\nJust (x1,xs1) -> x + (sumDU listpsi xs1)\nCertain functions, such as zip, can be defined in terms of destroy/unfoldr but not in terms\nof foldr/build. Other functions can be defined in terms of either. There is a fusion rule for\ndestroy/unfoldr analogous to the shortcut rule:\ndestroy g (unfoldr psi e) ==> g psi e\nMuch as the shortcut rule eliminates the intermediate list constructed by build, this rule\neliminates the intermediate list constructed by unfoldr.\nLike shortcut deforestation, this approach has the problem that programmers may not write\ntheir functions in terms of destroy and unfoldr, to an even greater extent, since foldr is a\ncommonly used function, but destroy and unfoldr are little-known. Moreover, it is unclear\nhow to combine the foldr/build rule with the destroy/unfoldr rule, since some functions can\nbe defined either way, and it is unclear how to choose which one. This approach may be\neffective if library functions are defined in terms of destroy and unfoldr, but we still lack an\neffective approach for deforesting compositions of user-defined functions. The type inference\nalgorithm for deforestation is effective for deforesting compositions of user-defined functions.\n\nChapter 2\nThe Type Inference Algorithm for\nDeforestation\n2.1\n\nInlining and Deforestation\n\nAll of the deforestation algorithms discussed in the previous chapter require some amount\nof inlining to be effective. However, inlining is a “black art”; when implemented in a practical compiler, many subtle heuristics are involved in determining whether to inline a given\nfunction (see for example [PJM99]). If inlining is performed indiscriminately, the size of\nthe resulting program can blow up exponentially, resulting in worse performance. Moreover,\ninlining certain expressions indiscriminately can result in work duplication, so the compiler\nmust be careful to conservatively determine which expressions may be used more than once.\nFor the purposes of – for example – shortcut deforestation, we would like a method for inlining which inlines exactly those functions which need to be inlined in order for foldrs to\nmeet builds. The type inference algorithm for deforestation addressed this issue, and was\noriginally motivated by the problem of inlining. Inlining is integrated with the deforestation\nalgorithm itself, and both make use of the same type information.\n\n2.2\n\nList Abstraction\n\nThe algorithm that follows was originally presented by Chitil in [Chi99]. It is based on\nthe observation that many list-consuming functions are already defined in terms of foldr,\nso it is less important to derive foldr forms for list consumers than build forms for list\nproducers. The basic idea is to replace the list constructors in a function definition (assuming\nthe function produces a single list) with variables c and n, and turn the definition into an\nabstraction over c and n, then applying build to it so it still produces a list. However, this\ncannot be done indiscriminately, since the function may not construct its result by using\nexplicit list constructors (if it does not, then we cannot transform it into a generalized list\nproducer without performing other transformations first), and not all list constructors in\nthe function necessarily contribute to the result. Type inference can determine whether it is\npossible to transform the function into a generalized list producer, and which constructors\nshould be abstracted over if so.\nWe will illustrate the list abstraction algorithm with an example. Consider the following\n\n16CHAPTER 2. THE TYPE INFERENCE ALGORITHM FOR DEFORESTATION\ndefinition of map, written with explicit type annotations on all variables:\nmap :: forall a b . (a -> b) -> [a] -> [b]\nmap @a @b (f::(a -> b)) (xs::[a]) =\ncase (xs::[a]) of\n([]::[a]) -> []\n((y::a):(ys::[a])) -> (f y):(map @a @b f ys)\nWe replace every list type with a new type variable, and every list constructor with a new\nterm variable:\nmap :: forall a b . (a -> b) -> t1 -> t2\nmap @a @b (f::(a -> b)) (xs::t3) =\ncase (xs::t4) of\n([]::t5) -> n\n((y::a):(ys::t6)) -> (c (f y) (map @a @b f ys))\nPerforming type inference on this expression reveals that although t1 is really the same\nas [a] due to the case expression, t2 is unconstrained, and hence this definition can be\nturned into a generalized list producer. Moreover, n and c have types t2 and b -> t2 ->\nt2, respectively. (The details of type inference are explained later.) So we can construct the\nfollowing definition of map:\nmap :: forall a b t . (b -> t -> t) -> t -> (a -> b) -> [a] -> t\nmap @a @b @t (c::(b -> t -> t)) (n::t) (f::(a -> b)) (xs::[a]) =\ncase (xs::[a]) of\n([]::[a]) -> n\n((y::a)::(ys::[a])) -> (c (f y) (map @a @b @t c n f ys))\nWe can apply build so that it has the same type as before:\nmap :: forall a b . (a -> b) -> [a] -> [b]\nmap @a @b (f::(a -> b)) (xs::[a]) =\nbuild (\\ @t (c::(b -> t -> t)) (n::t) ->\ncase (xs::[a]) of\n([]::[a]) -> n\n((y::a)::(ys::[a])) -> (c (f y) (map @a @b @t c n f ys))\nThis is the basic idea of list abstraction. More complicated cases are addressed later in this\nchapter.\n\n2.3\n\nType-Based Inlining\n\nIn some cases, a function constructs a list by calling another function. This prevents list abstraction, as described above, from occurring. For example, consider the following function,\nwhich constructs the list of squares from 1 to n:\nsquares n = map square (enumFromTo 1 n)\n\n2.3. TYPE-BASED INLINING\n\n17\n\nIt is obvious that list abstraction fails in this case, because type inference determines that the\nbody of squares has type [Int], based on the type of map in the global type environment.\nWe need to inline the bodies of map and enumFromTo in order to perform list abstraction on\nthe body of mapsquares. We accomplish this by replacing list types with new type variables\nin the types of map and enumFromTo in the type environment. In order to do this properly,\nwe must use versions of map and enumFromTo that are specialized to type Int (the reason\nfor this is explained in the section on the type inference algorithm). So we perform list\nabstraction on the following definition of squares, with the following bindings in the type\nenvironment:\nmapInt :: (Int -> Int) -> t1 -> t2\nenumFromTo :: Int -> Int -> t3\nsquares :: Int -> t4\nsquares (n::Int) = mapInt square (enumFromTo 1 n)\nType inference determines that t4 is unconstrained (and equivalent to t2, the result type of\nmapInt. However, we can’t just construct the list-abstracted definition of squares as is. The\nfact that the type of mapInt given by the type environment contains a free type variable, t2,\nthat was not unified with a list type, tells us that mapInt needs to be inlined. (Note that\nenumFromTo does not need to be inlined, for its result type t3 was unified with a list type\nbecause its result is passed to mapInt, which takes a list.) A future inlining pass will inline\nthe body of mapInt here, giving (after simplification):\nsquares n = (let mapInt xs =\ncase xs of\n[] -> []\n(y:ys) -> (square y):(mapInt ys) in\nmapInt (enumFromTo 1 n))\nWhen list abstraction is applied to this definition, it will successfully create a generalized\nlist producer. Moreover, we have avoided inlining the body of enumFromTo, since doing so is\nnot necessary to abstract over the lists in the definition of squares.\nThe original type-based deforestation algorithm, as presented in [Chi99], is as follows:\n• Find all expressions of the form (foldr k z p).\n• Apply list abstraction, as detailed above, to p in each such expression, giving an expression on the form (foldr k z (build ( c n -> ...)))\n• Apply the shortcut rule in each such case.\nThis algorithm works, but may still increase the size of the program to an undesirable\nlevel. We would hardly want the benefits of deforestation to be cancelled out by worsened\nperformance due to increased program size. Instead of inlining the entire body of each\nfunction that type inference determines is necessary to inline, we can use the approach\ndescribed in the next section.\n\n18CHAPTER 2. THE TYPE INFERENCE ALGORITHM FOR DEFORESTATION\n\n2.4\n\nWorker/Wrapper Splitting\n\nInstead of inlining the entire body of a function, we can split this function into a worker and\na wrapper, where the wrapper is much smaller than the worker. Only the wrapper needs\nto be inlined, so the size of the program will not increase appreciably. This approach is\ndescribed in [Chi00].\nConsider the definition of squares from above. Just as before, type inference will determine\nthat mapInt needs to be inlined. We construct a worker and wrapper for mapInt as follows.\nFirst, we do list abstraction on the body of mapInt, resulting in the following definition (with\nthe bindings for the newly introduced type and term variables omitted):\nmapInt :: (Int -> Int) -> [Int] -> t\nmapInt f xs =\ncase xs of\n[] -> n\n(y:ys) -> c (f y) (mapInt f ys)\nIn order to create the worker/wrapper split, the body of mapInt must be non-recursive. We\ntransform it as follows:\nmapInt :: (Int -> Int) -> [Int] -> t\nmapInt f xs = go xs\nwhere go xs =\ncase xs of\n[] -> n\n(y:ys) -> c (f y) (go ys)\nFinally, we construct the worker, consisting of this function with λ-bindings for t, c, and n,\nand a wrapper which applies the worker to [Int], (:), and []:\nmapInt :: (Int -> Int) -> [Int] -> [Int]\nmapInt f xs = mapIntW @[Int] ((:) Int) ([] Int) f xs\nmapIntW :: forall t . (Int -> t -> t) -> t -> (Int -> Int) -> [Int] -> t\nmapIntW @t c n f xs = go xs\nwhere go xs =\ncase xs of\n[] -> n\n(y:ys) -> c (f y) (go ys)\nWhen processing the body of squares, we only inline mapInt, not mapIntW:\nsquares (n::Int) = (mapIntW @[Int] ((:) Int) ([] Int)) square (enumFromTo 1 n)\nIt is easy to see the result of performing list abstraction on this definition.\nThe method for worker/wrapper splitting given above cannot construct worker/wrapper\ndefinitions that are polymorphically recursive in their constructor arguments – that is, where\narguments other than the original c and n are passed to the recursive call of the worker.\nSome definitions have list-abstracted versions that have this property, although relatively\n\n2.5. THE TYPE INFERENCE ALGORITHM\n\n19\n\nfew of them do. Another method for worker/wrapper splitting which can handle this case is\ndiscussed later.\nNote that worker/wrapper splitting makes it unnecessary to replace type variables in the\ntype environment, as we discussed in the previous section. We can just inline all wrappers\nunconditionally, since they are small and unlikely to lead to code blowup. It is possible to\ncombine the worker/wrapper splitting and type-based inlining approaches, and in fact our\nimplementation does this. To simplify the presentation for now, we will assume that after\nworker/wrapper splitting, wrappers are inlined everywhere (even across module boundaries).\n\n2.5\n\nThe Type Inference Algorithm\n\nHere we discuss the type inference algorithm that is the core of type-based deforestation, as\noriginally presented in [Chi99]. Our examples are presented in Haskell syntax, but keep in\nmind that the underlying language is actually the second-order lambda-calculus with explicit\ntype annotations, extended with let (for introducing mutually recursive groups of function\ndefinitions) and case (for pattern-matching on algebraic datatypes). Type inference for the\nsecond-order λ-calculus is undecidable, but here we have explicit type annotations, which\nmake it possible to perform type inference as needed for deforestation. This is reasonable,\nsince in a compiler we would be performing the type-based deforestation algorithm on code\nthat had been augmented with explicit type annotations in the process of desugaring from\nHaskell to a λ-calculus-based intermediate language. The type inference algorithm is based\non Algorithm M, for the Hindley-Milner type system [LY98], and in fact is so similar to\nAlgorithm M that we will not repeat it here (see [Chi99] for details). The key step is that\nbefore type inference, list types and constructors will have been replaced with new type and\nterm variables.\nGiven a type environment Γ, an expression e, and a type τ , M returns a principal typing\nfor (Γ, e, τ ) – that is, a type substitution mapping some of the type variables in e and τ to\nother types. Essentially, a typing σ for (Γ, e, τ ) is a principal typing if all other typings for\n(Γ, e, τ ) are substitution instances of σ. That is, σ is the “most general” possible typing, in\nthat it avoids putting any unnecessary constraints on type variables occurring in e and τ . In\nan expression where list types and constructors have been replaced with new type variables,\nσ will map some of these variables to [Int], signifying that they really must be list types\n(i.e., because the corresponding values are deconstructed by a case statement or passed to a\nfunction expecting a list). Some type variables may only be mapped to other type variables –\nthese are the type variables that can be abstracted over. Furthermore, constructor variables\nwhose types (after applying the substitution σ) are of the form a -> t -> t (for variables\nthat replaced (:)) or t (for variables that replaced [], where t is a variable introduced by\nlist abstraction, are variables that can be abstracted over. If the result of applying σ to the\ntype of the expression τ (in which list types have been replaced by type variables) is a type\nwhose result is a type variable that was introduced by list abstraction, then list abstraction\nis successful and a worker/wrapper definition for e can be constructed.\n\n20CHAPTER 2. THE TYPE INFERENCE ALGORITHM FOR DEFORESTATION\n\n2.6\n\nType-Based Deforestation\n\nNow all the pieces to present the complete type-based deforestation algorithm (as presented\nin [Chi00]) are in place. The algorithm takes a collection of function definitions as input (for\nnow, consider these to be Haskell definitions; we will be more concrete when we discuss the\nimplementation), and returns a new collection of function definitions, with hope one where\ndeforestation has occurred in some instances.\n1. For each top-level definition (v,ty,e) where ty is either [a], for some a, or a function\ntype whose result is [a], for some a:\n(a) Replace every list type with a fresh type variable, and every occurrence of a list\nconstructor (:) or [] with a fresh term variable (this is detailed below). This\ngives a new expression e’.\n(b) Perform the type inference algorithm on (Γ,e’,ty). (A global type environment\nΓ, containing types for all top-level definitions and any library functions used, is\nassumed to have been constructed at the beginning.) This gives a substitution σ.\n(c) Apply σ to ty. If the result type ty’ contains type variables, we know that it’s\nworthwhile to worker/wrapper split this definition.\n(d) Reinsert any type variables t such that σ(t) = [a] for any a with the original types\nfor which they were replaced. Reinsert any constructor variables c or n whose\ntypes after applying σ result in a list type with the original list constructors for\nwhich they were replaced. This gives a new expression e’’ (This is described in\nmore detail below.)\n(e) e00 may now contain different constructor variables whose types after applying σ\nare the same. Set a “canonical” constructor variable for each type and replace each\nconstructor variable with the canonical constructor variable of its type (detailed\nbelow). This gives a new expression e’’’\n(f) Does ty’ contain type variables in its result? If so:\ni. Construct a new type t’’ = (forall t1 ... tn . ty’), where t1..tn\nare all the free type variables in ty’.\nii. Construct the worker definition by wrapping e’’’ with type and term variable\nbindings for all the free type variables in ty’ and all the constructor variables\nremaining in e’’’, giving a new expression e’’’’.\niii. Generate a fresh name for the worker (here we call it vW). Return a pair of\na wrapper and worker definition, where the wrapper definition is:\n(v, ty, (vW @ t1 ... @ tk c1 n1 ... cn nn))\nwhere t1..tk are the types for which all the new type variables were replaced\nand c1 n1 ...cn nn are the constructors for which all the new constructor\nvariables were replaced. And the worker definition is:\n(vW, t’’, e’’’’).\ni. If not, return the original definition (v,ty,e).\n2. Now we have a collection of definitions that include workers and wrappers, as well as\nsome of the original definitions. (Assume there is a way to tell whether a function\nname represents a worker, a wrapper, or neither.) Inline wrappers everywhere.\n\n2.6. TYPE-BASED DEFORESTATION\n\n21\n\n3. Perform β-reduction where necessary.\n4. The previous two steps may be repeated some number of times, as inlining wrappers\nprovides new opportunities for worker/wrapper splitting.\n5. Find all expressions of the form (foldr k z e). Perform list abstraction on e, just as\npresented above, except that we only try to abstract a single list, and no worker/wrapper\nsplitting is done (list abstraction simply returns what would be the worker definition\notherwise). If it succeeds, we have an expression of the form ( c n -> ...). Return\nthe expression ( c n -> ...) k z. (We are eliding type arguments here.)\n6. Perform β-reduction where necessary.\n7. Repeat the previous steps some number of times, since applying the shortcut rule may\nexpose other opportunities to apply the shortcut rule.\n.\n\n2.6.1\n\nAbstracting Over Multiple Lists\n\nNote that worker/wrapper splitting can produce a worker such that multiple lists are abstracted. For example, when worker/wrapper splitting the definition of unzip, which has\nthe type (forall a b . [(a,b)] -> ([a],[b])), a worker can be derived whose type is\n(forall a b t1 t2 . (a -> t1 -> t1) -> t1 -> (b -> t2 -> t2) -> t2 -> [(a,b)]\n-> (t1,t2)). We only attempt to abstract over multiple lists when doing worker/wrapper\nsplitting. When we invoke the list abstraction algorithm during the deforestation stage, we\nonly construct an abstraction when the result type has a single type variable as its result.\nSo although our worker definition of unzip is such that either list can be removed, at any\nparticular instance where unzip is called, only one list will be removed.\n\n2.6.2\n\nPolymorphically Recursive Worker Definitions\n\nA slight modification of the worker/wrapper splitting algorithm given above is necessary\nto construct polymorphically recursive workers. In essence, we construct the most general\npossible worker type (the type obtained by replacing all list types in the type of the definition\nwith type variables), and construct the wrapper body assuming the worker has this type.\nWe replace any recursive calls to the function with this wrapper body and perform type\ninference, iterating to a fixed point of the result type. If the resulting type contains type\nvariables, we construct the worker definition. (For more details, see [Chi00].) This is the\nmethod used in our implementation. It can occasionally achieve some staggering results, such\nas changing the quadratic time definition of reverse given above to a linear time definition.\nChitil warns that since this can depend on the code being in a particular form, this method\nmay be unpredictable by the programmer, since a small change to the code can suddenly\nturn a linear algorithm into a quadratic one if the code is changed to be in a form that\nour algorithm cannot deforest. Nevertheless, our implementation does this, since it cannot\npossibly make the performance of a particular function worse.\n\n22CHAPTER 2. THE TYPE INFERENCE ALGORITHM FOR DEFORESTATION\n\n2.7\n\nRelated Work\n\nThe technique of Voigtlander [Voi02] seems quite amenable to being combined with typebased deforestation. Rather than attempting to deforest all list-producing functions, this\napproach focuses on three common ones, this list append function (++), reverse, and map.\nFor each of these functions, a so-called vanish combinator is defined, analogously to the\nbuild function – for example, vanish(++) for the append function. This combinator is applied to an expression which has had all occurrences of (++) abstracted out. Rules analogous\nto the shortcut rule are applied, and applications of these functions are fused together. Type\ninference could derive these special forms automatically, by treating these list functions as\nadditional list constructors; it would be straightforward to extend the algorithm to do this.\nIt is unclear whether this would be desirable. In the cases of the (++), reverse, and map\nfunctions, type-based deforestation can derive worker/wrapper forms without any additional\nmodifications. The only possible gain would be if vanish combinators were defined for functions which cannot be deforested by the shortcut rule, such as zip. Further study would be\nnecessary to determine the feasibility of combining these two methods for deforestation.\n\nChapter 3\nImplementing the Type Inference\nAlgorithm\n3.1\n\nGHC and External Core\n\nOur implementation of type-based deforestation depends on a feature of the Glasgow Haskell\nCompiler (GHC) which allows code in Core, the intermediate language used by GHC, to\nbe written to files and read back in by GHC or other tools. Core, a typed intermediate\nlanguage based on the second-order typed λ-calculus, is used in the middle end of GHC, which\nencapsulates most of the transformations and optimizations performed by GHC [PJS98].\nExternal Core, the language on which our implementation operates, is a version of Core\nthat has been modified to make it more suitable for exchange with external programs. The\nabstract syntax of External Core is given in Figure 3.1 as a Haskell datatype declaration,\nbased on [Tol01].\nA module consists of a name, a list of definitions for user-defined types (Haskell data and\nnewtype declarations), and a list of binding groups, each of which consists of either a single\nnon-recursive definition or a possibly mutually recursive group of definitions. We omit the\nsyntax for Tdef as it is irrelevant.\nThe types Var, Dcon, Tvar, Tcon, and Mname are all synonyms for String. Uses of variables, data constructors, and type constructors (Var, Dcon, and Tcon) are always qualified\n(paired with a module name); λ-bound and let-bound variables have the module name \"\".\nThe Lit type includes integer, rational, character, and string literals. Type application is\ndistinguished from term application syntactically (which it must be, since a type is distinct\nfrom a term), but type abstractions and term abstractions are both represented by the Lam\nconstructor. All variables bound by Lam, Let, and Case expressions are annotated with their\ntypes (or kinds, in the case of type variables; we omit the syntax for Kind here). Let binds\na mutually recursive group of definitions. A Case statement binds the scrutinee expression\nto a new name which may be used in the alternatives; case alternatives can pattern-match\non either data constructor applications, literals, or “anything” (Adefault). A Note form\nattaches some compiler-inserted annotation to an expression; an External form represents\na foreign function call, whose type must be provided. A type is either a type variable, a type\nconstructor, a type application, or a forall type.\nOur implementation reads in External Core files, transforms them, and writes the results\nto new External Core files that will then be compiled to executable form by GHC. GHC\n\n24CHAPTER 3. IMPLEMENTING THE TYPE INFERENCE ALGORITHM\n\ndata Module = (Module Mname [Tdef] [Vdefg])\ndata Exp\n= Var (Qual Var)\n| Dcon (Qual Dcon)\n| Lit Lit\n| App Exp Exp\n| Appt Exp Ty\n| Lam Bind Exp\n| Let Vdefg Exp\n| Case Exp Vbind [Alt] -- the list must be non-empty\n| Coerce Ty Exp\n| Note String Exp\n| External String Ty\ndata Ty\n= Tvar Tvar\n| Tcon Tcon\n| Tapp Ty Ty\n| Tforall Tbind Ty\ndata Vdefg\n= Nonrec Vdef\n| Rec [Vdef]\ntype Qual a = (Mname, a)\nnewtype Vdef = Vdef (Qual Var,Ty,Exp)\ndata Bind\n= Vb Vbind\n| Tb Tbind\ntype Vbind = (Var,Ty)\ntype Tbind = (Tvar,Kind)\ndata Alt\n= Acon (Qual Dcon) [Tbind] [Vbind] Exp\n| Alit Lit Exp\n| Adefault Exp\n\nFigure 3.1: The syntax of External Core\n\n3.2. IMPLEMENTATION DETAILS\n\n25\n\ngenerates External Core after performing all Core simplifications and optimizations; we turn\non most of GHC’s optimizations, since this gives us code in a more useful form (for example,\nsome inlining is already done and type classes are mostly specialized away). However, we are\nsure to turn off GHC’s deforestation when compiling code to be read in by our implementation, since we would like to find out whether our implementation performs deforestation\nin all the cases that GHC does. We chose to take this approach rather than implementing\ntype-based deforestation as a transformation pass in GHC in order to avoid making modifications to GHC. Sadly, in the end, we have probably made more modifications to GHC than\nwe would have made otherwise, since we found and fixed many bugs related to the External\nCore facility.\n\n3.2\n\nImplementation Details\n\nWe list each major phase of the implementation here, and give more details on some of them\nin sections to follow.\n1. Get the command-line arguments, consisting of a list of filenames containing External\nCore code.\n2. Read in the files and parse their contents, resulting in a list of Core ASTs (which we\nwill refer to from now on as “the program”). In addition, read in Core versions of\ncertain library modules which contain code that might be amenable to deforestation\n(including the List and Enum modules, among others).\n3. Perform dead code elimination, in order to remove any unused library code (this is\nonly necessary to improve the performance of the implementation).\n4. Read in the type environment for all the modules in GHC’s base package, since the\ntype inference phase will need to know the types of every variable mentioned in the\nprogram. The type environment is stored as an external file; alternatively, we could\nparse in all library files every time we run deforestation, but this would be very slow.\n5. Build a call graph for the program, which will be used later by the heuristics that\ndetermine which functions to worker/wrapper split.\n6. Specialize any polymorphically typed functions that produce lists. (see Section 3.2.1)\n7. Perform list abstraction, which creates worker and wrapper definitions for as many\nfunctions as possible (this phase includes inlining any wrappers that are determined\nnecessary to inline). (see Section 3.2.2)\n8. Apply the shortcut rule wherever possible. (see Section 3.2.3)\n9. Perform dead code elimination, to get rid of any definitions that might have been\ninlined everywhere they were used.\n10. Specialize any worker applications to the types and terms to which they are applied,\nif possible. (see Section 3.2.4)\n\n26CHAPTER 3. IMPLEMENTING THE TYPE INFERENCE ALGORITHM\n11. Perform the static argument transformation. (see Section 3.2.4)\n12. At this point, we may have created worker/wrapper definitions for some library functions. To avoid duplicating code already provided by libraries that hasn’t been changed\nby the transformation, we rename any functions present in the library modules that\nwere not originally defined in these modules, and write these modules to new modules\nthat have different names.\n13. Write out each transformed module to a file.\n\n3.2.1\n\nSpecializing Polymorphic Functions\n\nFor reasons discussed in Section 3.2.2, having to do with the combination of worker/wrapper\nsplitting and type-based inlining that we use, it is desirable to make specialized copies of all\ntype applications of polymorphic functions that produce lists. For example, if the program\ncontains the following expression:\nmap @ Int @ Int square [1,2,3]\n[...]\nmap :: forall a b . (a -> b) -> [a] -> [b]\nmap a b (f::(a -> b)) (xs::[a]) = \\ @ a @ b f xs -> ...\nwe will create a copy of map that is specialized to the type arguments Int, Int and replace\nthis application of map with a call to the specialized copy:\nmap_spec1 square [1,2,3]\n[...]\nmap_spec1 :: (Int -> Int) -> [Int] -> [Int]\nmap_spec1 (f::(Int -> Int)) (xs::[Int]) = \\ f xs -> ...\nIn addition, if a function is applied more than once to the same combination of type arguments, we will call the same specialized copy in each case, in order to avoid creating multiple\nidentical specialized definitions.\n\n3.2.2\n\nList Abstraction\n\nList abstraction consists of the following steps:\n1. Perform worker/wrapper splitting on the program.\n2. Some definitions may require certain other functions to have worker/wrapper definitions in order to be worker/wrapper split. If the previous pass of worker/wrapper\nsplitting, discovered any of these, we inline the wrappers of those that have already\nbeen worker/wrapper split.\n3. Perform β-reduction where necessary.\nWe repeat these steps some fixed number of times, since worker/wrapper splitting some\ndefinitions may enable more definitions to be worker/wrapper split.\n\n3.2. IMPLEMENTATION DETAILS\n\n27\n\nWorker/Wrapper Splitting Combined With Type-Based Inlining\nIn [Chi00], the deforestation algorithm presented only performs worker/wrapper splitting\nduring the list abstraction stage, and in the following stage inlines all wrappers everywhere.\nHowever, Chitil does suggest that this might be combined with the type-based inlining originally described in [Chi99], so that wrappers of functions are only inlined within definitions\nwhere the type of the definition depends on the type of the function. We implemented\nthis combined approach, because we found that when wrappers are inlined everywhere, the\nperformance of the resulting program can actually become worse (incongruously enough,\nsince the worker/wrapper scheme was originally devised in order to avoid the inefficiency\nintroduced by aggressive inlining). This can happen when the result of a function that has\na worker/wrapper pair is not actually consumed by foldr. The resulting program will contain expressions like (mapW @ Int @ Int @ [Int] @ [Int] ((:) @ Int) ([] @ Int) f\nxs), in which mapW has additional (useless) arguments that the original definition of map\ndoes not have. In practice, this can make the performance of the resulting program quite\npoor, possibly overshadowing any gains from deforestation. In Section 3.2.4, we discuss the\nways in which we originally attempted to address the problem of inefficient workers, but\nselectively inlining wrappers supersedes these approaches. (However, they remain present in\nthe implementation, for redundancy’s sake.)\nNow we can explain why the specialization pass mentioned in Section 3.2.1 is necessary. A\nsubtle detail of the list replacement phase of worker/wrapper splitting is that we cannot\nreplace a list type [a], where a is a free type variable, with a new type variable. To explain\nwhy, we give an example:\nfoo =\nlet (l1::[Int]) = map square [1,2]\n(l2::[Char]) = map toUpper [’a’,’b’]\nin ....\nmap :: forall a . b . (a -> b) -> [a] -> [b]\nWhen we do list replacement on the type of map in the type environment, we assign the type\nforall a b. (a -> b) -> t1 -> t2 to map, where t1 and t2 are free type variables. We\nalso replace list types in foo, giving us:\nfoo =\nlet (l1::t3) = map square [1,2]\n(l2::t4) = map toUpper [’a’,’b’]\nin ....\nmap :: forall a . b . (a -> b) -> t1 -> t2\nIn effect, map is being used polymorphically, but replacing [a] with a single type variable has\nmade map no longer polymorphic – map now returns something of type t2, a type which has\nno relationship to the type of the function argument, (a -> b). Type inference will unify t3\nand t4 with t2, implying that l1 and l2 have the same type, and if list abstraction succeeds,\nthat l1 and l2 can be built using the same constructor variables. This is clearly unsound.\nThus, list replacement will not replace list types containing free type variables, which means\n\n28CHAPTER 3. IMPLEMENTING THE TYPE INFERENCE ALGORITHM\nthat worker/wrapper splitting will never succeed on functions that build their results by\ncalling polymorphic list-producing functions. We solve this problem by specializing these\npolymorphic functions, as described in Section 3.2.1.\nTo summarize the worker/wrapper splitting algorithm we use:\n1. For each definition in the program, try to perform worker/wrapper splitting as described in Section 2.6. In addition, during the list replacement phase, we determine\nthe set of free names used in the definition body e, and for each name n in this set, we\nlook up its type t in the global environment; if t exists, we replace all list types in it\nwith type variables, and extend the global environment with (n,t).\n2. If abstraction fails, we return the original definition d. If it succeeds, we must determine\nwhether or not the resulting, abstracted type t depends on type variables that are free\nin some type in the global environment. We look up the type of each free variable v\nin e and check whether it contains any free variables that were unified with variables\ncontained in t. If so, we add v to a global environment1 mapping d onto a list of\nwrappers that should be inlined in d. If the resulting list of wrappers is non-empty, we\nreturn the original definition; otherwise, we return the worker/wrapper pair.\n3. For each definition d in the program, look up the list of wrappers l that should be\ninlined in d. Of course, not all the variable names in this list may actually have\nwrapper definitions, so we check whether all the names are actually wrapper names\n(this can be done using a global data structure). If so, we inline them. If not, we\nreturn d unchanged. The reason why we only inline the wrappers for d if all of them\nare wrappers is that it may not be possible to construct worker/wrapper pairs for all\nthe definitions named in l; if it’s not, we run the risk of inefficiency resulting from\nworkers not involved in deforestation, as explained above.\n4. Perform β-reduction where necessary.\nConsumer Worker/Wrapper Splitting\nAt this point, the astute reader might be wondering how the shortcut rule can ever be\nperformed on an expression like (sum (someListProducer)). Even if (someListProducer)\nis worker/wrapper split and the wrapper is inlined, the expression takes the form (sum\n(someListProducerW @ [a] ((:) a) ([] a))). sum is defined in terms of foldr, but\nthat’s not apparent here – the shortcut rule only applies in cases where foldr is literally\napplied to an expression that be list-abstracted. We could address this issue by inlining the\ndefinitions of all functions that contain foldr, and our implementation originally did this, but\nas one might expect, this sometimes made the performance of the resulting program worse,\nsince not every instance of foldr consumes an expression that can be list-abstracted. Instead,\nwe adopt a variation on the worker/wrapper scheme for list consumers, which was outlined in\n[Chi00]. Worker/wrapper splitting for list consumers is simpler than the analogous method\nfor list producers, as it requires no type-based analysis. We illustrate it with an example:\n1\n\nthat is, “global” as in “contained in the state of the monad in which the entire deforestation algorithm\nruns\n\n3.2. IMPLEMENTATION DETAILS\n\n29\n\nsum :: [Int] -> Int\nsum (xs::Int) = foldr (+) 0 xs\n==>\nsum :: [Int] -> Int\nsum (xs::[Int]) =\nsumW @ [Int]\n(\\ @ t (v_cons::(Int -> t -> t)) (v_nil::t) ->\nfoldr @ Int @ t v_cons v_nil xs)\nsumW :: (forall t . (Int -> t -> t) -> t -> t) -> Int\nsumW (xs::(forall t . (Int -> t -> t) -> t -> t)) = xs @ Int (+) 0\nFor any definition that applies (foldr @ a @ t k z), for some k and z, to one of its list\narguments (l::[a]), where l is not used in any other way, we replace the foldr application\nwith (l @ t k z), and change the type of l in its λ-binding to forall t . (a -> t ->\nt) -> t -> t, in order to make the worker body. Now, instead of taking a list argument,\nthe worker takes a generalized list producer. Note that this is an example of higher-order\npolymorphism, which is not supported in the Haskell standard, but which is allowed in GHC\nCore. The wrapper body applies the worker to [a] and passes in a generalized list producer\nwhich simply applies (foldr @ a @ t c n) to the wrapper’s list argument, where t, c,\nand n are the arguments passed to the generalized list producer. Effectively, the foldr is\nbrought outside the function body, where it can be inlined as part of the wrapper. Applying\nthe shortcut rule can then proceed as follows:\n(sum someListProducer)\n==> (after worker/wrapper splitting of {\\tt sum} and inlining)\n(sumW @ [Int] (\\ @ t (v_cons::(Int -> t -> t)) (v_nil::t) ->\nfoldr @ Int @ t v_cons v_nil someListProducer))\n==> (after worker/wrapper splitting of {\\tt someListProducer} and inlining)\n(sumW @ [Int] (\\ @ t (v_cons::(Int -> t -> t)) (v_nil::t) ->\nfoldr @ Int @ t v_cons v_nil (someListProducerW @ [Int] ((:)\n[Int]) ([] Int)))))\n==> (after applying the shortcut rule)\n(sumW @ [Int] (\\ @ t (v_cons::(Int -> t -> t)) (v_nil::t) ->\n(someListProducerW @ Int t v_cons v_nil)))\nsumW just applies its argument to (+) and 0, so in this modified expression, someListProducer\nproduces its sum directly rather than constructing an intermediate list and summing it up.\nFor functions that both consume and produce a list, such as map, a worker/wrapper pair can\nbe constructed that combines consumer and producer worker/wrapper splitting: just perform consumer worker/wrapper splitting first, and then perform producer worker/wrapper\nsplitting on the resulting worker.\n\n3.2.3\n\nApplying the Shortcut\n\nAfter all worker/wrapper splitting has concluded, we perform shortcut deforestation as described in Section 2.6. The only other detail is that in some cases where list abstraction\n\n30CHAPTER 3. IMPLEMENTING THE TYPE INFERENCE ALGORITHM\nfails on an expression, it may designate a list of wrappers to be inlined in that expression, so\nwhen abstraction fails, we inline those wrappers as in Section 3.2.2 and return the resulting\nexpression, in the hopes that some future iteration of deforestation may be able to perform\nthe shortcut on it.\n\n3.2.4\n\nEliminating Inefficient Workers\n\nA major problem with worker/wrapper splitting is that workers whose results are not consumed by foldr at some particular instance where wrapper inlining was performed are less\nefficient than their original definitions, as they take extra arguments (and must pass these\narguments to any recursive calls they make), and they call polymorphic functions to construct their results rather than data constructors whose types are statically apparent. This\nis less of an issue in our current implementation, since wrappers are inlined only on demand.\nIt is still somewhat of an issue, since every wrapper is defined in terms of its worker, so\neven when wrappers are not inlined, calling the wrapper means applying the worker to some\nconstructor arguments. It is possible to inline each worker in the body of its wrapper, but a\nmore general solution is to use specialization.\nSpecialization\nAfter deforestation, we search for applications of workers to “constant” type and constructor\narguments – that is, any arguments that don’t contain free type or term variables. We replace\nthese applications with calls to specialized copies of the workers, such as in the following\nexample:\nmapW @ Int @ Int @ [Int] ((:) Int) ([] Int) square [1,2]\nmapW :: forall a b t . (b -> t -> t) -> t -> (a -> b) -> [a] -> t\nmapW @ a @ b @ t (c::(b -> t -> t)) (n::t) (f::a -> b) (xs::[a]) =\ncase xs of\n[] -> n\n(y:ys) -> c (f y) (mapW @ a @ b @ t c n ys)\n===>\nmapW_spec1 square [1,2]\nmapW_spec1 :: (Int -> Int) -> [Int] -> Int\nmapW_spec1 (f::Int -> Int) (xs::[Int]) =\ncase xs of\n[] -> []\n(y:ys) -> (f y):(mapW_spec1 f xs)\nmapW spec1 looks a lot like the original definition of map, except that it has been specialized\nto type Int for its first two type arguments.\nSpecialization can potentially lead to code blowup if workers are applied in many different\nways (we attempt to use the same specialized copies to replace applications of the same\nworker to the same arguments, but this sometimes fails, for example when arguments are\nonly equal modulo α-renaming), but in practice this does not seem to be a problem.\n\n3.2. IMPLEMENTATION DETAILS\n\n31\n\nThe Static Argument Transformation\nMost worker definitions derived by our algorithm only call themselves recursively on the same\nconstructor arguments are passed (if at all) – for example, this is true of the worker definition\nof map given above. It is unnecessary to pass these extra arguments through each recursive\ncall. Instead, as [Chi00] suggests, we can perform the static argument transformation:\nfW @ t c n xs =\n... (fW @ t c n xs) ...\n==>\nfW @ t c n xs =\nlet fW’ xs =\n.... (fW’ xs) ....\nin fW’ xs\nAs formulated in [Chi99], the worker/wrapper splitting does this already, but the polymorphically recursive worker/wrapper splitting algorithm detailed in [Chi00], which we implement,\ndoes not, so we must perform the static argument transformation on all worker definitions\nas a postprocessing step.\n\n32CHAPTER 3. IMPLEMENTING THE TYPE INFERENCE ALGORITHM\n\nChapter 4\nExperimental Results\n4.1\n\nThe Nofib Suite\n\nWe tested our implementation on programs from the nofib suite, a benchmark suite for\nHaskell [Par93]. The suite is divided into three categories: “imaginary”, containing toy\nprograms such as programs to solve the n-queens problem and compute Fibonacci numbers\n(contrary to the name of the suite); “spectral”, containing medium-sized programs such as\na constraint solver and various scientific simulations; and “real”, consisting of real applications contributed by users, such as a strictness analyzer and an implementation of the\n“grep” search-and-replace program. We included nine “imaginary” programs, 55 “spectral”\nprograms, and 25 “real” programs in our tests. The programs range from 12 to 10,000 lines\nin size, and each consists of anywhere from one to 32 modules.\n\n4.2\n\nExperimental Methods\n\nFor each benchmark, we produced three executable programs, compiled in each of the following ways:\n1. No deforestation (compiled with ghc -frules-off to disable GHC’s deforestation)\n2. GHC’s deforestation turned on (compiled with normal GHC)\n3. Compile the program to External Core, run type-based deforestation on it, compile\nthe reuslt with ghc -frules-off\nWe compiled all the programs with GHC’s profiling turned on, so that we could measure the\namount of heap memory allocated by each program. When we speak of programs getting\n“better” or “worse” in the coming sections, we are always referring to allocation, rather than\ntime. We have not yet collected data on the effect type-based deforestation has on running\ntime, as we found that GHC’s time profiling was not as reliable as its allocation profiling.\nWe always ran GHC with the -O1 option to enable most optimizations, since when optimization is on, GHC does many transformations such as resolving type class overloading that\nput the program into a more convenient form for deforestation.\nWe made one change to GHC, having to do with list comprehensions. List comprehensions\nare a feature of Haskell that can either be desugared using foldr and build [GLP93], or\n\n34\n\nCHAPTER 4. EXPERIMENTAL RESULTS\n\nin a more efficient manner. Normally, GHC only uses the foldr/build desugaring when\ndeforestation is enabled. We changed GHC to use this desugaring unconditionally, since it\nis important that we run our deforestation on non-deforested code, in order to make sure we\ncatch all the opportunities for deforestation that GHC exploits.\nIn addition, we changed a few library functions, such as map and filter, to be defined in\nterms of foldr, since in theory, if deforestation is effective, then these functions should be\nwritten this way.\n\n4.3\n\nResults\n\nFigure 4.1: Type-based deforestation compared to no deforestation\nFigure 4.1 shows the results of compiling the nofib suite using type-based deforestation,\ncompared to no deforestation. For each n, bar n shows the number of benchmarks where\nthe amount of memory allocated decreased by anywhere between n and n - 5 percent.\nAs we would expect, the mode of the improvements is zero. As Peyton Jones, Tolmach\nand Hoare commented in [PJTH01], “Compiler optimisations are like therapeutic drugs.\nSome, like antibiotics, are effective on many programs... Others are targeted at specific\n’diseases’, on which they tend to be devastatingly effective, but have no effect at all on most\nother programs.” However, there is a significant class of programs on which deforestation ıis\ndevastatingly effective, as we see from the graph.\nThe benchmark program which improves the most is parstof, in the spectral category of\nthe nofib suite. Deforestation decreases the amount of memory allocated by this program,\na parser for a simple language, by 93%. This result was also achieved by GHC’s builtin deforestation, as documented in [PJTH01] (though the current version of GHC doesn’t\nachieve this result) – the outer loop of the program parses a sample input 40 times, and\ndeforestation transforms it so that the text is only parsed once. A real program would not\nbe written this way, so this result is somewhat of an artifact of the style in which some\nbenchmarks are written. The next-best improvers are integrate (which, as one might\n\n4.4. COMPARISON WITH GHC\n\n35\n\nguess, performs numerical integration), in the imaginary category, and cryptarithm1, in\nthe spectral category, a program that solves a particular instance of the “crypto-arithmetic”\npuzzle – in this case, finding a solution to the equation\nthirty + 5 * twelve = ninety\nwhere each letter represents a digit between 0 and 9. Both of these programs perform “bulk”\noperations on lists, in the words of [PJTH01]; for example, cryptarithm1’s main body\nconsists of applying filter to a list of permutations of the digits from 0 to 9. The body of\nthe function that computes permutations is defined in terms of several list comprehensions,\nwhich are desugared using foldr/build. Deforestation is well-suited for programs such as\nthis one, that consist a simple “pipeline” where a list is passed to and returned by each\n“pipeline stage” (in this case, the stages are enumFromTo, which constructs the list [0..9];\npermutations, a user-defined function which computes the permutations of this list; and\nfilter, which selects those permutations which are solutions of the equation).\nThe benchmark program whose allocation is worsened the most by deforestation is integer,\nin the spectral category, whose allocation is increased by 15%. The program is meant to\ntest the performance of Haskell’s built-in integer operation, and its main function looks like\nthis:\nintbench op astart astep alim bstart bstep blim =\nseqlist ([ a ‘op‘ b\n| a <- [ fromInteger astart,\nfromInteger astart + fromInteger astep ..\nfromInteger alim ]\n, b <- [ fromInteger bstart,\nfromInteger astart + fromInteger bstep ..\nfromInteger blim ]])\nThe seqlist function takes a list of elements and forces each one to be evaluated, using\nHaskell’s seq primitive, so the intbench function constructs a list of integer expressions\nand forces each one to be evaluated. Thus, there is no real opportunity for deforestation\nhere, since the entire list will always be demanded. However, since the list comprehension\nthat is the argument to seqlist is desugared into an expression involving foldr, shortcut\ndeforestation will be performed, but the net effect is only to create inefficient workers. The\nsecond-worse program, whose allocation is worsened by 7% (compared to no deforestation\n– it improves by 12% compared to GHC’s deforestation, curiously), is sphere, a raytracing\nprogram, also in the spectral category. This program has some auxiliary list functions that\nare defined in terms of list comprehensions that are not responsible for a significant amount\nof allocation, and converting these to worker/wrapper form results in inefficient workers that\nincrease the overall amount of allocation, as in integer.\n\n4.4\n\nComparison with GHC\n\nFigure 4.2 is analogous to Figure 4.1, except the baseline is now compiled with GHC’s\ndeforestation turned on.\nIt is clear that many of the positive results obtained above are solely due to type-based\ndeforestation reproducing the same results that GHC achieves; however, there is still a\n\n36\n\nCHAPTER 4. EXPERIMENTAL RESULTS\n\nFigure 4.2: Type-based deforestation compared to GHC’s shortcut deforestation\nsignificant class of programs that type-based deforestation improves appreciably. Note that\nseveral programs now perform worse with type-based deforestation than without – this is\nnot due to type-based deforestation changing the program in a way that makes it perform\nworse, but because type-based deforestation fails to reproduce the improvements that GHC\nmakes in these cases.\nThe best improvers compared with GHC are the same as the best improvers listed in Section 4.3. The program whose allocation is worsened the most is integer, as in Section 4.3\nThe second-worst is infer, an implementation of Hindley-Milner type inference, in the real\ncategory, whose allocation is worsened by -12% (ironically enough). This result is due to\na few frequently called functions being consumer worker/wrapper split (see Section 3.2.2);\nthe resulting code contains extra, unnecessary calls to foldr which are not eliminated by\nspecialization.\n\n4.5\n\nDeforestation Can Make Performance Worse\n\nIn the process of testing and refining our implementation, we encountered many programs\nthat were apparently made worse by type-based deforestation. In most of these cases, we\nwere able to adapt the implementation so that these programs were no longer made worse,\nand whatever benefits it achieved on other programs were preserved. However, we would\nexpect to encounter the phenomena enumerated below if we tested the implementation on a\nwider range of programs.\n\nInefficient Workers\nA worker/wrapper definition of a given function is inherently less efficient than the original\nfunction, since the new function takes extra arguments, constructs its results using unknown\nfunctions rather than literal list constructors (possibly defeating other optimizations), and\nmust pass the constructor arguments to any recursive calls it makes. If the static argument\n\n4.5. DEFORESTATION CAN MAKE PERFORMANCE WORSE\n\n37\n\ntransformation is performed, as it is in our implementation, the last problem is averted, except when we create polymorphically recursive worker definitions. But in general, whenever\nwe create a worker/wrapper pair and inline the wrapper, it is possible that the result of the\ncall to the worker will not be consumed by a foldr, and so we have effectively de-optimized\nthe function under consideration, leading to an increase in allocation that may cancel out\nany decrease achieved by deforestation at other call sites. In an early implementation of our\nsystem that inlined wrappers everywhere rather than doing so in a type-directed way, this\nwas a major problem. It is much less of a problem now that we inlined wrappers only where\nnecessary, but it is still somewhat of an issue.\n\nWork Duplication\nConsider the following expression:\nlet (x::[Int]) = map someExpensiveFunction [1..n] in\n... x ... x ...\nList abstraction creates a worker/wrapper definition for x:\nlet (x::[Int]) = xW @ [Int] ((:) Int) ([] Int)\n(xW :: forall t . (Int -> t -> t) -> t -> t) =\n\\ c n -> mapW @ t c n someExpensiveFunction [1..n] in\n... (xW @ [Int] ((:) Int) ([] Int)) ... (xW @ [Int] ((:) Int) ([] Int)) ...\nIn the original program, x is only computed once, due to the call-by-need semantics of\nHaskell: x is computed the first time it is used, and then the closure that represents it is\noverwritten with its value, which is used the second time. But in the transformed program,\nx has become a function rather than a constant value, so x is computed more than once,\ncalling someExpensiveFunction twice as often as before.\nWe encountered cases like this in the nofib suite, and attempted to address the problem in\ntwo ways. Initially, we avoided worker/wrapper splitting definitions of type [a] (rather than\na function type) if the definition’s right-hand side was determined to do “interesting” work\n(our heuristic for “interestingness” was that it called functions defined outside the enclosing\nmodule). Though this prevented many of the programs that previously were made worse\nby deforestation from getting worse, it also prevented some of the programs that previously\nimproved from improving. We found that a better solution was to compute an approximation\nthe number of times that a let-bound definition of a constant list, like x above, was used in\nits body, and avoid worker-wrapper splitting it if it was used more than once. This method\nis not foolproof, because in general computing the number of times x will really be used is\nundecidable – however, taking a first-order approximation (counting the number of times x\nliterally appears in the body) seems to be adequate. Usually, though, it seems to prevent\nprograms from getting much worse while not negating the benefits achieved by deforesting\nother programs. It is an inherent limitation of shortcut deforestation that only lists which\nare used once can be eliminated, so it is natural to avoid trying to deforest lists that are\nused multiple times.\n\n38\n\nCHAPTER 4. EXPERIMENTAL RESULTS\n\nMutually Recursive Functions\nConsider the following code (simplified from actual code generated by GHC for the mandel2\nbenchmark in the nofib suite):\na = f b\nb = g a\na and b compute an infinite list – each one calls the other to generate some portion of the\nlist, and then applies some function to it. We can see that even if f is defined in terms of\nfoldr, we cannot apply the shortcut rule in the body of a. We cannot eliminate an infinite\nlist. However, worker/wrapper splitting may derive worker definitions for these functions:\naW = \\ @ t c n -> f (bW @ t c n)\nbW = \\ @ t c n -> g (aW @ t c n)\nThis makes performance much worse, since two extra term arguments are now passed to\neach recursive call of a or b. In addition, these worker instances cannot be specialized, since\nattempting to create specialized versions of bW or aW would lead to an infinite regress. Our\nimplementation constructs a call graph for the program and avoids worker/wrapper splitting\nany functions that are involved in a cycle of length 2. Obviously, this does not handle the\ncase where more than 2 functions construct a list in a mutually recursive way, but this avoids\nworsening performance in the common case.\n\nInteraction With Other Optimizations\nWhen working with compiler optimizations, it is a given that one optimization may prevent\nanother from being applied, resulting in worse performance than if only one optimization had\nbeen applied rather than several. It is possible that type-based deforestation may prevent\nother optimizations that GHC would have applied, leading to overall worse performance,\nor that optimizations GHC performed before generating External Core might transform a\nprogram into a form unsuitable for deforestation. It would be desirable to carefully study\nthe effect the interaction between deforestation and other optimizations, but we leave this as\nfuture work. In the meantime, we note that deforestation might result in better performance\nif it were integrated as a transformation pass in GHC rather than running as an external\npass: in our system, GHC applies its transformations a number of times, then we perform\ndeforestation, then GHC does its transformations again; if deforestation were interleaved\nwith other transformations, better results might be achieved.\n\n4.6\n\nMeasuring Lists Allocated\n\nBesides measuring the total amount of memory a program allocated with and without allocation, it is also desirable to measure the amount of memory it allocates that is part of a list\ndata structure. If deforestation achieves a 0% improvement on a given program P, we would\nlike to know whether that is because deforestation is missing some opportunities present in\nP, or because P just doesn’t allocate many lists.\nWe modified GHC’s profiling system to output the total amount of memory allocated in\nlists as well as the total allocation. Figure 4.3 plots, for each of the nofib programs, the\n\n4.6. MEASURING LISTS ALLOCATED\n\n39\n\npercent improvement achieved by type-based deforestation versus the percentage of its total\nallocation that is part of some list data structure versus (compared to no deforestation).\n\nFigure 4.3: Improvement Achieved by Deforestation Versus Percentage of Memory Allocated\nFor Lists\nClearly, there is a large group of programs where 10% of total allocation or less consists\nof lists, and deforestation achieves no effect. We cannot hope to achieve better results on\nthese programs. However, there are also many programs where more than 40% of allocation\nconsists of lists, but deforestation achieves no effect. This does not necessarily imply that\nour implementation misses opportunities for deforestation in these cases. Some lists, after\nall, may be inherently necessary for the program’s computation. Explaining the reasons for\nthese results would require either closer examination of the programs for which deforestation’s\nimprovement is not proportional to the amount of lists allocated, a static or dynamic analysis\nto determine which lists are “truly intermediate”, or both.\n\n40\n\nCHAPTER 4. EXPERIMENTAL RESULTS\n\nChapter 5\nConclusions and Future Work\n5.1\n\nType-Based Deforestation Is Effective\n\nWe have shown that type-based deforestation achieves significant improvements in the amount\nof memory allocated by real programs; moreover, that it generally achieves equal or greater\nimprovements than those achieved by GHC’s built-in deforestation. There is further work to\nbe done in examining the programs that GHC’s deforestation improves more than type-based\ndeforestation does, and in studying the relationship between total amount of lists allocated\nand the potential improvement achieved by deforestation, but our work has made it clear\nthat the type-inference-based algorithm for deforestation is useful in practice.\n\n5.2\n\nFuture Work\n\n5.2.1\n\nIntegration with GHC\n\nIt would be desirable to incorporate our implementation as a transformation pass in GHC.\nThis would simplify the implementation greatly, reducing the amount of time required to\nrun experiments (the implementation repeats work such as parsing and building a type\nenvironment that would have already been done if it were a pass in GHC). Also, it might\nincrease the potential improvements achieved by deforestation, because deforestation would\nbe performed multiple times in concert with other optimizations that might create more\ndeforestation opportunities. The only way to find out whether this is the case would be to\nintegrate type-based deforestation with GHC.\n\n5.2.2\n\nArbitrary Data Structures\n\nIt is not difficult to imagine how the type inference algorithm might be extended to remove\narbitrary data structures, and not just lists. Shortcut deforestation can potentially eliminate\nvalues of any datatype for which a fold operation can be defined (it is trivial to generalize\nthe build operation to other types): for example, warm fusion is defined in a way that makes\nit applicable to arbitrary types [LS95]. It would not be hard to extend our implementation\nof type-based deforestation to remove arbitrary data structures, but problems might occur\nin practice, since programmers may be less likely to define functions that produce types\nother than lists in terms of a fold operation. A potential application for this generalized\n\n42\n\nCHAPTER 5. CONCLUSIONS AND FUTURE WORK\n\nform of deforestation is the style of generic programming in Haskell described in [LPJ03].\nThis paper describes a library that provides generic traversal functions for arbitrary userdefined datatypes, for example, combinators to allow a function defined on a certain algebraic\ndatatype that does something interesting only to values with one particular constructor to\nbe applied without writing out the cases for each constructor (what is known as the “visitor\npattern” in object-oriented programming). These traversals depend crucially on a “generic\nfold” operator, so it is possible that there might be many opportunities for deforestation in\nthese generic programs, which consume data structures using functions that are ultimately\ndefined in terms of fold.\n\n5.2.3\n\nProgrammer Annotations\n\nThe basic concern of type-based deforestation is to infer which functions construct lists\nthat are “virtual” – that only exist because of the particular way in which the programmer\nchose to express the algorithm, and are not essential to the computation being performed.\nBut programmers presumably have some knowledge about which if their functions have\nthis property. Why not allow them to express this knowledge by means of “virtuality”\nannotations on functions? These annotations could be used in the compiler to suggest\nplaces to try to apply deforestation, avoiding the work of trying to derive worker/wrapper\nforms for functions that produce lists that are not, in fact, virtual. Also, they could be used\nto provide useful feedback to the programmer. As the situation stands, a small change in\nthe program can make a big difference in its performance – a change that is trivial from\nthe programmer’s point of view may prevent deforestation from occurring. The programmer\ncannot predict when this will happen, without detailed knowledge of the compiler. With\nvirtuality annotations, however, the compiler could report back to the user when uses of\n“virtual” functions cannot be deforested. This would result in a more efficient optimization\nprocess and better predictability for the programmer.\n\nBibliography\n[BT84]\n\nTimothy Budd and Joseph M. Treat, “Extensions to Grid Selector Composition and Compilation in APL”, Information Processing Letters, Vol 19(3):\n117-123, (Oct 1984).\n\n[BD77]\n\nRod M. Burstall and John Darlington, “A transformation system for developing recursive programs”, Journal of the ACM, 24(1):44–67, January 1977.\n\n[Chi99]\n\nOlaf Chitil, “Type Inference Builds a Short Cut to Deforestation”, Proceedings\nof the International Conference on Functional Programming, 1999.\n\n[Chi00]\n\nOlaf Chitil, “Type-Inference Based Deforestation of Functional Programs”,\nPh.D thesis, Aachen University of Technology, 2000.\n\n[GLP93]\n\nAndrew Gill, John Launchbury, and Simon Peyton Jones, “A Short Cut to\nDeforestation”, Proceedings of the Conference on Functional Programming\nLanguages and Computer Architecture (FPCA ’93), pp. 223-232, 1993.\n\n[GW78]\n\nLeo J. Guibas and Douglas K. Wyatt, “Compilation and Delayed Evaluation\nin APL”, Proceedings of the ACM Symposium on Principles of Programming\nLanguages (POPL ’78), pp. 1-8, 1978.\n\n[Hug89]\n\nJohn Hughes, “Why Functional Programming Matters”, Computer Journal,\npp. 98-107, 1989.\n\n[LPJ03]\n\nRalf Lämmel and Simon Peyton Jones, “Scrap your boilerplate: a practical\ndesign pattern for generic programming”, Proceedings of the ACM Workshop\non Types in Language Design and Implementation (TLDI ’03), pp. 26-37,\n2003.\n\n[LS95]\n\nJohn Launchbury and Tim Sheard, “Warm Fusion: Deriving Build-Catas from\nRecursive Definitions”, Proceedings of the Conference on Functional Programming Languages and Computer Architecture (FPCA ’95), pp. 314-322, 1995.\n\n[LY98]\n\nOukseh Lee and Kangkeun Yi, “Proofs about a folklore let-polymorphic type\ninference algorithm”, ACM Transactions on Programming Languages and Systems, 20(4):707-723, July 1998.\n\n[Par93]\n\nWill Partain, “The nofib Benchmark Suite of Haskell Programs”, Functional\nProgramming, Glasgow 1992, J Launchbury & PM Sansom, eds., Workshops\nin Computing, Springer Verlag, 1993.\n\n44\n\nBIBLIOGRAPHY\n\n[PJM99]\n\nSimon Peyton Jones and Simon Marlow, “Secrets of the Glasgow Haskell Compiler inliner”, Proceedings of the Workshop on Implementing Declarative Languages, 1999.\n\n[PJS98]\n\nSimon Peyton Jones and André Santos, “A transformation-based optimiser\nfor Haskell”, Science of Computer Programming 32(1-3), pp3-47, September\n1998.\n\n[PJTH01]\n\nSimon Peyton Jones, Andrew Tolmach, and Tony Hoare, “Playing by the\nrules: rewriting as a practical optimisation technique in GHC”, Proceedings\nof the ACM/SIGPLAN Haskell Workshop, 2001.\n\n[Ste90]\n\nGuy Steele, Common Lisp: The Language, 2nd edition, Digital Press 1990.\n\n[Sve02]\n\nJosef Svenningsson, “Shortcut Fusion for Accumulating Parameters & Ziplike Functions”, Proceedings of the International Conference on Functional\nProgramming, 2002.\n\n[Tol01]\n\nAndrew Tolmach and the GHC Team, “An External Representation for the\nGHC Core Language” (draft), available at http://www.haskell.org/ghc/\ndocs/papers/core.ps.gz\n\n[Voi02]\n\nJanis Voigtlander, “Concatenate, Reverse and Map Vanish For Free”, Proceedings of the International Conference on Functional Programming, 2002.\n\n[Wad85]\n\nPhilip Wadler, “Listlessness is better than laziness II: Composing listless functions”, Proceedings of the Workshop on Programs as Data Objects, Copenhagen, October 1985. LNCS 217, Springer-Verlag, 1985.\n\n[Wad90]\n\nPhilip Wadler, “Deforestation: transforming programs to eliminate trees”,\nTheoretical Computer Science, v. 73, pp. 231-248, 1990.\n\n[Wat89]\n\nRichard Waters, “Optimization of Series Expressions: Part II: Overview of the\nTheory and Implementation”, MIT AI Lab Memo No. 1083, December 1989\n\n","pages":{"startPosition":[0,4995,9995,14997,20001,24991,29999,34997,39997,44998,50000,54996,59998,64999,70001,74999,80000,84995,89987]}},"html":{"comparison":{"identical":{"groupId":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40],"source":{"chars":{"starts":[3677845,3677862,3677870,3677887,3677895,3677912,3677920,3677937,3677945,3677962,3677970,3677987,3677995,3678012,3678020,3678037,3678045,3678062,3678070,3678087,3678095,3678112,3678120,3678145,3678162,3678170,3678187,3678195,3678212,3678220,3678237,3678245,3678262,3678270,3678287,3678295,3678312,3678320,3678337,3678345,3678362,3678370,3678387,3678395,3678696,3678713,3678721,3678738,3678746,3678763,3678771,3678788,3678796,3678813,3678821,3678838,3678846,3678863,3678871,3678888,3678896,3678913,3678921,3678938,3678946,3678963,3678971,3678988,3678996,3679597,3679614,3679622,3679639,3679647,3679664,3679672,3679689,3679697,3679714,3679722,3679739,3679747,3679764,3679772,3679789,3679797,3679814,3679822,3679839,3679847,3679864,3679872,3679889,3679897,3679914,3679922,3680867,3680884,3680892,3680909,3680917,3680934,3680942,3680959,3680967,3680984,3680992,3681009,3681017,3681034,3681042,3681059,3681067,3681084,3681092,3681109,3681117,3681134,3681142,3682014,3682031,3682039,3682056,3682064,3682081,3682089,3682106,3682114,3682131,3682139,3682156,3682164,3682181,3682189,3682206,3682214,3682231,3682239,3682256,3682264,3682642,3682659,3682667,3682684,3682692,3682709,3682717,3682734,3682742,3682759,3682767,3682784,3682792,3682809,3682817,3682834,3682842,3682859,3682867,3683246,3683263,3683271,3683288,3683296,3683313,3683321,3683338,3683346,3683363,3683371,3683388,3683396,3683413,3683421,3683438,3683446,3683463,3683471,3683779,3683796,3683804,3683821,3683829,3683846,3683854,3683871,3683879,3683896,3683904,3683921,3683929,3683946,3683954,3683971,3683979,3683996,3684004,3684021,3684029,3684046,3684054,3684071,3684079,3684096,3684104,3684121,3684129,3684146,3684154,3684171,3684179,3684196,3684204,3684221,3684229,3685140,3685157,3685165,3685182,3685190,3685207,3685215,3685232,3685240,3685257,3685265,3685282,3685290,3685307,3685315,3685332,3685340,3685357,3685365,3685382,3685390,3685407,3685415,3685432,3685440,3685457,3685465,3685482,3685490,3685507,3685515,3685532,3685540,3685557,3685565,3686129,3686146,3686154,3686171,3686179,3686196,3686204,3686221,3686229,3686246,3686254,3686271,3686279,3686296,3686304,3686321,3686329,3686694,3686711,3686719,3686736,3686744,3686761,3686769,3686786,3686794,3686811,3686819,3686836,3686844,3686861,3686869,3686886,3686894,3686911,3686919,3686936,3686944,3686961,3686969,3686986,3686994,3687011,3687019,3687036,3687044,3687061,3687069,3687086,3687094,3687111,3687119,3687136,3687144,3687161,3687169,3687186,3687194,3687211,3687219,3687236,3687244,3687261,3687269,3687286,3687294,3687311,3687319,3687336,3687344,3687944,3687961,3687969,3687986,3687994,3688011,3688019,3688036,3688044,3688061,3688069,3688086,3688094,3688111,3688119,3688136,3688144,3688161,3688169,3688186,3688194,3688211,3688219,3688236,3688244,3688261,3688269,3688286,3688294,3688311,3688319,3688336,3688344,3688361,3688369,3688386,3688394,3688411,3688419,3688436,3688444,3688461,3688469,3688486,3688494,3688511,3688519,3688536,3688544,3688561,3688569,3688586,3688594,3688611,3688619,3688636,3688644,3689874,3689891,3689899,3689916,3689924,3689941,3689949,3689966,3689974,3689991,3689999,3690016,3690024,3690041,3690049,3690066,3690074,3690091,3690099,3690116,3690124,3690141,3690149,3690166,3690174,3690191,3690199,3690216,3690224,3690241,3690249,3690266,3690274,3692647,3692664,3692672,3692689,3692697,3692714,3692722,3692739,3692747,3692764,3692772,3692789,3692797,3692814,3692822,3692839,3692847,3692864,3692872,3692889,3692897,3692914,3692922,3693697,3693714,3693722,3693739,3693747,3693764,3693772,3693789,3693797,3693814,3693822,3693839,3693847,3693864,3693872,3693889,3693897,3693914,3693922,3693939,3693947,3693964,3693972,3693997,3694014,3694022,3694039,3694047,3694064,3694072,3694089,3694097,3694114,3694122,3694139,3694147,3694164,3694172,3694189,3694197,3694214,3694222,3694239,3694247,3694264,3694272,3694289,3694297,3694314,3694322,3694339,3694347,3694364,3694372,3694389,3694397,3694414,3694422,3694439,3694447,3695509,3695526,3695534,3695551,3695559,3695576,3695584,3695601,3695609,3695626,3695634,3695651,3695659,3695676,3695684,3695701,3695709,3695726,3695734,3695751,3695759,3695776,3695784,3695801,3695809,3695826,3695834,3695851,3695859,3695876,3695884,3695901,3695909,3695926,3695934,3695951,3695959,3696321,3696338,3696346,3696363,3696371,3696388,3696396,3696413,3696421,3696438,3696446,3696463,3696471,3696488,3696496,3696513,3696521,3696538,3696546,3696563,3696571,3696588,3696596,3696613,3696621,3696638,3696646,3696663,3696671,3696688,3696696,3696713,3696721,3696738,3696746,3696763,3696771,3696788,3696796,3696813,3696821,3696838,3696846,3696863,3696871,3696888,3696896,3696913,3696921,3696938,3696946,3696963,3696971,3696988,3696996,3697388,3697405,3697413,3697430,3697438,3697455,3697463,3697480,3697488,3697505,3697513,3697530,3697538,3697555,3697563,3697580,3697588,3697605,3697613,3697630,3697638,3697655,3697663,3697680,3697688,3697705,3697713,3697730,3697738,3697755,3697763,3697780,3697788,3697805,3697813,3697830,3697838,3697855,3697863,3697880,3697888,3697905,3697913,3697930,3697938,3697955,3697963,3697980,3697988,3698005,3698013,3698030,3698038,3698438,3698455,3698463,3698480,3698488,3698505,3698513,3698530,3698538,3698555,3698563,3698580,3698588,3698605,3698613,3698630,3698638,3698655,3698663,3698928,3698945,3698953,3698970,3698978,3698995,3699003,3699020,3699028,3699045,3699053,3699070,3699078,3699095,3699103,3699120,3699128,3699145,3699153,3699170,3699178,3699195,3699203,3699220,3699228,3699245,3699253,3699681,3699698,3699706,3699723,3699731,3699748,3699756,3699773,3699781,3699798,3699806,3699823,3699831,3699848,3699856,3699873,3699881,3699898,3699906,3699923,3699931,3699948,3699956,3699973,3699981,3699998,3700006,3700023,3700031,3712449,3712466,3712474,3712491,3712499,3712516,3712524,3712541,3712549,3712566,3712574,3712591,3712599,3712616,3712624,3712641,3712649,3712666,3712674,3712691,3712699,3712716,3712724,3712741,3712749,3712766,3712774,3712791,3712799,3712816,3712824,3712841,3712849,3712866,3712874,3712891,3712899,3712916,3712924,3712941,3712949,3712966,3712974,3712991,3712999,3713016,3713024,3713041,3713049,3713066,3713074,3713091,3713099,3713116,3713124,3713141,3713149,3713166,3713174,3713191,3713199,3714769,3714786,3714794,3714811,3714819,3714836,3714844,3714861,3714869,3714886,3714894,3714911,3714919,3714936,3714944,3714961,3714969,3714986,3714994,3715011,3715019,3715036,3715044,3715061,3715069,3715086,3715094,3715111,3715119,3715136,3715144,3715161,3715169,3715186,3715194,3716229,3716246,3716254,3716271,3716279,3716296,3716304,3716321,3716329,3716346,3716354,3716371,3716379,3716396,3716404,3716421,3716429,3716446,3716454,3716471,3716479,3716496,3716504,3716529,3716546,3716554,3716571,3716579,3716596,3716604,3716621,3716629,3716646,3716654,3716671,3716679,3716696,3716704,3716721,3716729,3716746,3716754,3717086,3717103,3717111,3717128,3717136,3717153,3717161,3717178,3717186,3717203,3717211,3717228,3717236,3717253,3717261,3717278,3717286,3717303,3717311,3717328,3717336,3717353,3717361,3717378,3717386,3717403,3717411,3717428,3717436,3717453,3717461,3717478,3717486,3717503,3717511,3717835,3717852,3717860,3717877,3717885,3717902,3717910,3717927,3717935,3717952,3717960,3717977,3717985,3718002,3718010,3718027,3718035,3718052,3718060,3718077,3718085,3718102,3718110,3718135,3718152,3718160,3718177,3718185,3718202,3718210,3718227,3718235,3718252,3718260,3718277,3718285,3718302,3718310,3718327,3718335,3718352,3718360,3719062,3719079,3719087,3719104,3719112,3719129,3719137,3719154,3719162,3719179,3719187,3719204,3719212,3719229,3719237,3719254,3719262,3719279,3719287,3719304,3719312,3719329,3719337,3719362,3719379,3719387,3719404,3719412,3719429,3719437,3719454,3719462,3719479,3719487,3719504,3719512,3719529,3719537,3719554,3719562,3719579,3719587,3719604,3719612,3719629,3719637,3719654,3719662,3719679,3719687,3719704,3719712,3720834,3720851,3720859,3720876,3720884,3720901,3720909,3720926,3720934,3720951,3720959,3720976,3720984,3721001,3721009,3721026,3721034,3721051,3721059,3721489,3721506,3721514,3721531,3721539,3721556,3721564,3721581,3721589,3721606,3721614,3721631,3721639,3721656,3721664,3721681,3721689,3721706,3721714,3721731,3721739,3723212,3723229,3723237,3723254,3723262,3723279,3723287,3723304,3723312,3723329,3723337,3723354,3723362,3723379,3723387,3723404,3723412,3723429,3723437,3723454,3723462,3723479,3723487,3723512,3723529,3723537,3723554,3723562,3723579,3723587,3723604,3723612,3723629,3723637,3723654,3723662,3723679,3723687,3723704,3723712,3723729,3723737,3723754,3723762,3723779,3723787,3723804,3723812,3723829,3723837,3771437,3771464,3771472,3771489,3771497,3771514,3771522,3771539,3771547,3771564,3771572,3771589,3771597,3771614,3771622,3771639,3771647,3771664,3771672,3771689,3771697,3771714,3771722,3771739,3771747,3771764,3771772,3771789,3771797,3771814,3771822,3771839,3771847,3771864,3771872,3771889,3771897,3771914,3771922,3771939,3771947,3771964,3771972,3853195,3853223,3853231,3853248,3853256,3853273,3853281,3853298,3853306,3853323,3853331,3853348,3853356,3853373,3853381,3853398,3853406,3853423,3853431,3853448,3853456,3853473,3853481,3853498,3853506,3853523,3853531,3853548,3853556,3853573,3853581,3853598,3853606,3853623,3853631,3853648,3853656,3853673,3853681,3853972,3854003,3854011,3854028,3854036,3854053,3854061,3854078,3854086,3854103,3854111,3854128,3854136,3854153,3854161,3854178,3854186,3854203,3854211,3854228,3854236,3854253,3854261,3854278,3854286,3854303,3854311,3911662,3911690,3911698,3911715,3911723,3911740,3911748,3911765,3911773,3911790,3911798,3911815,3911823,3911840,3911848,3911865,3911873,3911890,3911898,3911915,3911923,3911940,3911948,4072054,4072083,4072091,4072108,4072116,4072133,4072141,4072158,4072166,4072183,4072191,4072208,4072216,4072233,4072241,4072258,4072266,4072283,4072291,4072308,4072316,4072333,4072341,4072358,4072366,4072383,4072391,4072408,4072416,4072433,4072441,4072458,4072466,4072483,4072491,4072508,4072516,4072533,4072541,4072558,4072566,4072583,4072591,4072608,4072616,4072633,4072641,4072658,4072666,4072683,4072691,4072708,4072716],"lengths":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,11,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]},"words":{"starts":[5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5805,5817,5817,5817,5817,5817,5817,5817,5817,5817,5817,5817,5817,5817,5817,5817,5817,5817,5817,5817,5817,5817,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5835,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5866,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5907,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5943,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5963,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5982,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,5999,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6044,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6080,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6096,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6135,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6198,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6280,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6311,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6323,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6374,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6400,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6436,6473,6473,6473,6473,6473,6473,6473,6473,6473,6473,6473,6473,6473,6473,6473,6473,6473,6473,6473,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6489,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6515,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6558,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6635,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6684,6696,6696,6696,6696,6696,6696,6696,6696,6696,6696,6696,6696,6696,6696,6696,6696,6696,6696,6696,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6714,6740,6740,6740,6740,6740,6740,6740,6740,6740,6740,6740,6740,6740,6740,6740,6740,6740,6740,6740,6740,6740,6740,6740,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6752,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6779,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6791,6841,6841,6841,6841,6841,6841,6841,6841,6841,6841,6841,6841,6841,6841,6841,6841,6841,6841,6841,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6862,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6914,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,6926,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,8154,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10008,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,10036,11091,11091,11091,11091,11091,11091,11091,11091,11091,11091,11091,11091,11091,11091,11091,11091,11091,11091,11091,11091,11091,11091,11091,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840,14840],"lengths":[11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26]}},"suspected":{"chars":{"starts":[557,557,557,557,557,557,557,557,557,557,557,557,557,557,557,557,557,557,557,557,557,557,557,630,630,630,630,630,630,630,630,630,630,630,630,630,630,630,630,630,630,630,630,630,654,654,654,654,654,654,654,654,654,654,654,654,654,654,654,654,654,654,654,654,654,654,654,654,654,719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,806,806,806,806,806,806,806,806,806,806,806,806,806,806,806,806,806,806,806,806,806,806,806,891,891,891,891,891,891,891,891,891,891,891,891,891,891,891,891,891,891,891,891,891,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,963,963,963,963,963,963,963,963,963,963,963,963,963,963,963,963,963,963,963,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1026,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1102,1283,1283,1283,1283,1283,1283,1283,1283,1283,1283,1283,1283,1283,1283,1283,1283,1283,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1346,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1432,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1545,1715,1715,1715,1715,1715,1715,1715,1715,1715,1715,1715,1715,1715,1715,1715,1715,1715,1715,1715,1715,1715,1715,1715,1787,1787,1787,1787,1787,1787,1787,1787,1787,1787,1787,1787,1787,1787,1787,1787,1787,1787,1787,1787,1787,1787,1787,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,1937,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2113,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2182,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2344,2430,2430,2430,2430,2430,2430,2430,2430,2430,2430,2430,2430,2430,2430,2430,2430,2430,2430,2430,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2454,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2520,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2628,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2799,2847,2847,2847,2847,2847,2847,2847,2847,2847,2847,2847,2847,2847,2847,2847,2847,2847,2847,2847,2847,2847,2847,2847,2895,2895,2895,2895,2895,2895,2895,2895,2895,2895,2895,2895,2895,2895,2895,2895,2895,2895,2895,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,2919,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,3088,3088,3088,3088,3088,3088,3088,3088,3088,3088,3088,3088,3088,3088,3088,3088,3088,3088,3088,3248,3248,3248,3248,3248,3248,3248,3248,3248,3248,3248,3248,3248,3248,3248,3248,3248,3248,3248,3248,3248,3248,3248,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3306,3389,3389,3389,3389,3389,3389,3389,3389,3389,3389,3389,3389,3389,3389,3389,3389,3389,3389,3389,3413,3413,3413,3413,3413,3413,3413,3413,3413,3413,3413,3413,3413,3413,3413,3413,3413,3413,3413,3413,3413,3485,3485,3485,3485,3485,3485,3485,3485,3485,3485,3485,3485,3485,3485,3485,3485,3485,3485,3485,3485,3485,3485,3485,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,3550,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2713,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,2271,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,1868,774,774,774,774,774,774,774,774,774,774,774,774,774,774,774,774,774,774,774,774,774,774,774,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602,1602],"lengths":[23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61]},"words":{"starts":[81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,218,230,230,230,230,230,230,230,230,230,230,230,230,230,230,230,230,230,230,230,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,252,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,340,340,340,340,340,340,340,340,340,340,340,340,340,340,340,340,340,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,398,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,443,505,505,505,505,505,505,505,505,505,505,505,505,505,505,505,505,505,505,505,505,505,505,505,527,527,527,527,527,527,527,527,527,527,527,527,527,527,527,527,527,527,527,527,527,527,527,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,576,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,634,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,714,747,747,747,747,747,747,747,747,747,747,747,747,747,747,747,747,747,747,747,759,759,759,759,759,759,759,759,759,759,759,759,759,759,759,759,759,759,759,759,759,759,759,759,759,759,759,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,777,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,812,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,884,908,908,908,908,908,908,908,908,908,908,908,908,908,908,908,908,908,908,908,908,908,908,908,924,924,924,924,924,924,924,924,924,924,924,924,924,924,924,924,924,924,924,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,936,960,960,960,960,960,960,960,960,960,960,960,960,960,960,960,960,960,960,960,960,960,960,960,993,993,993,993,993,993,993,993,993,993,993,993,993,993,993,993,993,993,993,1038,1038,1038,1038,1038,1038,1038,1038,1038,1038,1038,1038,1038,1038,1038,1038,1038,1038,1038,1038,1038,1038,1038,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1062,1094,1094,1094,1094,1094,1094,1094,1094,1094,1094,1094,1094,1094,1094,1094,1094,1094,1094,1094,1106,1106,1106,1106,1106,1106,1106,1106,1106,1106,1106,1106,1106,1106,1106,1106,1106,1106,1106,1106,1106,1130,1130,1130,1130,1130,1130,1130,1130,1130,1130,1130,1130,1130,1130,1130,1130,1130,1130,1130,1130,1130,1130,1130,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,1151,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,848,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464,464],"lengths":[11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26]}}},"minorChanges":{"groupId":[41,42],"source":{"chars":{"starts":[3697088,3717540],"lengths":[7,2]},"words":{"starts":[6429,6732],"lengths":[0,0]}},"suspected":{"chars":{"starts":[2240,2955],"lengths":[5,3]},"words":{"starts":[687,954],"lengths":[0,0]}}},"relatedMeaning":{"groupId":[43],"source":{"chars":{"starts":[3697353],"lengths":[7]},"words":{"starts":[6435],"lengths":[0]}},"suspected":{"chars":{"starts":[2330],"lengths":[13]},"words":{"starts":[712],"lengths":[1]}}}}},"version":3}